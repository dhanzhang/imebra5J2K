

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>DICOM dataSet &amp; tags classes &mdash; Imebra 5.2.1.1 changeset 906b3798 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/language_data.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="copyright" title="Copyright" href="copyright.html" />
    <link rel="next" title="UID generation classes" href="dicom_uid_generation_classes.html" />
    <link rel="prev" title="Objects lifecycle and Object ownership" href="objects_lifecycle.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> Imebra
          

          
          </a>

          
            
            
              <div class="version">
                5.2.1.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Download Imebra</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="download.html">Downloading Imebra</a></li>
</ul>
<p class="caption"><span class="caption-text">Legal</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="copyright.html">Copyright</a></li>
<li class="toctree-l1"><a class="reference internal" href="gplv2.html">GNU General Public License</a></li>
<li class="toctree-l1"><a class="reference internal" href="commercial.html">Commercial license</a></li>
</ul>
<p class="caption"><span class="caption-text">Introduction</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="changes_log.html">Changes log</a></li>
</ul>
<p class="caption"><span class="caption-text">User documentation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="compiling_imebra.html">Compiling Imebra</a></li>
<li class="toctree-l1"><a class="reference internal" href="logging.html">Logging</a></li>
<li class="toctree-l1"><a class="reference internal" href="add_to_project.html">Adding Imebra to your project</a></li>
<li class="toctree-l1"><a class="reference internal" href="quick_tour.html">Tutorial</a></li>
</ul>
<p class="caption"><span class="caption-text">API</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="objects_lifecycle.html">Objects lifecycle and Object ownership</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">DICOM dataSet &amp; tags classes</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#introduction">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="#data-storage">Data storage</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#dataset">DataSet</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#c">C++</a></li>
<li class="toctree-l4"><a class="reference internal" href="#objective-c-swift">Objective-C/Swift</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#mutabledataset">MutableDataSet</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id3">C++</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id4">Objective-C/Swift</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#tag">Tag</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id6">C++</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id7">Objective-C/Swift</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#mutabletag">MutableTag</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id9">C++</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id10">Objective-C/Swift</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#data-access">Data access</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#tagid">TagId</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id12">C++</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id13">Objective-C/Swift</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#readingdatahandler">ReadingDataHandler</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id15">C++</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id16">Objective-C/Swift</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#readingdatahandlernumeric">ReadingDataHandlerNumeric</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id18">C++</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id19">Objective-C/Swift</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#writingdatahandler">WritingDataHandler</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id21">C++</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id22">Objective-C/Swift</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#writingdatahandlernumeric">WritingDataHandlerNumeric</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id24">C++</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id25">Objective-C/Swift</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#date">Date</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id26">C++</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id27">Objective-C/Swift</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#age">Age</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id28">C++</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id29">Objective-C/Swift</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#patientname">PatientName</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id30">C++</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id31">Objective-C/Swift</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#unicodepatientname">UnicodePatientName</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id32">C++</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id33">Objective-C/Swift</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="dicom_uid_generation_classes.html">UID generation classes</a></li>
<li class="toctree-l1"><a class="reference internal" href="stream_classes.html">Stream classes</a></li>
<li class="toctree-l1"><a class="reference internal" href="imaging_classes.html">Imaging classes</a></li>
<li class="toctree-l1"><a class="reference internal" href="transforms_classes.html">Transforms classes</a></li>
<li class="toctree-l1"><a class="reference internal" href="memory_management_classes.html">Memory management classes</a></li>
<li class="toctree-l1"><a class="reference internal" href="acse_classes.html">ACSE classes</a></li>
<li class="toctree-l1"><a class="reference internal" href="dimse_classes.html">DIMSE classes</a></li>
<li class="toctree-l1"><a class="reference internal" href="dicomdir_classes.html">DICOMDIR classes</a></li>
<li class="toctree-l1"><a class="reference internal" href="dicom_dictionary_classes.html">DICOM dictionary</a></li>
<li class="toctree-l1"><a class="reference internal" href="definition_classes.html">Definitions</a></li>
<li class="toctree-l1"><a class="reference internal" href="exception_classes.html">Exceptions</a></li>
</ul>
<p class="caption"><span class="caption-text">Build distributions</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="build_distribution.html">Creating the source distribution from the code in the VCS</a></li>
<li class="toctree-l1"><a class="reference internal" href="build_distribution.html#versioning">Versioning</a></li>
</ul>
<p class="caption"><span class="caption-text">Requirements &amp; Risks</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="risks_requirements.html">Requirements</a></li>
<li class="toctree-l1"><a class="reference internal" href="risks_requirements.html#risks">Risks</a></li>
</ul>
<p class="caption"><span class="caption-text">Standard operating procedures</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="sop.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="sop.html#sops">SOPs</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Imebra</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>DICOM dataSet &amp; tags classes</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/dicom_data_classes.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="dicom-dataset-tags-classes">
<h1>DICOM dataSet &amp; tags classes<a class="headerlink" href="#dicom-dataset-tags-classes" title="Permalink to this headline">¶</a></h1>
<div class="section" id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>This section describes the classes and methods responsible for storing, retrieving and setting the information that composes the
DICOM structure, represented by the class <a class="reference internal" href="#dataset"><span class="std std-ref">DataSet</span></a>.</p>
<p>The following classes are described in this chapter:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 38%" />
<col style="width: 37%" />
<col style="width: 25%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>C++ class</p></th>
<th class="head"><p>Objective-C/Swift class</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference internal" href="#_CPPv4N6imebra7DataSetE" title="imebra::DataSet"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">imebra::DataSet</span></code></a></p></td>
<td><p><a class="reference internal" href="#_CPPv413ImebraDataSet" title="ImebraDataSet"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ImebraDataSet</span></code></a></p></td>
<td><p>An immutable DICOM structure</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#_CPPv4N6imebra14MutableDataSetE" title="imebra::MutableDataSet"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">imebra::MutableDataSet</span></code></a></p></td>
<td><p><a class="reference internal" href="#_CPPv420ImebraMutableDataSet" title="ImebraMutableDataSet"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ImebraMutableDataSet</span></code></a></p></td>
<td><p>Mutable DICOM structure</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#_CPPv4N6imebra3TagE" title="imebra::Tag"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">imebra::Tag</span></code></a></p></td>
<td><p><a class="reference internal" href="#_CPPv49ImebraTag" title="ImebraTag"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ImebraTag</span></code></a></p></td>
<td><p>A single immutable DICOM tag</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#_CPPv4N6imebra10MutableTagE" title="imebra::MutableTag"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">imebra::MutableTag</span></code></a></p></td>
<td><p><a class="reference internal" href="#_CPPv416ImebraMutableTag" title="ImebraMutableTag"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ImebraMutableTag</span></code></a></p></td>
<td><p>A single mutable DICOM tag</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#_CPPv4N6imebra5TagIdE" title="imebra::TagId"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">imebra::TagId</span></code></a></p></td>
<td><p><a class="reference internal" href="#_CPPv411ImebraTagId" title="ImebraTagId"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ImebraTagId</span></code></a></p></td>
<td><p>Identifies a tag</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#_CPPv4N6imebra18ReadingDataHandlerE" title="imebra::ReadingDataHandler"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">imebra::ReadingDataHandler</span></code></a></p></td>
<td><p><a class="reference internal" href="#_CPPv424ImebraReadingDataHandler" title="ImebraReadingDataHandler"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ImebraReadingDataHandler</span></code></a></p></td>
<td><p>Read data from a tag</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#_CPPv4N6imebra25ReadingDataHandlerNumericE" title="imebra::ReadingDataHandlerNumeric"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">imebra::ReadingDataHandlerNumeric</span></code></a></p></td>
<td><p><a class="reference internal" href="#_CPPv431ImebraReadingDataHandlerNumeric" title="ImebraReadingDataHandlerNumeric"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ImebraReadingDataHandlerNumeric</span></code></a></p></td>
<td><p>Read data from a numeric tag</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#_CPPv4N6imebra18WritingDataHandlerE" title="imebra::WritingDataHandler"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">imebra::WritingDataHandler</span></code></a></p></td>
<td><p><a class="reference internal" href="#_CPPv424ImebraWritingDataHandler" title="ImebraWritingDataHandler"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ImebraWritingDataHandler</span></code></a></p></td>
<td><p>Write into a tag</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#_CPPv4N6imebra25WritingDataHandlerNumericE" title="imebra::WritingDataHandlerNumeric"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">imebra::WritingDataHandlerNumeric</span></code></a></p></td>
<td><p><a class="reference internal" href="#_CPPv431ImebraWritingDataHandlerNumeric" title="ImebraWritingDataHandlerNumeric"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ImebraWritingDataHandlerNumeric</span></code></a></p></td>
<td><p>Write into a numeric tag</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#_CPPv4N6imebra4DateE" title="imebra::Date"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">imebra::Date</span></code></a></p></td>
<td><p><a class="reference internal" href="#_CPPv410ImebraDate" title="ImebraDate"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ImebraDate</span></code></a></p></td>
<td><p>Stores a DICOM date/time</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#_CPPv4N6imebra3AgeE" title="imebra::Age"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">imebra::Age</span></code></a></p></td>
<td><p><a class="reference internal" href="#_CPPv49ImebraAge" title="ImebraAge"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ImebraAge</span></code></a></p></td>
<td><p>Stores a DICOM Age</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#_CPPv4N6imebra11PatientNameE" title="imebra::PatientName"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">imebra::PatientName</span></code></a></p></td>
<td><p><a class="reference internal" href="#_CPPv417ImebraPatientName" title="ImebraPatientName"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ImebraPatientName</span></code></a></p></td>
<td><p>Stores a patient name</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#_CPPv4N6imebra18UnicodePatientNameE" title="imebra::UnicodePatientName"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">imebra::UnicodePatientName</span></code></a></p></td>
<td></td>
<td><p>Stores a patient name (unicode)</p></td>
</tr>
</tbody>
</table>
<div class="figure align-default" id="id34" style="width: 100%">
<a class="reference external image-reference" href="_images/data.jpg"><img alt="Data related classes" src="_images/data.jpg" /></a>
<p class="caption"><span class="caption-text">Class diagram of the data related classes</span><a class="headerlink" href="#id34" title="Permalink to this image">¶</a></p>
</div>
<p><a class="reference internal" href="#dataset"><span class="std std-ref">DataSet</span></a> is a collection of <a class="reference internal" href="#tag"><span class="std std-ref">Tag</span></a> objects. Each <a class="reference internal" href="#tag"><span class="std std-ref">Tag</span></a> is identified by a <a class="reference internal" href="#tagid"><span class="std std-ref">TagId</span></a>.</p>
<p><a class="reference internal" href="#dataset"><span class="std std-ref">DataSet</span></a> and <a class="reference internal" href="#mutabledataset"><span class="std std-ref">MutableDataSet</span></a> supply several functions that allow to easily read and write the value of the tags. However when advanced
functionalities are needed (e.g. when writing several items in one tag that accepts more than one value) then the classes
<a class="reference internal" href="#readingdatahandler"><span class="std std-ref">ReadingDataHandler</span></a>, <a class="reference internal" href="#readingdatahandlernumeric"><span class="std std-ref">ReadingDataHandlerNumeric</span></a>, <a class="reference internal" href="#writingdatahandler"><span class="std std-ref">WritingDataHandler</span></a> and <a class="reference internal" href="#writingdatahandlernumeric"><span class="std std-ref">WritingDataHandlerNumeric</span></a> should be used.</p>
<p>The difference between <a class="reference internal" href="#readingdatahandlernumeric"><span class="std std-ref">ReadingDataHandlerNumeric</span></a> and <a class="reference internal" href="#readingdatahandler"><span class="std std-ref">ReadingDataHandler</span></a> (and between <a class="reference internal" href="#writingdatahandlernumeric"><span class="std std-ref">WritingDataHandlerNumeric</span></a> and
<a class="reference internal" href="#writingdatahandler"><span class="std std-ref">WritingDataHandler</span></a>) is that the ‘XXXNumeric’ counterpart supplies functions to access the underlying memory buffer that stores
the data, allowing fast processing when dealing with images and large collections of data.</p>
</div>
<div class="section" id="data-storage">
<h2>Data storage<a class="headerlink" href="#data-storage" title="Permalink to this headline">¶</a></h2>
<div class="section" id="dataset">
<span id="id1"></span><h3>DataSet<a class="headerlink" href="#dataset" title="Permalink to this headline">¶</a></h3>
<div class="section" id="c">
<h4>C++<a class="headerlink" href="#c" title="Permalink to this headline">¶</a></h4>
<dl class="class">
<dt id="_CPPv4N6imebra7DataSetE">
<span id="_CPPv3N6imebra7DataSetE"></span><span id="_CPPv2N6imebra7DataSetE"></span><span id="imebra::DataSet"></span><span class="target" id="classimebra_1_1_data_set"></span><em class="property">class </em><code class="sig-name descname">DataSet</code><a class="headerlink" href="#_CPPv4N6imebra7DataSetE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This class represents a DICOM dataset. </p>
<p>The information it contains is organized into groups and each group may contain several tags.</p>
<p>You can create a <a class="reference internal" href="#classimebra_1_1_data_set"><span class="std std-ref">DataSet</span></a> from a DICOM file by using the <a class="reference internal" href="stream_classes.html#classimebra_1_1_codec_factory_1a408a8ab14e6ef691bae727b395030fde"><span class="std std-ref">CodecFactory::load()</span></a> function:</p>
<p>In C++: <div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">using</span> <span class="n">namespace</span> <span class="n">imebra</span><span class="p">;</span>
<span class="n">DataSet</span> <span class="n">dataSet</span> <span class="o">=</span> <span class="n">CodecFactory</span><span class="p">::</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;/path/to/file&quot;</span><span class="p">);</span>
</pre></div>
</div>
</p>
<p>In Java: <div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">com</span><span class="o">.</span><span class="n">imebra</span><span class="o">.</span><span class="n">DataSet</span> <span class="n">dataSet</span> <span class="o">=</span> <span class="n">com</span><span class="o">.</span><span class="n">imebra</span><span class="o">.</span><span class="n">CodecFactory</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;/path/to/file&quot;</span><span class="p">);</span>
</pre></div>
</div>
</p>
<p>To retrieve the <a class="reference internal" href="#classimebra_1_1_data_set"><span class="std std-ref">DataSet</span></a>’s content, use one of the following methods which give direct access to the tags’ values:<ul class="simple">
<li><p><a class="reference internal" href="#classimebra_1_1_data_set_1acfae6b097376164a504a028f0c514630"><span class="std std-ref">getImage()</span></a></p></li>
<li><p><a class="reference internal" href="#classimebra_1_1_data_set_1a5d6e05b1a066f2d1eb9c54fcc906acae"><span class="std std-ref">getImageApplyModalityTransform()</span></a></p></li>
<li><p><a class="reference internal" href="#classimebra_1_1_data_set_1a8c8fbd978af7875a7e225a8614776d15"><span class="std std-ref">getSequenceItem()</span></a></p></li>
<li><p><a class="reference internal" href="#classimebra_1_1_data_set_1ab706708729ab6e4609a6d704872c15d2"><span class="std std-ref">getInt32()</span></a></p></li>
<li><p><a class="reference internal" href="#classimebra_1_1_data_set_1a62d8d2514d647dee1d1bbfd5cf6fd270"><span class="std std-ref">getUint32()</span></a></p></li>
<li><p><a class="reference internal" href="#classimebra_1_1_data_set_1ac9f1b43f09d7e93dc604b71be21d74a2"><span class="std std-ref">getInt16()</span></a></p></li>
<li><p><a class="reference internal" href="#classimebra_1_1_data_set_1a456fc406a5f314d0bf82258017e41da0"><span class="std std-ref">getUint16()</span></a></p></li>
<li><p><a class="reference internal" href="#classimebra_1_1_data_set_1aa928cadad6ad8a03b603407b80728e80"><span class="std std-ref">getInt8()</span></a></p></li>
<li><p><a class="reference internal" href="#classimebra_1_1_data_set_1a21e4ca844285de75f5e6086052f417c4"><span class="std std-ref">getUint8()</span></a></p></li>
<li><p><a class="reference internal" href="#classimebra_1_1_data_set_1a41e14df6227fbb29ad71a89e76e08b21"><span class="std std-ref">getDouble()</span></a></p></li>
<li><p><a class="reference internal" href="#classimebra_1_1_data_set_1a4a8ac295aa34660e724810fb1f96f4a3"><span class="std std-ref">getFloat()</span></a></p></li>
<li><p><a class="reference internal" href="#classimebra_1_1_data_set_1a01f3d3c5e1420e9add546c93ea68c77f"><span class="std std-ref">getString()</span></a></p></li>
<li><p><a class="reference internal" href="#classimebra_1_1_data_set_1a47b0d0d7756c198da46b8de03306edcc"><span class="std std-ref">getUnicodeString()</span></a></p></li>
<li><p><a class="reference internal" href="#classimebra_1_1_data_set_1a4db801ccf4bc701ea5ae6cb06e91e41d"><span class="std std-ref">getAge()</span></a></p></li>
<li><p><a class="reference internal" href="#classimebra_1_1_data_set_1a0205e741e4210afd52bfeb83b0ff6488"><span class="std std-ref">getDate()</span></a></p></li>
</ul>
</p>
<p>In alternative, you can first retrieve a <a class="reference internal" href="#classimebra_1_1_reading_data_handler"><span class="std std-ref">ReadingDataHandler</span></a> with <a class="reference internal" href="#classimebra_1_1_data_set_1a28ac2de1400b6a8c40762a687d27292b"><span class="std std-ref">getReadingDataHandler()</span></a> and then access the tag’s content via the handler.</p>
<p>If you want to modify the dataset, use <a class="reference internal" href="#classimebra_1_1_mutable_data_set"><span class="std std-ref">MutableDataSet</span></a> instead. </p>
<p>Subclassed by <a class="reference internal" href="#classimebra_1_1_mutable_data_set"><span class="std std-ref">imebra::MutableDataSet</span></a></p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv4N6imebra7DataSet7DataSetERK7DataSet">
<span id="_CPPv3N6imebra7DataSet7DataSetERK7DataSet"></span><span id="_CPPv2N6imebra7DataSet7DataSetERK7DataSet"></span><span id="imebra::DataSet::DataSet__DataSetCR"></span><span class="target" id="classimebra_1_1_data_set_1aacf5715f4f1d488f260e064674b8979f"></span><code class="sig-name descname">DataSet</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N6imebra7DataSet7DataSetERK7DataSet" title="imebra::DataSet::DataSet">DataSet</a> &amp;<em>source</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N6imebra7DataSet7DataSetERK7DataSet" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Copy constructor. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">source</span></code>: the source data set </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N6imebra7DataSetD0Ev">
<span id="_CPPv3N6imebra7DataSetD0Ev"></span><span id="_CPPv2N6imebra7DataSetD0Ev"></span><span id="imebra::DataSet::~DataSet"></span><span class="target" id="classimebra_1_1_data_set_1af877f61f1949e7214d2c61bad9bc621b"></span><em class="property">virtual</em> <code class="sig-name descname">~DataSet</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N6imebra7DataSetD0Ev" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Destructor. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK6imebra7DataSet7getTagsEv">
<span id="_CPPv3NK6imebra7DataSet7getTagsEv"></span><span id="_CPPv2NK6imebra7DataSet7getTagsEv"></span><span id="imebra::DataSet::getTagsC"></span><span class="target" id="classimebra_1_1_data_set_1a0e7279f51275fc17bbf39fe05d399f81"></span>tagsIds_t <code class="sig-name descname">getTags</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK6imebra7DataSet7getTagsEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns a list of all the tags stored in the <a class="reference internal" href="#classimebra_1_1_data_set"><span class="std std-ref">DataSet</span></a>, ordered by group and tag ID. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>an ordered list of the stored Tags </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK6imebra7DataSet6getTagERK5TagId">
<span id="_CPPv3NK6imebra7DataSet6getTagERK5TagId"></span><span id="_CPPv2NK6imebra7DataSet6getTagERK5TagId"></span><span id="imebra::DataSet::getTag__TagIdCRC"></span><span class="target" id="classimebra_1_1_data_set_1a74de4c6e10d80043eaec0e6f5abc9cfa"></span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N6imebra3TagE" title="imebra::Tag">Tag</a> <code class="sig-name descname">getTag</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK6imebra7DataSet6getTagERK5TagId" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Retrieve the <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a> with the specified ID. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a> with the specified ID </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the ID of the tag to retrieve </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK6imebra7DataSet8getImageE6size_t">
<span id="_CPPv3NK6imebra7DataSet8getImageE6size_t"></span><span id="_CPPv2NK6imebra7DataSet8getImageE6size_t"></span><span id="imebra::DataSet::getImage__sC"></span><span class="target" id="classimebra_1_1_data_set_1acfae6b097376164a504a028f0c514630"></span><em class="property">const</em> <a class="reference internal" href="imaging_classes.html#_CPPv4N6imebra5ImageE" title="imebra::Image">Image</a> <code class="sig-name descname">getImage</code><span class="sig-paren">(</span>size_t <em>frameNumber</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK6imebra7DataSet8getImageE6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Retrieve an image from the dataset. </p>
<p>Images should be retrieved in order (first frame 0, then frame 1, then frame 2 and so on). Images can be retrieved also in random order but this introduces performance penalties.</p>
<p>Throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_data_set_image_doesnt_exist_error"><span class="std std-ref">DataSetImageDoesntExistError</span></a> if the requested frame does not exist.</p>
<p><dl class="simple">
<dt><strong>Note</strong></dt><dd><p>Images retrieved from the <a class="reference internal" href="#classimebra_1_1_data_set"><span class="std std-ref">DataSet</span></a> should be processed by the <a class="reference internal" href="transforms_classes.html#classimebra_1_1_modality_v_o_i_l_u_t"><span class="std std-ref">ModalityVOILUT</span></a> transform, which converts the modality-specific pixel values to values that the application can understand. Consider using <a class="reference internal" href="#classimebra_1_1_data_set_1a5d6e05b1a066f2d1eb9c54fcc906acae"><span class="std std-ref">getImageApplyModalityTransform()</span></a> to retrieve the image already processed by <a class="reference internal" href="transforms_classes.html#classimebra_1_1_modality_v_o_i_l_u_t"><span class="std std-ref">ModalityVOILUT</span></a>.</p>
</dd>
<dt><strong>Return</strong></dt><dd><p>an <a class="reference internal" href="imaging_classes.html#classimebra_1_1_image"><span class="std std-ref">Image</span></a> object containing the decompressed image </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">frameNumber</span></code>: the frame to retrieve (the first frame is 0) </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK6imebra7DataSet10getOverlayE6size_t">
<span id="_CPPv3NK6imebra7DataSet10getOverlayE6size_t"></span><span id="_CPPv2NK6imebra7DataSet10getOverlayE6size_t"></span><span id="imebra::DataSet::getOverlay__sC"></span><span class="target" id="classimebra_1_1_data_set_1a3e8da6cf655c67fac79892bbd8ee20bd"></span><em class="property">const</em> <a class="reference internal" href="imaging_classes.html#_CPPv4N6imebra7OverlayE" title="imebra::Overlay">Overlay</a> <code class="sig-name descname">getOverlay</code><span class="sig-paren">(</span>size_t <em>overlayNumber</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK6imebra7DataSet10getOverlayE6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Retrieve one of the DICOM overlays. </p>
<p>Throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_missing_group_error"><span class="std std-ref">MissingGroupError</span></a> if the requested overlay does not exist.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the requested overlay </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">overlayNumber</span></code>: the number of the overlay to retrieve (0…127) </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK6imebra7DataSet30getImageApplyModalityTransformE6size_t">
<span id="_CPPv3NK6imebra7DataSet30getImageApplyModalityTransformE6size_t"></span><span id="_CPPv2NK6imebra7DataSet30getImageApplyModalityTransformE6size_t"></span><span id="imebra::DataSet::getImageApplyModalityTransform__sC"></span><span class="target" id="classimebra_1_1_data_set_1a5d6e05b1a066f2d1eb9c54fcc906acae"></span><em class="property">const</em> <a class="reference internal" href="imaging_classes.html#_CPPv4N6imebra5ImageE" title="imebra::Image">Image</a> <code class="sig-name descname">getImageApplyModalityTransform</code><span class="sig-paren">(</span>size_t <em>frameNumber</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK6imebra7DataSet30getImageApplyModalityTransformE6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Retrieve an image from the dataset and if necessary process it with <a class="reference internal" href="transforms_classes.html#classimebra_1_1_modality_v_o_i_l_u_t"><span class="std std-ref">ModalityVOILUT</span></a> before returning it. </p>
<p>Images should be retrieved in order (first frame 0, then frame 1, then frame 2 and so on). Images can be retrieved also in random order but this introduces performance penalties.</p>
<p>Throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_data_set_image_doesnt_exist_error"><span class="std std-ref">DataSetImageDoesntExistError</span></a> if the requested frame does not exist.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>an image object containing the decompressed image processed with <a class="reference internal" href="transforms_classes.html#classimebra_1_1_modality_v_o_i_l_u_t"><span class="std std-ref">ModalityVOILUT</span></a> </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">frameNumber</span></code>: the frame to retrieve (the first frame is 0) </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK6imebra7DataSet7getVOIsEv">
<span id="_CPPv3NK6imebra7DataSet7getVOIsEv"></span><span id="_CPPv2NK6imebra7DataSet7getVOIsEv"></span><span id="imebra::DataSet::getVOIsC"></span><span class="target" id="classimebra_1_1_data_set_1a9eb8a51ae6798119fda308988e337b21"></span><a class="reference internal" href="definition_classes.html#_CPPv4N6imebra6vois_tE" title="imebra::vois_t">vois_t</a> <code class="sig-name descname">getVOIs</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK6imebra7DataSet7getVOIsEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return the list of VOI settings stored in the <a class="reference internal" href="#classimebra_1_1_data_set"><span class="std std-ref">DataSet</span></a>. </p>
<p>Each VOI setting includes the center &amp; width values that can be used with the <a class="reference internal" href="transforms_classes.html#classimebra_1_1_v_o_i_l_u_t"><span class="std std-ref">VOILUT</span></a> transform to highlight different parts of an <a class="reference internal" href="imaging_classes.html#classimebra_1_1_image"><span class="std std-ref">Image</span></a>.</p>
<p>If the VOI/LUT information is stored in a functional group, then first use <a class="reference internal" href="#classimebra_1_1_data_set_1a42478e54ed4bd95337e5038a94867b2e"><span class="std std-ref">getFunctionalGroupDataSet()</span></a> to retrieve the sequence item containing the VOI/LUT information, then call <a class="reference internal" href="#classimebra_1_1_data_set_1a9eb8a51ae6798119fda308988e337b21"><span class="std std-ref">getVOIs()</span></a> on the returned dataset.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>a list of <a class="reference internal" href="transforms_classes.html#classimebra_1_1_v_o_i_description"><span class="std std-ref">VOIDescription</span></a> objects defined in the <a class="reference internal" href="#classimebra_1_1_data_set"><span class="std std-ref">DataSet</span></a> </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK6imebra7DataSet25getFunctionalGroupDataSetE6size_t">
<span id="_CPPv3NK6imebra7DataSet25getFunctionalGroupDataSetE6size_t"></span><span id="_CPPv2NK6imebra7DataSet25getFunctionalGroupDataSetE6size_t"></span><span id="imebra::DataSet::getFunctionalGroupDataSet__sC"></span><span class="target" id="classimebra_1_1_data_set_1a42478e54ed4bd95337e5038a94867b2e"></span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N6imebra7DataSetE" title="imebra::DataSet">DataSet</a> <code class="sig-name descname">getFunctionalGroupDataSet</code><span class="sig-paren">(</span>size_t <em>frameNumber</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK6imebra7DataSet25getFunctionalGroupDataSetE6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>In case the dataset uses functional groups to store imaging information, then this method returns the sequence item containing imaging information for a specific frame. </p>
<p>The method looks first for a frame specific functional group sequence item, then for a common functional group sequence item if the specific one is missing.</p>
<p>Throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_missing_tag_error"><span class="std std-ref">MissingTagError</span></a> or <a class="reference internal" href="exception_classes.html#classimebra_1_1_missing_group_error"><span class="std std-ref">MissingGroupError</span></a> or <a class="reference internal" href="exception_classes.html#classimebra_1_1_missing_item_error"><span class="std std-ref">MissingItemError</span></a> if the functional group sequence item is not present.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the functional group sequence item for the requested frame. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">frameNumber</span></code>: the frame number for which the functional group sequence item is required </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK6imebra7DataSet15getStreamReaderERK5TagId6size_t">
<span id="_CPPv3NK6imebra7DataSet15getStreamReaderERK5TagId6size_t"></span><span id="_CPPv2NK6imebra7DataSet15getStreamReaderERK5TagId6size_t"></span><span id="imebra::DataSet::getStreamReader__TagIdCR.sC"></span><span class="target" id="classimebra_1_1_data_set_1aad6e50748748af4b5c681cc06d9c825a"></span><a class="reference internal" href="stream_classes.html#_CPPv4N6imebra12StreamReaderE" title="imebra::StreamReader">StreamReader</a> <code class="sig-name descname">getStreamReader</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, size_t <em>bufferId</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK6imebra7DataSet15getStreamReaderERK5TagId6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get a <a class="reference internal" href="stream_classes.html#classimebra_1_1_stream_reader"><span class="std std-ref">StreamReader</span></a> connected to a tag buffer’s data. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the <a class="reference internal" href="stream_classes.html#classimebra_1_1_stream_reader"><span class="std std-ref">StreamReader</span></a> connected to the buffer’s data. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id for which the <a class="reference internal" href="stream_classes.html#classimebra_1_1_stream_reader"><span class="std std-ref">StreamReader</span></a> is requested </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bufferId</span></code>: the id of the buffer for which the <a class="reference internal" href="stream_classes.html#classimebra_1_1_stream_reader"><span class="std std-ref">StreamReader</span></a> is required. This parameter is usually 0 </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK6imebra7DataSet15getSequenceItemERK5TagId6size_t">
<span id="_CPPv3NK6imebra7DataSet15getSequenceItemERK5TagId6size_t"></span><span id="_CPPv2NK6imebra7DataSet15getSequenceItemERK5TagId6size_t"></span><span id="imebra::DataSet::getSequenceItem__TagIdCR.sC"></span><span class="target" id="classimebra_1_1_data_set_1a8c8fbd978af7875a7e225a8614776d15"></span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N6imebra7DataSetE" title="imebra::DataSet">DataSet</a> <code class="sig-name descname">getSequenceItem</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, size_t <em>itemId</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK6imebra7DataSet15getSequenceItemERK5TagId6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Retrieve a sequence item stored in a tag. </p>
<p>If the specified <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a> does not exist then throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_missing_tag_error"><span class="std std-ref">MissingTagError</span></a> or <a class="reference internal" href="exception_classes.html#classimebra_1_1_missing_group_error"><span class="std std-ref">MissingGroupError</span></a>.</p>
<p>If the <a class="reference internal" href="#classimebra_1_1_data_set"><span class="std std-ref">DataSet</span></a> does not contain the specified sequence item then throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_missing_group_error"><span class="std std-ref">MissingGroupError</span></a>, <a class="reference internal" href="exception_classes.html#classimebra_1_1_missing_tag_error"><span class="std std-ref">MissingTagError</span></a> or <a class="reference internal" href="exception_classes.html#classimebra_1_1_missing_item_error"><span class="std std-ref">MissingItemError</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the requested sequence item </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id containing the sequence item </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">itemId</span></code>: the sequence item to retrieve. The first item has an Id = 0 </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK6imebra7DataSet6getLUTERK5TagId6size_t">
<span id="_CPPv3NK6imebra7DataSet6getLUTERK5TagId6size_t"></span><span id="_CPPv2NK6imebra7DataSet6getLUTERK5TagId6size_t"></span><span id="imebra::DataSet::getLUT__TagIdCR.sC"></span><span class="target" id="classimebra_1_1_data_set_1a9936ecedcf83789fd91592a742a173b4"></span><em class="property">const</em> <a class="reference internal" href="transforms_classes.html#_CPPv4N6imebra3LUTE" title="imebra::LUT">LUT</a> <code class="sig-name descname">getLUT</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, size_t <em>itemId</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK6imebra7DataSet6getLUTERK5TagId6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Retrieve a <a class="reference internal" href="transforms_classes.html#classimebra_1_1_l_u_t"><span class="std std-ref">LUT</span></a> stored in a sequence item. </p>
<p>If the specified <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a> does not exist then throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_missing_tag_error"><span class="std std-ref">MissingTagError</span></a> or <a class="reference internal" href="exception_classes.html#classimebra_1_1_missing_group_error"><span class="std std-ref">MissingGroupError</span></a>.</p>
<p>If the <a class="reference internal" href="#classimebra_1_1_data_set"><span class="std std-ref">DataSet</span></a> does not contain the specified sequence item then throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_missing_group_error"><span class="std std-ref">MissingGroupError</span></a>, <a class="reference internal" href="exception_classes.html#classimebra_1_1_missing_tag_error"><span class="std std-ref">MissingTagError</span></a> or <a class="reference internal" href="exception_classes.html#classimebra_1_1_missing_item_error"><span class="std std-ref">MissingItemError</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the <a class="reference internal" href="transforms_classes.html#classimebra_1_1_l_u_t"><span class="std std-ref">LUT</span></a> stored in the requested sequence item </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id containing the sequence that stores the LUTs </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">itemId</span></code>: the sequence item to retrieve. The first item has an Id = 0 </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK6imebra7DataSet21getReadingDataHandlerERK5TagId6size_t">
<span id="_CPPv3NK6imebra7DataSet21getReadingDataHandlerERK5TagId6size_t"></span><span id="_CPPv2NK6imebra7DataSet21getReadingDataHandlerERK5TagId6size_t"></span><span id="imebra::DataSet::getReadingDataHandler__TagIdCR.sC"></span><span class="target" id="classimebra_1_1_data_set_1a28ac2de1400b6a8c40762a687d27292b"></span><a class="reference internal" href="#_CPPv4N6imebra18ReadingDataHandlerE" title="imebra::ReadingDataHandler">ReadingDataHandler</a> <code class="sig-name descname">getReadingDataHandler</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, size_t <em>bufferId</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK6imebra7DataSet21getReadingDataHandlerERK5TagId6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Retrieve a <a class="reference internal" href="#classimebra_1_1_reading_data_handler"><span class="std std-ref">ReadingDataHandler</span></a> object connected to a specific tag’s buffer. </p>
<p>If the specified <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a> does not exist then throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_missing_tag_error"><span class="std std-ref">MissingTagError</span></a> or <a class="reference internal" href="exception_classes.html#classimebra_1_1_missing_group_error"><span class="std std-ref">MissingGroupError</span></a>.</p>
<p>If the specified <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a> does not contain the specified buffer item then throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_missing_buffer_error"><span class="std std-ref">MissingBufferError</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>a <a class="reference internal" href="#classimebra_1_1_reading_data_handler"><span class="std std-ref">ReadingDataHandler</span></a> object connected to the requested <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a>’s buffer </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id containing the requested buffer </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bufferId</span></code>: the buffer to connect to the <a class="reference internal" href="#classimebra_1_1_reading_data_handler"><span class="std std-ref">ReadingDataHandler</span></a> object. The first buffer has an Id = 0 </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK6imebra7DataSet28getReadingDataHandlerNumericERK5TagId6size_t">
<span id="_CPPv3NK6imebra7DataSet28getReadingDataHandlerNumericERK5TagId6size_t"></span><span id="_CPPv2NK6imebra7DataSet28getReadingDataHandlerNumericERK5TagId6size_t"></span><span id="imebra::DataSet::getReadingDataHandlerNumeric__TagIdCR.sC"></span><span class="target" id="classimebra_1_1_data_set_1a78fbf8821e910ed8b87cff36c6788d4d"></span><a class="reference internal" href="#_CPPv4N6imebra25ReadingDataHandlerNumericE" title="imebra::ReadingDataHandlerNumeric">ReadingDataHandlerNumeric</a> <code class="sig-name descname">getReadingDataHandlerNumeric</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, size_t <em>bufferId</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK6imebra7DataSet28getReadingDataHandlerNumericERK5TagId6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Retrieve a getReadingDataHandlerNumeric object connected to a specific tag’s numeric buffer. </p>
<p>If the tag’s VR is not a numeric type then throws std::bad_cast.</p>
<p>If the specified <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a> does not exist then throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_missing_tag_error"><span class="std std-ref">MissingTagError</span></a> or <a class="reference internal" href="exception_classes.html#classimebra_1_1_missing_group_error"><span class="std std-ref">MissingGroupError</span></a>.</p>
<p>If the specified <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a> does not contain the specified buffer item then throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_missing_buffer_error"><span class="std std-ref">MissingBufferError</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>a <a class="reference internal" href="#classimebra_1_1_reading_data_handler_numeric"><span class="std std-ref">ReadingDataHandlerNumeric</span></a> object connected to the requested <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a>’s buffer </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id containing the requested buffer </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bufferId</span></code>: the buffer to connect to the <a class="reference internal" href="#classimebra_1_1_reading_data_handler"><span class="std std-ref">ReadingDataHandler</span></a> object. The first buffer has an Id = 0 </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK6imebra7DataSet24getReadingDataHandlerRawERK5TagId6size_t">
<span id="_CPPv3NK6imebra7DataSet24getReadingDataHandlerRawERK5TagId6size_t"></span><span id="_CPPv2NK6imebra7DataSet24getReadingDataHandlerRawERK5TagId6size_t"></span><span id="imebra::DataSet::getReadingDataHandlerRaw__TagIdCR.sC"></span><span class="target" id="classimebra_1_1_data_set_1a0ae1d2dcbcd71bd3fedd8ab8aafbad7c"></span><a class="reference internal" href="#_CPPv4N6imebra25ReadingDataHandlerNumericE" title="imebra::ReadingDataHandlerNumeric">ReadingDataHandlerNumeric</a> <code class="sig-name descname">getReadingDataHandlerRaw</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, size_t <em>bufferId</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK6imebra7DataSet24getReadingDataHandlerRawERK5TagId6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Retrieve a getReadingDataHandlerNumeric object connected to a specific tag’s buffer, no matter what the tag’s data type. </p>
<p>If the tag’s VR is not a numeric type then throws std::bad_cast.</p>
<p>If the specified <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a> does not exist then throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_missing_tag_error"><span class="std std-ref">MissingTagError</span></a> or <a class="reference internal" href="exception_classes.html#classimebra_1_1_missing_group_error"><span class="std std-ref">MissingGroupError</span></a>.</p>
<p>If the specified <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a> does not contain the specified buffer item then throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_missing_buffer_error"><span class="std std-ref">MissingBufferError</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>a <a class="reference internal" href="#classimebra_1_1_reading_data_handler_numeric"><span class="std std-ref">ReadingDataHandlerNumeric</span></a> object connected to the requested <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a>’s buffer </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id containing the requested buffer </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bufferId</span></code>: the buffer to connect to the <a class="reference internal" href="#classimebra_1_1_reading_data_handler"><span class="std std-ref">ReadingDataHandler</span></a> object. The first buffer has an Id = 0 </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK6imebra7DataSet12bufferExistsERK5TagId6size_t">
<span id="_CPPv3NK6imebra7DataSet12bufferExistsERK5TagId6size_t"></span><span id="_CPPv2NK6imebra7DataSet12bufferExistsERK5TagId6size_t"></span><span id="imebra::DataSet::bufferExists__TagIdCR.sC"></span><span class="target" id="classimebra_1_1_data_set_1a37b0d18374b0c669c5cb1c46efd3e23f"></span>bool <code class="sig-name descname">bufferExists</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, size_t <em>bufferId</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK6imebra7DataSet12bufferExistsERK5TagId6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Check if the specified tag and tag’s buffer exist. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>true if the specified tag and tag’s buffer exist, false otherwise </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK6imebra7DataSet8getInt32ERK5TagId6size_t">
<span id="_CPPv3NK6imebra7DataSet8getInt32ERK5TagId6size_t"></span><span id="_CPPv2NK6imebra7DataSet8getInt32ERK5TagId6size_t"></span><span id="imebra::DataSet::getInt32__TagIdCR.sC"></span><span class="target" id="classimebra_1_1_data_set_1ab706708729ab6e4609a6d704872c15d2"></span>std::int32_t <code class="sig-name descname">getInt32</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, size_t <em>elementNumber</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK6imebra7DataSet8getInt32ERK5TagId6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Retrieve a tag’s value as signed integer (32 bit). </p>
<p>If the tag’s value cannot be converted to a signed integer then throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_data_handler_conversion_error"><span class="std std-ref">DataHandlerConversionError</span></a>.</p>
<p>If the value does not exist then throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_missing_tag_error"><span class="std std-ref">MissingTagError</span></a> or <a class="reference internal" href="exception_classes.html#classimebra_1_1_missing_group_error"><span class="std std-ref">MissingGroupError</span></a> or <a class="reference internal" href="exception_classes.html#classimebra_1_1_missing_buffer_error"><span class="std std-ref">MissingBufferError</span></a> or <a class="reference internal" href="exception_classes.html#classimebra_1_1_missing_item_error"><span class="std std-ref">MissingItemError</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the tag’s value as a signed 32 bit integer </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">elementNumber</span></code>: the element number within the buffer </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK6imebra7DataSet13getSignedLongERK5TagId6size_t">
<span id="_CPPv3NK6imebra7DataSet13getSignedLongERK5TagId6size_t"></span><span id="_CPPv2NK6imebra7DataSet13getSignedLongERK5TagId6size_t"></span><span id="imebra::DataSet::getSignedLong__TagIdCR.sC"></span><span class="target" id="classimebra_1_1_data_set_1a05e78490d7e4f082e077216be9edb545"></span>std::int32_t <code class="sig-name descname">getSignedLong</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, size_t <em>elementNumber</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK6imebra7DataSet13getSignedLongERK5TagId6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Deprecated. Use <a class="reference internal" href="#classimebra_1_1_data_set_1ab706708729ab6e4609a6d704872c15d2"><span class="std std-ref">getInt32()</span></a> instead. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK6imebra7DataSet8getInt32ERK5TagId6size_tNSt7int32_tE">
<span id="_CPPv3NK6imebra7DataSet8getInt32ERK5TagId6size_tNSt7int32_tE"></span><span id="_CPPv2NK6imebra7DataSet8getInt32ERK5TagId6size_tNSt7int32_tE"></span><span id="imebra::DataSet::getInt32__TagIdCR.s.std::int32_tC"></span><span class="target" id="classimebra_1_1_data_set_1a164db1ce4c2044f69ddc87c958eb73ea"></span>std::int32_t <code class="sig-name descname">getInt32</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, size_t <em>elementNumber</em>, std::int32_t <em>defaultValue</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK6imebra7DataSet8getInt32ERK5TagId6size_tNSt7int32_tE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Retrieve a tag’s value as signed integer (32 bit). </p>
<p>If the tag’s value cannot be converted to a signed integer then throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_data_handler_conversion_error"><span class="std std-ref">DataHandlerConversionError</span></a>.</p>
<p>If the specified <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a> does not exist or it does not contain the specified buffer then returns the default value specified in the parameter.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the tag’s value as a signed 32 bit integer, or defaultValue if the tag doesn’t exist </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">elementNumber</span></code>: the element number within the buffer </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">defaultValue</span></code>: the value to return if the tag doesn’t exist </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK6imebra7DataSet13getSignedLongERK5TagId6size_tNSt7int32_tE">
<span id="_CPPv3NK6imebra7DataSet13getSignedLongERK5TagId6size_tNSt7int32_tE"></span><span id="_CPPv2NK6imebra7DataSet13getSignedLongERK5TagId6size_tNSt7int32_tE"></span><span id="imebra::DataSet::getSignedLong__TagIdCR.s.std::int32_tC"></span><span class="target" id="classimebra_1_1_data_set_1af21071de3e36ab3463279917e3c7157b"></span>std::int32_t <code class="sig-name descname">getSignedLong</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, size_t <em>elementNumber</em>, std::int32_t <em>defaultValue</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK6imebra7DataSet13getSignedLongERK5TagId6size_tNSt7int32_tE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Deprecated. Use <a class="reference internal" href="#classimebra_1_1_data_set_1ab706708729ab6e4609a6d704872c15d2"><span class="std std-ref">getInt32()</span></a> instead. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK6imebra7DataSet9getUint32ERK5TagId6size_t">
<span id="_CPPv3NK6imebra7DataSet9getUint32ERK5TagId6size_t"></span><span id="_CPPv2NK6imebra7DataSet9getUint32ERK5TagId6size_t"></span><span id="imebra::DataSet::getUint32__TagIdCR.sC"></span><span class="target" id="classimebra_1_1_data_set_1a62d8d2514d647dee1d1bbfd5cf6fd270"></span>std::uint32_t <code class="sig-name descname">getUint32</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, size_t <em>elementNumber</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK6imebra7DataSet9getUint32ERK5TagId6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Retrieve a tag’s value as unsigned integer (32 bit). </p>
<p>When calling <a class="reference internal" href="#classimebra_1_1_data_set_1a62d8d2514d647dee1d1bbfd5cf6fd270"><span class="std std-ref">getUint32()</span></a> on an AT tag (Attribute <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a>) then the tag group is always in the high word of the returned value.</p>
<p>If the tag’s value cannot be converted to an unsigned integer then throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_data_handler_conversion_error"><span class="std std-ref">DataHandlerConversionError</span></a>.</p>
<p>If the value does not exist then throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_missing_tag_error"><span class="std std-ref">MissingTagError</span></a> or <a class="reference internal" href="exception_classes.html#classimebra_1_1_missing_group_error"><span class="std std-ref">MissingGroupError</span></a> or <a class="reference internal" href="exception_classes.html#classimebra_1_1_missing_buffer_error"><span class="std std-ref">MissingBufferError</span></a> or <a class="reference internal" href="exception_classes.html#classimebra_1_1_missing_item_error"><span class="std std-ref">MissingItemError</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the tag’s value as an unsigned 32 bit integer </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">elementNumber</span></code>: the element number within the buffer </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK6imebra7DataSet15getUnsignedLongERK5TagId6size_t">
<span id="_CPPv3NK6imebra7DataSet15getUnsignedLongERK5TagId6size_t"></span><span id="_CPPv2NK6imebra7DataSet15getUnsignedLongERK5TagId6size_t"></span><span id="imebra::DataSet::getUnsignedLong__TagIdCR.sC"></span><span class="target" id="classimebra_1_1_data_set_1a08327af26d511bd6361bac3fd293f4ea"></span>std::uint32_t <code class="sig-name descname">getUnsignedLong</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, size_t <em>elementNumber</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK6imebra7DataSet15getUnsignedLongERK5TagId6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Deprecated. Use <a class="reference internal" href="#classimebra_1_1_data_set_1a62d8d2514d647dee1d1bbfd5cf6fd270"><span class="std std-ref">getUint32()</span></a> instead. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK6imebra7DataSet9getUint32ERK5TagId6size_tNSt8uint32_tE">
<span id="_CPPv3NK6imebra7DataSet9getUint32ERK5TagId6size_tNSt8uint32_tE"></span><span id="_CPPv2NK6imebra7DataSet9getUint32ERK5TagId6size_tNSt8uint32_tE"></span><span id="imebra::DataSet::getUint32__TagIdCR.s.std::uint32_tC"></span><span class="target" id="classimebra_1_1_data_set_1a86cc2d8e9a231b7d898dc7b1b1d1e3b0"></span>std::uint32_t <code class="sig-name descname">getUint32</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, size_t <em>elementNumber</em>, std::uint32_t <em>defaultValue</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK6imebra7DataSet9getUint32ERK5TagId6size_tNSt8uint32_tE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Retrieve a tag’s value as unsigned integer (32 bit). </p>
<p>If the tag’s value cannot be converted to an unsigned integer then throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_data_handler_conversion_error"><span class="std std-ref">DataHandlerConversionError</span></a>.</p>
<p>If the specified <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a> does not exist then returns the default value specified in the parameter.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the tag’s value as an unsigned 32 bit integer, or defaultValue if the tag doesn’t exist </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">elementNumber</span></code>: the element number within the buffer </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">defaultValue</span></code>: the value to return if the tag doesn’t exist </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK6imebra7DataSet15getUnsignedLongERK5TagId6size_tNSt8uint32_tE">
<span id="_CPPv3NK6imebra7DataSet15getUnsignedLongERK5TagId6size_tNSt8uint32_tE"></span><span id="_CPPv2NK6imebra7DataSet15getUnsignedLongERK5TagId6size_tNSt8uint32_tE"></span><span id="imebra::DataSet::getUnsignedLong__TagIdCR.s.std::uint32_tC"></span><span class="target" id="classimebra_1_1_data_set_1a8ae06aa2b542d8b885c21bc90cdc5a82"></span>std::uint32_t <code class="sig-name descname">getUnsignedLong</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, size_t <em>elementNumber</em>, std::uint32_t <em>defaultValue</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK6imebra7DataSet15getUnsignedLongERK5TagId6size_tNSt8uint32_tE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Deprecated. Use <a class="reference internal" href="#classimebra_1_1_data_set_1a62d8d2514d647dee1d1bbfd5cf6fd270"><span class="std std-ref">getUint32()</span></a> instead. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK6imebra7DataSet8getInt16ERK5TagId6size_t">
<span id="_CPPv3NK6imebra7DataSet8getInt16ERK5TagId6size_t"></span><span id="_CPPv2NK6imebra7DataSet8getInt16ERK5TagId6size_t"></span><span id="imebra::DataSet::getInt16__TagIdCR.sC"></span><span class="target" id="classimebra_1_1_data_set_1ac9f1b43f09d7e93dc604b71be21d74a2"></span>std::int16_t <code class="sig-name descname">getInt16</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, size_t <em>elementNumber</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK6imebra7DataSet8getInt16ERK5TagId6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Retrieve a tag’s value as signed integer (16 bit). </p>
<p>If the tag’s value cannot be converted to a signed integer then throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_data_handler_conversion_error"><span class="std std-ref">DataHandlerConversionError</span></a>.</p>
<p>If the value does not exist then throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_missing_tag_error"><span class="std std-ref">MissingTagError</span></a> or <a class="reference internal" href="exception_classes.html#classimebra_1_1_missing_group_error"><span class="std std-ref">MissingGroupError</span></a> or <a class="reference internal" href="exception_classes.html#classimebra_1_1_missing_buffer_error"><span class="std std-ref">MissingBufferError</span></a> or <a class="reference internal" href="exception_classes.html#classimebra_1_1_missing_item_error"><span class="std std-ref">MissingItemError</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the tag’s value as a signed 16 bit integer </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">elementNumber</span></code>: the element number within the buffer </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK6imebra7DataSet8getInt16ERK5TagId6size_tNSt7int16_tE">
<span id="_CPPv3NK6imebra7DataSet8getInt16ERK5TagId6size_tNSt7int16_tE"></span><span id="_CPPv2NK6imebra7DataSet8getInt16ERK5TagId6size_tNSt7int16_tE"></span><span id="imebra::DataSet::getInt16__TagIdCR.s.std::int16_tC"></span><span class="target" id="classimebra_1_1_data_set_1a99d94b28921a89c4a0fe0687a39d0bfa"></span>std::int16_t <code class="sig-name descname">getInt16</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, size_t <em>elementNumber</em>, std::int16_t <em>defaultValue</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK6imebra7DataSet8getInt16ERK5TagId6size_tNSt7int16_tE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Retrieve a tag’s value as signed integer (16 bit). </p>
<p>If the tag’s value cannot be converted to a signed long integer then throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_data_handler_conversion_error"><span class="std std-ref">DataHandlerConversionError</span></a>.</p>
<p>If the specified <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a> does not exist or it does not contain the specified buffer then returns the default value specified in the parameter.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the tag’s value as a signed 16 bit integer, or defaultValue if the tag doesn’t exist </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">elementNumber</span></code>: the element number within the buffer </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">defaultValue</span></code>: the value to return if the tag doesn’t exist </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK6imebra7DataSet9getUint16ERK5TagId6size_t">
<span id="_CPPv3NK6imebra7DataSet9getUint16ERK5TagId6size_t"></span><span id="_CPPv2NK6imebra7DataSet9getUint16ERK5TagId6size_t"></span><span id="imebra::DataSet::getUint16__TagIdCR.sC"></span><span class="target" id="classimebra_1_1_data_set_1a456fc406a5f314d0bf82258017e41da0"></span>std::uint16_t <code class="sig-name descname">getUint16</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, size_t <em>elementNumber</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK6imebra7DataSet9getUint16ERK5TagId6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Retrieve a tag’s value as unsigned integer (16 bit). </p>
<p>If the tag’s value cannot be converted to an unsigned integer then throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_data_handler_conversion_error"><span class="std std-ref">DataHandlerConversionError</span></a>.</p>
<p>If the value does not exist then throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_missing_tag_error"><span class="std std-ref">MissingTagError</span></a> or <a class="reference internal" href="exception_classes.html#classimebra_1_1_missing_group_error"><span class="std std-ref">MissingGroupError</span></a> or <a class="reference internal" href="exception_classes.html#classimebra_1_1_missing_buffer_error"><span class="std std-ref">MissingBufferError</span></a> or <a class="reference internal" href="exception_classes.html#classimebra_1_1_missing_item_error"><span class="std std-ref">MissingItemError</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the tag’s value as an unsigned 16 bit integer </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">elementNumber</span></code>: the element number within the buffer </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK6imebra7DataSet9getUint16ERK5TagId6size_tNSt8uint16_tE">
<span id="_CPPv3NK6imebra7DataSet9getUint16ERK5TagId6size_tNSt8uint16_tE"></span><span id="_CPPv2NK6imebra7DataSet9getUint16ERK5TagId6size_tNSt8uint16_tE"></span><span id="imebra::DataSet::getUint16__TagIdCR.s.std::uint16_tC"></span><span class="target" id="classimebra_1_1_data_set_1a41a64f053ec06be69acaa7b4a060fde6"></span>std::uint16_t <code class="sig-name descname">getUint16</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, size_t <em>elementNumber</em>, std::uint16_t <em>defaultValue</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK6imebra7DataSet9getUint16ERK5TagId6size_tNSt8uint16_tE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Retrieve a tag’s value as unsigned integer (16 bit). </p>
<p>If the tag’s value cannot be converted to an unsigned integer then throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_data_handler_conversion_error"><span class="std std-ref">DataHandlerConversionError</span></a>.</p>
<p>If the specified <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a> does not exist then returns the default value specified in the parameter.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the tag’s value as an unsigned 16 bit integer, or defaultValue if the tag doesn’t exist </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">elementNumber</span></code>: the element number within the buffer </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">defaultValue</span></code>: the value to return if the tag doesn’t exist </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK6imebra7DataSet7getInt8ERK5TagId6size_t">
<span id="_CPPv3NK6imebra7DataSet7getInt8ERK5TagId6size_t"></span><span id="_CPPv2NK6imebra7DataSet7getInt8ERK5TagId6size_t"></span><span id="imebra::DataSet::getInt8__TagIdCR.sC"></span><span class="target" id="classimebra_1_1_data_set_1aa928cadad6ad8a03b603407b80728e80"></span>std::int8_t <code class="sig-name descname">getInt8</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, size_t <em>elementNumber</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK6imebra7DataSet7getInt8ERK5TagId6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Retrieve a tag’s value as signed integer (8 bit). </p>
<p>If the tag’s value cannot be converted to a signed integer then throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_data_handler_conversion_error"><span class="std std-ref">DataHandlerConversionError</span></a>.</p>
<p>If the value does not exist then throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_missing_tag_error"><span class="std std-ref">MissingTagError</span></a> or <a class="reference internal" href="exception_classes.html#classimebra_1_1_missing_group_error"><span class="std std-ref">MissingGroupError</span></a> or <a class="reference internal" href="exception_classes.html#classimebra_1_1_missing_buffer_error"><span class="std std-ref">MissingBufferError</span></a> or <a class="reference internal" href="exception_classes.html#classimebra_1_1_missing_item_error"><span class="std std-ref">MissingItemError</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the tag’s value as a signed 8 bit integer </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">elementNumber</span></code>: the element number within the buffer </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK6imebra7DataSet7getInt8ERK5TagId6size_tNSt6int8_tE">
<span id="_CPPv3NK6imebra7DataSet7getInt8ERK5TagId6size_tNSt6int8_tE"></span><span id="_CPPv2NK6imebra7DataSet7getInt8ERK5TagId6size_tNSt6int8_tE"></span><span id="imebra::DataSet::getInt8__TagIdCR.s.std::int8_tC"></span><span class="target" id="classimebra_1_1_data_set_1a7663f885ae5c920a2a7c33634b9025a0"></span>std::int8_t <code class="sig-name descname">getInt8</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, size_t <em>elementNumber</em>, std::int8_t <em>defaultValue</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK6imebra7DataSet7getInt8ERK5TagId6size_tNSt6int8_tE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Retrieve a tag’s value as signed integer (8 bit). </p>
<p>If the tag’s value cannot be converted to a signed long integer then throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_data_handler_conversion_error"><span class="std std-ref">DataHandlerConversionError</span></a>.</p>
<p>If the specified <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a> does not exist or it does not contain the specified buffer then returns the default value specified in the parameter.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the tag’s value as a signed 8 bit integer, or defaultValue if the tag doesn’t exist </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">elementNumber</span></code>: the element number within the buffer </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">defaultValue</span></code>: the value to return if the tag doesn’t exist </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK6imebra7DataSet8getUint8ERK5TagId6size_t">
<span id="_CPPv3NK6imebra7DataSet8getUint8ERK5TagId6size_t"></span><span id="_CPPv2NK6imebra7DataSet8getUint8ERK5TagId6size_t"></span><span id="imebra::DataSet::getUint8__TagIdCR.sC"></span><span class="target" id="classimebra_1_1_data_set_1a21e4ca844285de75f5e6086052f417c4"></span>std::uint8_t <code class="sig-name descname">getUint8</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, size_t <em>elementNumber</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK6imebra7DataSet8getUint8ERK5TagId6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Retrieve a tag’s value as unsigned integer (8 bit). </p>
<p>If the tag’s value cannot be converted to an unsigned integer then throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_data_handler_conversion_error"><span class="std std-ref">DataHandlerConversionError</span></a>.</p>
<p>If the value does not exist then throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_missing_tag_error"><span class="std std-ref">MissingTagError</span></a> or <a class="reference internal" href="exception_classes.html#classimebra_1_1_missing_group_error"><span class="std std-ref">MissingGroupError</span></a> or <a class="reference internal" href="exception_classes.html#classimebra_1_1_missing_buffer_error"><span class="std std-ref">MissingBufferError</span></a> or <a class="reference internal" href="exception_classes.html#classimebra_1_1_missing_item_error"><span class="std std-ref">MissingItemError</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the tag’s value as an unsigned 8 bit integer </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">elementNumber</span></code>: the element number within the buffer </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK6imebra7DataSet8getUint8ERK5TagId6size_tNSt7uint8_tE">
<span id="_CPPv3NK6imebra7DataSet8getUint8ERK5TagId6size_tNSt7uint8_tE"></span><span id="_CPPv2NK6imebra7DataSet8getUint8ERK5TagId6size_tNSt7uint8_tE"></span><span id="imebra::DataSet::getUint8__TagIdCR.s.std::uint8_tC"></span><span class="target" id="classimebra_1_1_data_set_1a4b0f04ae3a362436b02438adf262328d"></span>std::uint8_t <code class="sig-name descname">getUint8</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, size_t <em>elementNumber</em>, std::uint8_t <em>defaultValue</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK6imebra7DataSet8getUint8ERK5TagId6size_tNSt7uint8_tE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Retrieve a tag’s value as unsigned integer (8 bit). </p>
<p>If the tag’s value cannot be converted to an unsigned integer then throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_data_handler_conversion_error"><span class="std std-ref">DataHandlerConversionError</span></a>.</p>
<p>If the specified <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a> does not exist then returns the default value specified in the parameter.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the tag’s value as an unsigned 8 bit integer, or defaultValue if the tag doesn’t exist </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">elementNumber</span></code>: the element number within the buffer </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">defaultValue</span></code>: the value to return if the tag doesn’t exist </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK6imebra7DataSet9getDoubleERK5TagId6size_t">
<span id="_CPPv3NK6imebra7DataSet9getDoubleERK5TagId6size_t"></span><span id="_CPPv2NK6imebra7DataSet9getDoubleERK5TagId6size_t"></span><span id="imebra::DataSet::getDouble__TagIdCR.sC"></span><span class="target" id="classimebra_1_1_data_set_1a41e14df6227fbb29ad71a89e76e08b21"></span>double <code class="sig-name descname">getDouble</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, size_t <em>elementNumber</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK6imebra7DataSet9getDoubleERK5TagId6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Retrieve a tag’s value as a 64 bit floating point. </p>
<p>If the tag’s value cannot be converted to a floating point value then throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_data_handler_conversion_error"><span class="std std-ref">DataHandlerConversionError</span></a>.</p>
<p>If the value does not exist then throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_missing_tag_error"><span class="std std-ref">MissingTagError</span></a> or <a class="reference internal" href="exception_classes.html#classimebra_1_1_missing_group_error"><span class="std std-ref">MissingGroupError</span></a> or <a class="reference internal" href="exception_classes.html#classimebra_1_1_missing_buffer_error"><span class="std std-ref">MissingBufferError</span></a> or <a class="reference internal" href="exception_classes.html#classimebra_1_1_missing_item_error"><span class="std std-ref">MissingItemError</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the tag’s value as a 64 bit floating point </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">elementNumber</span></code>: the element number within the buffer </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK6imebra7DataSet8getFloatERK5TagId6size_t">
<span id="_CPPv3NK6imebra7DataSet8getFloatERK5TagId6size_t"></span><span id="_CPPv2NK6imebra7DataSet8getFloatERK5TagId6size_t"></span><span id="imebra::DataSet::getFloat__TagIdCR.sC"></span><span class="target" id="classimebra_1_1_data_set_1a4a8ac295aa34660e724810fb1f96f4a3"></span>float <code class="sig-name descname">getFloat</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, size_t <em>elementNumber</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK6imebra7DataSet8getFloatERK5TagId6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Retrieve a tag’s value as a 32 bit floating point. </p>
<p>If the tag’s value cannot be converted to a floating point value then throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_data_handler_conversion_error"><span class="std std-ref">DataHandlerConversionError</span></a>.</p>
<p>If the value does not exist then throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_missing_tag_error"><span class="std std-ref">MissingTagError</span></a> or <a class="reference internal" href="exception_classes.html#classimebra_1_1_missing_group_error"><span class="std std-ref">MissingGroupError</span></a> or <a class="reference internal" href="exception_classes.html#classimebra_1_1_missing_buffer_error"><span class="std std-ref">MissingBufferError</span></a> or <a class="reference internal" href="exception_classes.html#classimebra_1_1_missing_item_error"><span class="std std-ref">MissingItemError</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the tag’s value as a 32 bit floating point </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">elementNumber</span></code>: the element number within the buffer </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK6imebra7DataSet9getDoubleERK5TagId6size_td">
<span id="_CPPv3NK6imebra7DataSet9getDoubleERK5TagId6size_td"></span><span id="_CPPv2NK6imebra7DataSet9getDoubleERK5TagId6size_td"></span><span id="imebra::DataSet::getDouble__TagIdCR.s.doubleC"></span><span class="target" id="classimebra_1_1_data_set_1abf00b0bd859d15e027a80ebaba08528f"></span>double <code class="sig-name descname">getDouble</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, size_t <em>elementNumber</em>, double <em>defaultValue</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK6imebra7DataSet9getDoubleERK5TagId6size_td" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Retrieve a tag’s value as a 64 bit floating point. </p>
<p>If the tag’s value cannot be converted to a floating point value then throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_data_handler_conversion_error"><span class="std std-ref">DataHandlerConversionError</span></a>.</p>
<p>If the specified <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a> does not exist then returns the default value specified in the parameter.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the tag’s value as a 64 bit floating point, or defaultValue if the tag doesn’t exist </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">elementNumber</span></code>: the element number within the buffer </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">defaultValue</span></code>: the value to return if the tag doesn’t exist </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK6imebra7DataSet8getFloatERK5TagId6size_tf">
<span id="_CPPv3NK6imebra7DataSet8getFloatERK5TagId6size_tf"></span><span id="_CPPv2NK6imebra7DataSet8getFloatERK5TagId6size_tf"></span><span id="imebra::DataSet::getFloat__TagIdCR.s.floatC"></span><span class="target" id="classimebra_1_1_data_set_1a39aef4c69c783aad0cb73262c22fc815"></span>float <code class="sig-name descname">getFloat</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, size_t <em>elementNumber</em>, float <em>defaultValue</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK6imebra7DataSet8getFloatERK5TagId6size_tf" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Retrieve a tag’s value as a 32 bit floating point. </p>
<p>If the tag’s value cannot be converted to a floating point value then throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_data_handler_conversion_error"><span class="std std-ref">DataHandlerConversionError</span></a>.</p>
<p>If the specified <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a> does not exist then returns the default value specified in the parameter.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the tag’s value as a 32 bit floating point, or defaultValue if the tag doesn’t exist </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">elementNumber</span></code>: the element number within the buffer </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">defaultValue</span></code>: the value to return if the tag doesn’t exist </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK6imebra7DataSet9getStringERK5TagId6size_t">
<span id="_CPPv3NK6imebra7DataSet9getStringERK5TagId6size_t"></span><span id="_CPPv2NK6imebra7DataSet9getStringERK5TagId6size_t"></span><span id="imebra::DataSet::getString__TagIdCR.sC"></span><span class="target" id="classimebra_1_1_data_set_1a01f3d3c5e1420e9add546c93ea68c77f"></span>std::string <code class="sig-name descname">getString</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, size_t <em>elementNumber</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK6imebra7DataSet9getStringERK5TagId6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Retrieve a tag’s value as a UTF8 string. </p>
<p>If the tag’s value cannot be converted to a string then throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_data_handler_conversion_error"><span class="std std-ref">DataHandlerConversionError</span></a>.</p>
<p>If the value does not exist then throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_missing_tag_error"><span class="std std-ref">MissingTagError</span></a> or <a class="reference internal" href="exception_classes.html#classimebra_1_1_missing_group_error"><span class="std std-ref">MissingGroupError</span></a> or <a class="reference internal" href="exception_classes.html#classimebra_1_1_missing_buffer_error"><span class="std std-ref">MissingBufferError</span></a> or <a class="reference internal" href="exception_classes.html#classimebra_1_1_missing_item_error"><span class="std std-ref">MissingItemError</span></a>.</p>
<p>If the conversion to UTF8 fails then throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_charset_conversion_cannot_convert"><span class="std std-ref">CharsetConversionCannotConvert</span></a>, <a class="reference internal" href="exception_classes.html#classimebra_1_1_charset_conversion_no_supported_table_error"><span class="std std-ref">CharsetConversionNoSupportedTableError</span></a>, <a class="reference internal" href="exception_classes.html#classimebra_1_1_charset_conversion_no_table_error"><span class="std std-ref">CharsetConversionNoTableError</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the tag’s value as a string </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">elementNumber</span></code>: the element number within the buffer </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK6imebra7DataSet9getStringERK5TagId6size_tRKNSt6stringE">
<span id="_CPPv3NK6imebra7DataSet9getStringERK5TagId6size_tRKNSt6stringE"></span><span id="_CPPv2NK6imebra7DataSet9getStringERK5TagId6size_tRKNSt6stringE"></span><span id="imebra::DataSet::getString__TagIdCR.s.ssCRC"></span><span class="target" id="classimebra_1_1_data_set_1ae57b791ceb14768b55b89c46fddb61f8"></span>std::string <code class="sig-name descname">getString</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, size_t <em>elementNumber</em>, <em class="property">const</em> std::string &amp;<em>defaultValue</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK6imebra7DataSet9getStringERK5TagId6size_tRKNSt6stringE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Retrieve a tag’s value as a UTF8 string. </p>
<p>If the tag’s value cannot be converted to a string then throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_data_handler_conversion_error"><span class="std std-ref">DataHandlerConversionError</span></a>.</p>
<p>If the specified <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a> does not exist then returns the default value specified in the parameter.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the tag’s value as a string, or defaultValue if the tag doesn’t exist </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">elementNumber</span></code>: the element number within the buffer </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">defaultValue</span></code>: the value to return if the tag doesn’t exist </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK6imebra7DataSet16getUnicodeStringERK5TagId6size_t">
<span id="_CPPv3NK6imebra7DataSet16getUnicodeStringERK5TagId6size_t"></span><span id="_CPPv2NK6imebra7DataSet16getUnicodeStringERK5TagId6size_t"></span><span id="imebra::DataSet::getUnicodeString__TagIdCR.sC"></span><span class="target" id="classimebra_1_1_data_set_1a47b0d0d7756c198da46b8de03306edcc"></span>std::wstring <code class="sig-name descname">getUnicodeString</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, size_t <em>elementNumber</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK6imebra7DataSet16getUnicodeStringERK5TagId6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Retrieve a tag’s value as an Unicode string. </p>
<p>If the tag’s value cannot be converted to a Unicode string then throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_data_handler_conversion_error"><span class="std std-ref">DataHandlerConversionError</span></a>.</p>
<p>If the value does not exist then throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_missing_tag_error"><span class="std std-ref">MissingTagError</span></a> or <a class="reference internal" href="exception_classes.html#classimebra_1_1_missing_group_error"><span class="std std-ref">MissingGroupError</span></a> or <a class="reference internal" href="exception_classes.html#classimebra_1_1_missing_buffer_error"><span class="std std-ref">MissingBufferError</span></a> or <a class="reference internal" href="exception_classes.html#classimebra_1_1_missing_item_error"><span class="std std-ref">MissingItemError</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the tag’s value as an unicode string </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">elementNumber</span></code>: the element number within the buffer </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK6imebra7DataSet16getUnicodeStringERK5TagId6size_tRKNSt7wstringE">
<span id="_CPPv3NK6imebra7DataSet16getUnicodeStringERK5TagId6size_tRKNSt7wstringE"></span><span id="_CPPv2NK6imebra7DataSet16getUnicodeStringERK5TagId6size_tRKNSt7wstringE"></span><span id="imebra::DataSet::getUnicodeString__TagIdCR.s.std::wstringCRC"></span><span class="target" id="classimebra_1_1_data_set_1af0c66d58feb51310a13fafb5476fb5e5"></span>std::wstring <code class="sig-name descname">getUnicodeString</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, size_t <em>elementNumber</em>, <em class="property">const</em> std::wstring &amp;<em>defaultValue</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK6imebra7DataSet16getUnicodeStringERK5TagId6size_tRKNSt7wstringE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Retrieve a tag’s value as an unicode string. </p>
<p>If the tag’s value cannot be converted to a Unicode string then throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_data_handler_conversion_error"><span class="std std-ref">DataHandlerConversionError</span></a>.</p>
<p>If the specified <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a> does not exist then returns the default value specified in the parameter.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the tag’s value as an unicode string, or defaultValue if the tag doesn’t exist </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">elementNumber</span></code>: the element number within the buffer </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">defaultValue</span></code>: the value to return if the tag doesn’t exist </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK6imebra7DataSet6getAgeERK5TagId6size_t">
<span id="_CPPv3NK6imebra7DataSet6getAgeERK5TagId6size_t"></span><span id="_CPPv2NK6imebra7DataSet6getAgeERK5TagId6size_t"></span><span id="imebra::DataSet::getAge__TagIdCR.sC"></span><span class="target" id="classimebra_1_1_data_set_1a4db801ccf4bc701ea5ae6cb06e91e41d"></span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N6imebra3AgeE" title="imebra::Age">Age</a> <code class="sig-name descname">getAge</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, size_t <em>elementNumber</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK6imebra7DataSet6getAgeERK5TagId6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Retrieve a tag’s value as <a class="reference internal" href="#classimebra_1_1_age"><span class="std std-ref">Age</span></a>. </p>
<p>If the tag’s value cannot be converted to <a class="reference internal" href="#classimebra_1_1_age"><span class="std std-ref">Age</span></a> then throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_data_handler_conversion_error"><span class="std std-ref">DataHandlerConversionError</span></a>.</p>
<p>If the value does not exist then throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_missing_tag_error"><span class="std std-ref">MissingTagError</span></a> or <a class="reference internal" href="exception_classes.html#classimebra_1_1_missing_group_error"><span class="std std-ref">MissingGroupError</span></a> or <a class="reference internal" href="exception_classes.html#classimebra_1_1_missing_buffer_error"><span class="std std-ref">MissingBufferError</span></a> or <a class="reference internal" href="exception_classes.html#classimebra_1_1_missing_item_error"><span class="std std-ref">MissingItemError</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the tag’s value as <a class="reference internal" href="#classimebra_1_1_age"><span class="std std-ref">Age</span></a> </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">elementNumber</span></code>: the element number within the buffer </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK6imebra7DataSet6getAgeERK5TagId6size_tRK3Age">
<span id="_CPPv3NK6imebra7DataSet6getAgeERK5TagId6size_tRK3Age"></span><span id="_CPPv2NK6imebra7DataSet6getAgeERK5TagId6size_tRK3Age"></span><span id="imebra::DataSet::getAge__TagIdCR.s.AgeCRC"></span><span class="target" id="classimebra_1_1_data_set_1ab87c375ca052fb21eb832534b741e4ee"></span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N6imebra3AgeE" title="imebra::Age">Age</a> <code class="sig-name descname">getAge</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, size_t <em>elementNumber</em>, <em class="property">const</em> <a class="reference internal" href="#_CPPv4N6imebra3AgeE" title="imebra::Age">Age</a> &amp;<em>defaultValue</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK6imebra7DataSet6getAgeERK5TagId6size_tRK3Age" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Retrieve a tag’s value as <a class="reference internal" href="#classimebra_1_1_age"><span class="std std-ref">Age</span></a>. </p>
<p>If the tag’s value cannot be converted to <a class="reference internal" href="#classimebra_1_1_age"><span class="std std-ref">Age</span></a> then throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_data_handler_conversion_error"><span class="std std-ref">DataHandlerConversionError</span></a>.</p>
<p>If the specified <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a> does not exist then returns the default value specified in the parameter.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the tag’s value as <a class="reference internal" href="#classimebra_1_1_age"><span class="std std-ref">Age</span></a>, or defaultValue if the tag doesn’t exist </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">elementNumber</span></code>: the element number within the buffer 0 </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">defaultValue</span></code>: the value to return if the tag doesn’t exist </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK6imebra7DataSet7getDateERK5TagId6size_t">
<span id="_CPPv3NK6imebra7DataSet7getDateERK5TagId6size_t"></span><span id="_CPPv2NK6imebra7DataSet7getDateERK5TagId6size_t"></span><span id="imebra::DataSet::getDate__TagIdCR.sC"></span><span class="target" id="classimebra_1_1_data_set_1a0205e741e4210afd52bfeb83b0ff6488"></span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N6imebra4DateE" title="imebra::Date">Date</a> <code class="sig-name descname">getDate</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, size_t <em>elementNumber</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK6imebra7DataSet7getDateERK5TagId6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Retrieve a tag’s value as a <a class="reference internal" href="#classimebra_1_1_date"><span class="std std-ref">Date</span></a>. </p>
<p>If the tag’s value cannot be converted to a <a class="reference internal" href="#classimebra_1_1_date"><span class="std std-ref">Date</span></a> then throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_data_handler_conversion_error"><span class="std std-ref">DataHandlerConversionError</span></a>.</p>
<p>If the value does not exist then throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_missing_tag_error"><span class="std std-ref">MissingTagError</span></a> or <a class="reference internal" href="exception_classes.html#classimebra_1_1_missing_group_error"><span class="std std-ref">MissingGroupError</span></a> or <a class="reference internal" href="exception_classes.html#classimebra_1_1_missing_buffer_error"><span class="std std-ref">MissingBufferError</span></a> or <a class="reference internal" href="exception_classes.html#classimebra_1_1_missing_item_error"><span class="std std-ref">MissingItemError</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the tag’s value as a <a class="reference internal" href="#classimebra_1_1_date"><span class="std std-ref">Date</span></a> </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">elementNumber</span></code>: the element number within the buffer 0 </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK6imebra7DataSet7getDateERK5TagId6size_tRK4Date">
<span id="_CPPv3NK6imebra7DataSet7getDateERK5TagId6size_tRK4Date"></span><span id="_CPPv2NK6imebra7DataSet7getDateERK5TagId6size_tRK4Date"></span><span id="imebra::DataSet::getDate__TagIdCR.s.DateCRC"></span><span class="target" id="classimebra_1_1_data_set_1af27a36f25f55c2796ada1dc261fcae47"></span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N6imebra4DateE" title="imebra::Date">Date</a> <code class="sig-name descname">getDate</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, size_t <em>elementNumber</em>, <em class="property">const</em> <a class="reference internal" href="#_CPPv4N6imebra4DateE" title="imebra::Date">Date</a> &amp;<em>defaultValue</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK6imebra7DataSet7getDateERK5TagId6size_tRK4Date" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Retrieve a tag’s value as a <a class="reference internal" href="#classimebra_1_1_date"><span class="std std-ref">Date</span></a>. </p>
<p>If the tag’s value cannot be converted to a date then throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_data_handler_conversion_error"><span class="std std-ref">DataHandlerConversionError</span></a>.</p>
<p>If the specified <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a> does not exist then returns the default value specified in the parameter.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the tag’s value as a <a class="reference internal" href="#classimebra_1_1_date"><span class="std std-ref">Date</span></a>, or defaultValue if the tag doesn’t exist </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">elementNumber</span></code>: the element number within the buffer </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">defaultValue</span></code>: the value to return if the tag doesn’t exist </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK6imebra7DataSet14getPatientNameERK5TagId6size_t">
<span id="_CPPv3NK6imebra7DataSet14getPatientNameERK5TagId6size_t"></span><span id="_CPPv2NK6imebra7DataSet14getPatientNameERK5TagId6size_t"></span><span id="imebra::DataSet::getPatientName__TagIdCR.sC"></span><span class="target" id="classimebra_1_1_data_set_1aae10c63f2401511886fa076c6949ad4a"></span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N6imebra11PatientNameE" title="imebra::PatientName">PatientName</a> <code class="sig-name descname">getPatientName</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, size_t <em>elementNumber</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK6imebra7DataSet14getPatientNameERK5TagId6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Retrieve a tag’s value as a Patient Name. </p>
<p>If the value does not exist then throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_missing_tag_error"><span class="std std-ref">MissingTagError</span></a> or <a class="reference internal" href="exception_classes.html#classimebra_1_1_missing_group_error"><span class="std std-ref">MissingGroupError</span></a> or <a class="reference internal" href="exception_classes.html#classimebra_1_1_missing_buffer_error"><span class="std std-ref">MissingBufferError</span></a> or <a class="reference internal" href="exception_classes.html#classimebra_1_1_missing_item_error"><span class="std std-ref">MissingItemError</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the tag’s value as a Patient Name </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">elementNumber</span></code>: the element number within the buffer </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">defaultValue</span></code>: the value to return if the tag doesn’t exist </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK6imebra7DataSet14getPatientNameERK5TagId6size_tRK11PatientName">
<span id="_CPPv3NK6imebra7DataSet14getPatientNameERK5TagId6size_tRK11PatientName"></span><span id="_CPPv2NK6imebra7DataSet14getPatientNameERK5TagId6size_tRK11PatientName"></span><span id="imebra::DataSet::getPatientName__TagIdCR.s.PatientNameCRC"></span><span class="target" id="classimebra_1_1_data_set_1af4d5fa6428a8a9e6297835c1d8176896"></span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N6imebra11PatientNameE" title="imebra::PatientName">PatientName</a> <code class="sig-name descname">getPatientName</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, size_t <em>elementNumber</em>, <em class="property">const</em> <a class="reference internal" href="#_CPPv4N6imebra11PatientNameE" title="imebra::PatientName">PatientName</a> &amp;<em>defaultValue</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK6imebra7DataSet14getPatientNameERK5TagId6size_tRK11PatientName" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Retrieve a tag’s value as a Patient Name. </p>
<p>If the tag’s value cannot be converted to a patient name then throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_data_handler_conversion_error"><span class="std std-ref">DataHandlerConversionError</span></a>.</p>
<p>If the specified <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a> does not exist then returns the default value specified in the parameter.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the tag’s value as a Patient Name, or defaultValue if the tag doesn’t exist </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">elementNumber</span></code>: the element number within the buffer </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">defaultValue</span></code>: the value to return if the tag doesn’t exist </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK6imebra7DataSet21getUnicodePatientNameERK5TagId6size_t">
<span id="_CPPv3NK6imebra7DataSet21getUnicodePatientNameERK5TagId6size_t"></span><span id="_CPPv2NK6imebra7DataSet21getUnicodePatientNameERK5TagId6size_t"></span><span id="imebra::DataSet::getUnicodePatientName__TagIdCR.sC"></span><span class="target" id="classimebra_1_1_data_set_1af0809efa8f34db47601f4b756f9befe1"></span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N6imebra18UnicodePatientNameE" title="imebra::UnicodePatientName">UnicodePatientName</a> <code class="sig-name descname">getUnicodePatientName</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, size_t <em>elementNumber</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK6imebra7DataSet21getUnicodePatientNameERK5TagId6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Retrieve a tag’s value as a Unicode Patient Name. </p>
<p>If the tag’s value cannot be converted to a patient name then throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_data_handler_conversion_error"><span class="std std-ref">DataHandlerConversionError</span></a>.</p>
<p>If the value does not exist then throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_missing_tag_error"><span class="std std-ref">MissingTagError</span></a> or <a class="reference internal" href="exception_classes.html#classimebra_1_1_missing_group_error"><span class="std std-ref">MissingGroupError</span></a> or <a class="reference internal" href="exception_classes.html#classimebra_1_1_missing_buffer_error"><span class="std std-ref">MissingBufferError</span></a> or <a class="reference internal" href="exception_classes.html#classimebra_1_1_missing_item_error"><span class="std std-ref">MissingItemError</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the tag’s value as a Unicode Patient Name </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">elementNumber</span></code>: the element number within the buffer </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">defaultValue</span></code>: the value to return if the tag doesn’t exist </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK6imebra7DataSet21getUnicodePatientNameERK5TagId6size_tRK18UnicodePatientName">
<span id="_CPPv3NK6imebra7DataSet21getUnicodePatientNameERK5TagId6size_tRK18UnicodePatientName"></span><span id="_CPPv2NK6imebra7DataSet21getUnicodePatientNameERK5TagId6size_tRK18UnicodePatientName"></span><span id="imebra::DataSet::getUnicodePatientName__TagIdCR.s.UnicodePatientNameCRC"></span><span class="target" id="classimebra_1_1_data_set_1a4c4f079e16522425409d883556ffb624"></span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N6imebra18UnicodePatientNameE" title="imebra::UnicodePatientName">UnicodePatientName</a> <code class="sig-name descname">getUnicodePatientName</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, size_t <em>elementNumber</em>, <em class="property">const</em> <a class="reference internal" href="#_CPPv4N6imebra18UnicodePatientNameE" title="imebra::UnicodePatientName">UnicodePatientName</a> &amp;<em>defaultValue</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK6imebra7DataSet21getUnicodePatientNameERK5TagId6size_tRK18UnicodePatientName" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Retrieve a tag’s value as a Unicode Patient Name. </p>
<p>If the tag’s value cannot be converted to a patient name then throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_data_handler_conversion_error"><span class="std std-ref">DataHandlerConversionError</span></a>.</p>
<p>If the specified <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a> does not exist then returns the default value specified in the parameter.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the tag’s value as a Unicode Patient Name, or defaultValue if the tag doesn’t exist </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">elementNumber</span></code>: the element number within the buffer </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">defaultValue</span></code>: the value to return if the tag doesn’t exist </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK6imebra7DataSet11getDataTypeERK5TagId">
<span id="_CPPv3NK6imebra7DataSet11getDataTypeERK5TagId"></span><span id="_CPPv2NK6imebra7DataSet11getDataTypeERK5TagId"></span><span id="imebra::DataSet::getDataType__TagIdCRC"></span><span class="target" id="classimebra_1_1_data_set_1a02fd5b27065d9ae242ac6da50b4d5913"></span><a class="reference internal" href="definition_classes.html#_CPPv4N6imebra7tagVR_tE" title="imebra::tagVR_t">tagVR_t</a> <code class="sig-name descname">getDataType</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK6imebra7DataSet11getDataTypeERK5TagId" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return the 2 chars data type (VR) of the specified tag. </p>
<p>If the tag not exist then throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_missing_tag_error"><span class="std std-ref">MissingTagError</span></a> or <a class="reference internal" href="exception_classes.html#classimebra_1_1_missing_group_error"><span class="std std-ref">MissingGroupError</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the tag’s data type (VR) </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the id of the tag </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</div>
<div class="section" id="objective-c-swift">
<h4>Objective-C/Swift<a class="headerlink" href="#objective-c-swift" title="Permalink to this headline">¶</a></h4>
<dl class="class">
<dt id="_CPPv413ImebraDataSet">
<span id="_CPPv313ImebraDataSet"></span><span id="_CPPv213ImebraDataSet"></span><span id="ImebraDataSet"></span><span class="target" id="interface_imebra_data_set"></span><em class="property">class </em><code class="sig-name descname">ImebraDataSet</code> : <em class="property">public</em> NSObject<a class="headerlink" href="#_CPPv413ImebraDataSet" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This class represents an immutable DICOM dataset. </p>
<p>The information it contains is organized into groups and each group may contain several tags.</p>
<p>You can create a <a class="reference internal" href="#interface_imebra_data_set"><span class="std std-ref">ImebraDataSet</span></a> from a DICOM file by using the ImebraCodecFactory::load() function:</p>
<p><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">NSError</span><span class="o">*</span> <span class="n">error</span> <span class="o">=</span> <span class="n">nil</span><span class="p">;</span>
<span class="n">ImebraDataSet</span><span class="o">*</span> <span class="n">pDataSet</span> <span class="o">=</span> <span class="p">[</span><span class="n">ImebraCodecFactory</span> <span class="n">load</span><span class="p">:</span><span class="o">@</span><span class="s2">&quot;dicomFile.dcm&quot;</span> <span class="n">error</span><span class="p">:</span><span class="o">&amp;</span><span class="n">error</span><span class="p">];</span>
</pre></div>
</div>
</p>
<p>To retrieve the DataSet’s content, use one of the following methods which give direct access to the tags’ values:<ul class="simple">
<li><p>getImage()</p></li>
<li><p>getImageApplyModalityTransform()</p></li>
<li><p>getSequenceItem()</p></li>
<li><p>getInt32()</p></li>
<li><p>getInt16()</p></li>
<li><p>getInt8()</p></li>
<li><p>getUint32()</p></li>
<li><p>getUint16()</p></li>
<li><p>getUint8()</p></li>
<li><p>getDouble()</p></li>
<li><p>getFloat()</p></li>
<li><p>getString()</p></li>
<li><p>getUnicodeString()</p></li>
<li><p>getAge()</p></li>
<li><p>getDate()</p></li>
<li><p>getPatient()</p></li>
</ul>
</p>
<p>In alternative, you can first retrieve a <a class="reference internal" href="#interface_imebra_reading_data_handler"><span class="std std-ref">ImebraReadingDataHandler</span></a> with getReadingDataHandler() and then access the tag’s content via the handler. </p>
<p>Subclassed by <a class="reference internal" href="#interface_imebra_mutable_data_set"><span class="std std-ref">ImebraMutableDataSet</span></a></p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv4N13ImebraDataSet7getTagsEv">
<span id="_CPPv3N13ImebraDataSet7getTagsEv"></span><span id="_CPPv2N13ImebraDataSet7getTagsEv"></span><span id="ImebraDataSet::getTags"></span><span class="target" id="interface_imebra_data_set_1a9a3a21702b61bae5306c6d3abf95b589"></span>NSArray *<code class="sig-name descname">getTags</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N13ImebraDataSet7getTagsEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns a list of all the tags stored in the DataSet, ordered by group and tag ID. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>an NSArray containing an ordered list of <a class="reference internal" href="#interface_imebra_tag_id"><span class="std std-ref">ImebraTagId</span></a> objects </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_data_set_1a16f5da5d77919be76aa4e1c7525785ae"></span><code class="sig-name descname">ImebraTag* ImebraDataSet::getTag:error:(ImebraTagId  * tagId, NSError ** pError)</code></dt>
<dd><p>Retrieve the Tag with the specified ID. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the Tag with the specified ID </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the ID of the tag to retrieve </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pError</span></code>: set if an error occurs </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_data_set_1a654c7008d0044408556af9c6858067ad"></span><code class="sig-name descname">ImebraImage* ImebraDataSet::getImage:error:(unsigned int frameNumber, NSError ** pError)</code></dt>
<dd><p>Retrieve an image from the dataset. </p>
<p>Images should be retrieved in order (first frame 0, then frame 1, then frame 2 and so on). Images can be retrieved also in random order but this introduces performance penalties.</p>
<p>Set pError and returns nil if the requested image does not exist.</p>
<p><dl class="simple">
<dt><strong>Note</strong></dt><dd><p>Images retrieved from the <a class="reference internal" href="#interface_imebra_data_set"><span class="std std-ref">ImebraDataSet</span></a> should be processed by the <a class="reference internal" href="transforms_classes.html#interface_imebra_modality_v_o_i_l_u_t"><span class="std std-ref">ImebraModalityVOILUT</span></a> transform, which converts the modality-specific pixel values to values that the application can understand. Consider using getImageApplyModalityTransform() to retrieve the image already processed by <a class="reference internal" href="transforms_classes.html#interface_imebra_modality_v_o_i_l_u_t"><span class="std std-ref">ImebraModalityVOILUT</span></a>.</p>
</dd>
<dt><strong>Return</strong></dt><dd><p>an <a class="reference internal" href="imaging_classes.html#interface_imebra_image"><span class="std std-ref">ImebraImage</span></a> object containing the decompressed image </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">frameNumber</span></code>: the frame to retrieve (the first frame is 0) </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pError</span></code>: a pointer to a NSError pointer which is set when an error occurs </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_data_set_1a27b9139717929fe09157f61093236a75"></span><code class="sig-name descname">ImebraOverlay* ImebraDataSet::getOverlay:error:(unsigned int overlayNumber, NSError ** pError)</code></dt>
<dd><p>Retrieve one of the DICOM overlays. </p>
<p>Set pError to ImebraMissingGroupError if the requested overlay does not exist.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the requested overlay </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">overlayNumber</span></code>: the number of the overlay to retrieve (0…127) </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_data_set_1adf97a82136ed04c62592e21a270fc6ba"></span><code class="sig-name descname">ImebraImage* ImebraDataSet::getImageApplyModalityTransform:error:(unsigned int frameNumber, NSError ** pError)</code></dt>
<dd><p>Retrieve an image from the dataset and if necessary process it with <a class="reference internal" href="transforms_classes.html#interface_imebra_modality_v_o_i_l_u_t"><span class="std std-ref">ImebraModalityVOILUT</span></a> before returning it. </p>
<p>Images should be retrieved in order (first frame 0, then frame 1, then frame 2 and so on). Images can be retrieved also in random order but this introduces performance penalties.</p>
<p>Set pError and returns nil if the requested image does not exist.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>an <a class="reference internal" href="imaging_classes.html#interface_imebra_image"><span class="std std-ref">ImebraImage</span></a> object containing the decompressed image processed by <a class="reference internal" href="transforms_classes.html#interface_imebra_modality_v_o_i_l_u_t"><span class="std std-ref">ImebraModalityVOILUT</span></a> (if present) </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">frameNumber</span></code>: the frame to retrieve (the first frame is 0) </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pError</span></code>: a pointer to a NSError pointer which is set when an error occurs </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_data_set_1a16eae46106397c872124c48efcebfb91"></span><code class="sig-name descname">NSArray* ImebraDataSet::getVOIs:(NSError ** pError)</code></dt>
<dd><p>Return the list of VOI settings stored in the DataSet. </p>
<p>Each VOI setting includes the center &amp; width values that can be used with the VOILUT transform to highlight different parts of an Image.</p>
<p>If the VOI/LUT information is stored in a functional group, then first use getFunctionalGroupDataSet() to retrieve the sequence item containing the VOI/LUT information, then call getVOIs() on the returned dataset.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>an NSArray containing a list of <a class="reference internal" href="transforms_classes.html#interface_imebra_v_o_i_description"><span class="std std-ref">ImebraVOIDescription</span></a> objects </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pError</span></code>: a pointer to a NSError pointer which is set when an error occurs </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_data_set_1ae7fc9509d7fd27698629f1c8a7ecbae6"></span><code class="sig-name descname">ImebraDataSet* ImebraDataSet::getFunctionalGroupDataSet:error:(unsigned int frameNumber, NSError ** pError)</code></dt>
<dd><p>In case the dataset uses functional groups to store imaging information, then this method returns the sequence item containing imaging information for a specific frame. </p>
<p>The method looks first for a frame specific functional group sequence item, then for a common functional group sequence item if the specific one is missing.</p>
<p>Throws MissingTagError is the dataset does not contain a functional group sequence.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the functional group sequence item for the requested frame. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">frameNumber</span></code>: the frame number for which the functional group sequence item is required </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pError</span></code>: a pointer to a NSError pointer which is set when an error occurs </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_data_set_1adf11f6f5f64671c3564ee8742856d996"></span><code class="sig-name descname">ImebraStreamReader* ImebraDataSet::getStreamReader:bufferId:error:(ImebraTagId  * tagId, unsigned int bufferId, NSError ** pError)</code></dt>
<dd><p>Get a StreamReader connected to a buffer’s data. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the streamReader connected to the buffer’s data. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pTagId</span></code>: the tag’s id for which the StreamReader is required </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bufferId</span></code>: the id of the buffer for which the StreamReader is required. This parameter is usually 0 </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pError</span></code>: set to a NSError derived class in case of error </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_data_set_1ae3514fd259bb657b36cc7fd81d4aa868"></span><code class="sig-name descname">ImebraDataSet* ImebraDataSet::getSequenceItem:item:error:(ImebraTagId  * pTagId, unsigned int itemId, NSError ** pError)</code></dt>
<dd><p>Retrieve a sequence item stored in a tag. </p>
<p>If the specified tag does not exist then set pError to ImebraMissingTagError or ImebraMissingGroupError.</p>
<p>If the specified tag does not contain the specified sequence item then set pError to ImebraMissingItemError.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the requested sequence item </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pTagId</span></code>: the tag’s id containing the sequence item </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">itemId</span></code>: the sequence item to retrieve. The first item has an Id = 0 </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pError</span></code>: a pointer to a NSError pointer which is set when an error occurs </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_data_set_1aed2e34889ae1be296c0da8e33ca12f92"></span><code class="sig-name descname">ImebraLUT* ImebraDataSet::getLUT:item:error:(ImebraTagId  * pTagId, unsigned int itemId, NSError ** pError)</code></dt>
<dd><p>Retrieve a <a class="reference internal" href="transforms_classes.html#interface_imebra_l_u_t"><span class="std std-ref">ImebraLUT</span></a> stored in a sequence item. </p>
<p>If the specified tag does not exist then set pError to ImebraMissingTagError or ImebraMissingGroupError.</p>
<p>If the specified tag does not contain the specified sequence item then set pError to ImebraMissingItemError.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the LUT stored in the requested sequence item </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pTagId</span></code>: the tag’s id containing the sequence that stores the LUTs </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">itemId</span></code>: the sequence item to retrieve. The first item has an Id = 0 </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pError</span></code>: a pointer to a NSError pointer which is set when an error occurs </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_data_set_1adad8d9f3466bca2800ee95d25c16c0a6"></span><code class="sig-name descname">ImebraReadingDataHandler* ImebraDataSet::getReadingDataHandler:bufferId:error:(ImebraTagId  * tagId, unsigned int bufferId, NSError ** pError)</code></dt>
<dd><p>Retrieve an <a class="reference internal" href="#interface_imebra_reading_data_handler"><span class="std std-ref">ImebraReadingDataHandler</span></a> object connected to a specific tag’s buffer. </p>
<p>If the specified tag does not exist then sets pError to ImebraMissingTagError or ImebraMissingGroupError.</p>
<p>If the specified tag does not contain the specified buffer item then sets pError to ImebraMissingBufferError.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>an <a class="reference internal" href="#interface_imebra_reading_data_handler"><span class="std std-ref">ImebraReadingDataHandler</span></a> object connected to the requested tag’s buffer </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id containing the requested buffer </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bufferId</span></code>: the buffer to connect to the ReadingDataHandler object. The first buffer has an Id = 0 </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pError</span></code>: a pointer to a NSError pointer which is set when an error occurs </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_data_set_1aa664e341b0362ef2794a4daa5e36ae02"></span><code class="sig-name descname">ImebraReadingDataHandlerNumeric* ImebraDataSet::getReadingDataHandlerNumeric:bufferId:error:(ImebraTagId  * tagId, unsigned int bufferId, NSError ** pError)</code></dt>
<dd><p>Retrieve a <a class="reference internal" href="#interface_imebra_reading_data_handler_numeric"><span class="std std-ref">ImebraReadingDataHandlerNumeric</span></a> object connected to a specific tag’s numeric buffer. </p>
<p>If the tag’s VR is not a numeric type then throws std::bad_cast.</p>
<p>If the specified tag does not exist then set pError to ImebraMissingTagError or ImebraMissingGroupError.</p>
<p>If the specified tag does not contain the specified buffer item then set pError to ImebraMissingItemError.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>a <a class="reference internal" href="#interface_imebra_reading_data_handler_numeric"><span class="std std-ref">ImebraReadingDataHandlerNumeric</span></a> object connected to the requested tag’s buffer </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id containing the requested buffer </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bufferId</span></code>: the buffer to connect to the ReadingDataHandler object. The first buffer has an Id = 0 </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pError</span></code>: a pointer to a NSError pointer which is set when an error occurs </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_data_set_1adf2512d1865aa9e654fc07573d4325bf"></span><code class="sig-name descname">ImebraReadingDataHandlerNumeric* ImebraDataSet::getReadingDataHandlerRaw:bufferId:error:(ImebraTagId  * tagId, unsigned int bufferId, NSError ** pError)</code></dt>
<dd><p>Retrieve a <a class="reference internal" href="#interface_imebra_reading_data_handler_numeric"><span class="std std-ref">ImebraReadingDataHandlerNumeric</span></a> object connected to a specific tag’s buffer, no matter what the tag’s data type. </p>
<p>If the specified tag does not exist then set pError to ImebraMissingTagError or ImebraMissingGroupError.</p>
<p>If the specified tag does not contain the specified buffer item then set pError to ImebraMissingItemError.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>a <a class="reference internal" href="#interface_imebra_reading_data_handler_numeric"><span class="std std-ref">ImebraReadingDataHandlerNumeric</span></a> object connected to the requested tag’s buffer </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id containing the requested buffer </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bufferId</span></code>: the buffer to connect to the ReadingDataHandler object. The first buffer has an Id = 0 </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pError</span></code>: a pointer to a NSError pointer which is set when an error occurs </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_data_set_1afbeb067afc43ab8dee6568c07a1e461b"></span><code class="sig-name descname">signed int ImebraDataSet::getInt32:elementNumber:error:(ImebraTagId  * tagId, unsigned int elementNumber, (swift_error(nonnull_error)) __attribute__)</code></dt>
<dd><p>Retrieve a tag’s value as signed long integer (32 bit). </p>
<p>If the tag’s value cannot be converted to a signed long integer then sets pError to ImebraDataHandlerConversionError.</p>
<p>If the specified tag does not exist then set pError to ImebraMissingTagError or ImebraMissingGroupError.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the tag’s value as a signed 32 bit integer </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">elementNumber</span></code>: the element number within the buffer </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pError</span></code>: a pointer to a NSError pointer which is set when an error occurs </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_data_set_1a0fbc66687aa639666845721ecd23ffbd"></span><code class="sig-name descname">signed int ImebraDataSet::getSignedLong:elementNumber:error:(ImebraTagId  * tagId, unsigned int elementNumber, (swift_error(nonnull_error)) __attribute__)</code></dt>
<dd><p>Deprecated. Use getInt32() instead. </p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_data_set_1adf98897c44d73346d605955d9c489aaf"></span><code class="sig-name descname">signed short ImebraDataSet::getInt16:elementNumber:error:(ImebraTagId  * tagId, unsigned int elementNumber, (swift_error(nonnull_error)) __attribute__)</code></dt>
<dd><p>Retrieve a tag’s value as signed short integer (16 bit). </p>
<p>If the tag’s value cannot be converted to a signed long integer then sets pError to ImebraDataHandlerConversionError.</p>
<p>If the specified tag does not exist then set pError to ImebraMissingTagError or ImebraMissingGroupError.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the tag’s value as a signed 16 bit integer </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">elementNumber</span></code>: the element number within the buffer </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pError</span></code>: a pointer to a NSError pointer which is set when an error occurs </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_data_set_1a86a8104260663ab41c06e66486edbf6d"></span><code class="sig-name descname">signed char ImebraDataSet::getInt8:elementNumber:error:(ImebraTagId  * tagId, unsigned int elementNumber, (swift_error(nonnull_error)) __attribute__)</code></dt>
<dd><p>Retrieve a tag’s value as signed char integer (8 bit). </p>
<p>If the tag’s value cannot be converted to a signed long integer then sets pError to ImebraDataHandlerConversionError.</p>
<p>If the specified tag does not exist then set pError to ImebraMissingTagError or ImebraMissingGroupError.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the tag’s value as a signed 8 bit integer </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">elementNumber</span></code>: the element number within the buffer </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pError</span></code>: a pointer to a NSError pointer which is set when an error occurs </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_data_set_1a824a7e3df39c5dae712b62bcb1011d9b"></span><code class="sig-name descname">signed int ImebraDataSet::getInt32:elementNumber:defaultValue:error:(ImebraTagId  * tagId, unsigned int elementNumber, signed int defaultValue, (swift_error(nonnull_error)) __attribute__)</code></dt>
<dd><p>Retrieve a tag’s value as signed long integer (32 bit). </p>
<p>If the tag’s value cannot be converted to a signed long integer then sets pError to ImebraDataHandlerConversionError.</p>
<p>If the specified tag does not exist then returns the default value set in the defaultValue parameter.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the tag’s value as a signed 32 bit integer </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">elementNumber</span></code>: the element number within the buffer </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">defaultValue</span></code>: the value to return if the tag doesn’t exist </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pError</span></code>: a pointer to a NSError pointer which is set when an error occurs </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_data_set_1afae02f35e37b63a184317279f9887731"></span><code class="sig-name descname">signed int ImebraDataSet::getSignedLong:elementNumber:defaultValue:error:(ImebraTagId  * tagId, unsigned int elementNumber, signed int defaultValue, (swift_error(nonnull_error)) __attribute__)</code></dt>
<dd><p>Deprecated. Use getInt32() instead. </p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_data_set_1a5c4d8be6eca5df9fd2fb5931bed50d4d"></span><code class="sig-name descname">signed short ImebraDataSet::getInt16:elementNumber:defaultValue:error:(ImebraTagId  * tagId, unsigned int elementNumber, signed short defaultValue, (swift_error(nonnull_error)) __attribute__)</code></dt>
<dd><p>Retrieve a tag’s value as signed short integer (16 bit). </p>
<p>If the tag’s value cannot be converted to a signed long integer then sets pError to ImebraDataHandlerConversionError.</p>
<p>If the specified tag does not exist then returns the default value set in the defaultValue parameter.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the tag’s value as a signed 16 bit integer </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">elementNumber</span></code>: the element number within the buffer </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">defaultValue</span></code>: the value to return if the tag doesn’t exist </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pError</span></code>: a pointer to a NSError pointer which is set when an error occurs </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_data_set_1a4bf28ff79214d1b7f3132d2edeb426c4"></span><code class="sig-name descname">signed char ImebraDataSet::getInt8:elementNumber:defaultValue:error:(ImebraTagId  * tagId, unsigned int elementNumber, signed char defaultValue, (swift_error(nonnull_error)) __attribute__)</code></dt>
<dd><p>Retrieve a tag’s value as signed char integer (8 bit). </p>
<p>If the tag’s value cannot be converted to a signed long integer then sets pError to ImebraDataHandlerConversionError.</p>
<p>If the specified tag does not exist then returns the default value set in the defaultValue parameter.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the tag’s value as a signed 8 bit integer </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">elementNumber</span></code>: the element number within the buffer </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">defaultValue</span></code>: the value to return if the tag doesn’t exist </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pError</span></code>: a pointer to a NSError pointer which is set when an error occurs </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_data_set_1a6b964501e2a02cf1bf8ca86549ae21d2"></span><code class="sig-name descname">unsigned int ImebraDataSet::getUint32:elementNumber:error:(ImebraTagId  * tagId, unsigned int elementNumber, (swift_error(nonnull_error)) __attribute__)</code></dt>
<dd><p>Retrieve a tag’s value as unsigned long integer (32 bit). </p>
<p>When calling getUint32() on an AT tag (Attribute Tag) then the tag group is always in the high word of the returned value.</p>
<p>If the tag’s value cannot be converted to an unsigned long integer then sets pError to ImebraDataHandlerConversionError.</p>
<p>If the specified tag does not exist then set pError to ImebraMissingTagError or ImebraMissingGroupError.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the tag’s value as an unsigned 32 bit integer </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">elementNumber</span></code>: the element number within the buffer </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pError</span></code>: a pointer to a NSError pointer which is set when an error occurs </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_data_set_1aa4518f47f8f44f4258e58028585b5d76"></span><code class="sig-name descname">unsigned int ImebraDataSet::getUnsignedLong:elementNumber:error:(ImebraTagId  * tagId, unsigned int elementNumber, (swift_error(nonnull_error)) __attribute__)</code></dt>
<dd><p>Deprecated. Use getUint32() instead. </p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_data_set_1a3f20eebabe4c3a8e1f837cd907185945"></span><code class="sig-name descname">unsigned short ImebraDataSet::getUint16:elementNumber:error:(ImebraTagId  * tagId, unsigned int elementNumber, (swift_error(nonnull_error)) __attribute__)</code></dt>
<dd><p>Retrieve a tag’s value as unsigned long integer (16 bit). </p>
<p>If the tag’s value cannot be converted to an unsigned long integer then sets pError to ImebraDataHandlerConversionError.</p>
<p>If the specified tag does not exist then set pError to ImebraMissingTagError or ImebraMissingGroupError.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the tag’s value as an unsigned 16 bit integer </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">elementNumber</span></code>: the element number within the buffer </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pError</span></code>: a pointer to a NSError pointer which is set when an error occurs </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_data_set_1ab4c1c60eda11dcb3118b2dbdf6674004"></span><code class="sig-name descname">unsigned char ImebraDataSet::getUint8:elementNumber:error:(ImebraTagId  * tagId, unsigned int elementNumber, (swift_error(nonnull_error)) __attribute__)</code></dt>
<dd><p>Retrieve a tag’s value as unsigned long integer (8 bit). </p>
<p>If the tag’s value cannot be converted to an unsigned long integer then sets pError to ImebraDataHandlerConversionError.</p>
<p>If the specified tag does not exist then set pError to ImebraMissingTagError or ImebraMissingGroupError.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the tag’s value as an unsigned 8 bit integer </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">elementNumber</span></code>: the element number within the buffer </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pError</span></code>: a pointer to a NSError pointer which is set when an error occurs </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_data_set_1aace70faae852fb3a8b791006d73f9836"></span><code class="sig-name descname">unsigned int ImebraDataSet::getUint32:elementNumber:defaultValue:error:(ImebraTagId  * tagId, unsigned int elementNumber, unsigned int defaultValue, (swift_error(nonnull_error)) __attribute__)</code></dt>
<dd><p>Retrieve a tag’s value as unsigned long integer (32 bit). </p>
<p>When calling getUint32() on an AT tag (Attribute Tag) then the tag group is always in the high word of the returned value.</p>
<p>If the tag’s value cannot be converted to an unsigned long integer then sets pError to ImebraDataHandlerConversionError.</p>
<p>If the specified tag does not exist then returns the default value set in the defaultValue parameter.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the tag’s value as an unsigned 32 bit integer </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">elementNumber</span></code>: the element number within the buffer </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">defaultValue</span></code>: the value to return if the tag doesn’t exist </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pError</span></code>: a pointer to a NSError pointer which is set when an error occurs </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_data_set_1a894a704b544fcfee06b40bf304b39357"></span><code class="sig-name descname">unsigned int ImebraDataSet::getUnsignedLong:elementNumber:defaultValue:error:(ImebraTagId  * tagId, unsigned int elementNumber, unsigned int defaultValue, (swift_error(nonnull_error)) __attribute__)</code></dt>
<dd><p>Deprecated. Use getUint32() instead. </p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_data_set_1a3b9435b6e060514da9d378827d3f28c2"></span><code class="sig-name descname">unsigned short ImebraDataSet::getUint16:elementNumber:defaultValue:error:(ImebraTagId  * tagId, unsigned int elementNumber, unsigned short defaultValue, (swift_error(nonnull_error)) __attribute__)</code></dt>
<dd><p>Retrieve a tag’s value as unsigned long integer (16 bit). </p>
<p>If the tag’s value cannot be converted to an unsigned long integer then sets pError to ImebraDataHandlerConversionError.</p>
<p>If the specified tag does not exist then returns the default value set in the defaultValue parameter.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the tag’s value as an unsigned 16 bit integer </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">elementNumber</span></code>: the element number within the buffer </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">defaultValue</span></code>: the value to return if the tag doesn’t exist </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pError</span></code>: a pointer to a NSError pointer which is set when an error occurs </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_data_set_1adba4a85e0d8708cd7dbee474fa50ba49"></span><code class="sig-name descname">unsigned char ImebraDataSet::getUint8:elementNumber:defaultValue:error:(ImebraTagId  * tagId, unsigned int elementNumber, unsigned char defaultValue, (swift_error(nonnull_error)) __attribute__)</code></dt>
<dd><p>Retrieve a tag’s value as unsigned long integer (8 bit). </p>
<p>If the tag’s value cannot be converted to an unsigned long integer then sets pError to ImebraDataHandlerConversionError.</p>
<p>If the specified tag does not exist then returns the default value set in the defaultValue parameter.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the tag’s value as an unsigned 8 bit integer </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">elementNumber</span></code>: the element number within the buffer </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">defaultValue</span></code>: the value to return if the tag doesn’t exist </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pError</span></code>: a pointer to a NSError pointer which is set when an error occurs </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_data_set_1a199e236396331a6102308b396ded6101"></span><code class="sig-name descname">double ImebraDataSet::getDouble:elementNumber:error:(ImebraTagId  * tagId, unsigned int elementNumber, (swift_error(nonnull_error)) __attribute__)</code></dt>
<dd><p>Retrieve a tag’s value as a double floating point. </p>
<p>If the tag’s value cannot be converted to double floating point then sets pError to ImebraDataHandlerConversionError.</p>
<p>If the specified tag does not exist then set pError to ImebraMissingTagError or ImebraMissingGroupError.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the tag’s value as a double floating point </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">elementNumber</span></code>: the element number within the buffer </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pError</span></code>: a pointer to a NSError pointer which is set when an error occurs </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_data_set_1a6a5ad9771027116086a608c04b5c908d"></span><code class="sig-name descname">float ImebraDataSet::getFloat:elementNumber:error:(ImebraTagId  * tagId, unsigned int elementNumber, (swift_error(nonnull_error)) __attribute__)</code></dt>
<dd><p>Retrieve a tag’s value as a floating point value. </p>
<p>If the tag’s value cannot be converted to double floating point then sets pError to ImebraDataHandlerConversionError.</p>
<p>If the specified tag does not exist then set pError to ImebraMissingTagError or ImebraMissingGroupError.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the tag’s value as a floating point </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">elementNumber</span></code>: the element number within the buffer </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pError</span></code>: a pointer to a NSError pointer which is set when an error occurs </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_data_set_1a809ee64a66b62b0dc56a18a8225a73dd"></span><code class="sig-name descname">double ImebraDataSet::getDouble:elementNumber:defaultValue:error:(ImebraTagId  * tagId, unsigned int elementNumber, double defaultValue, (swift_error(nonnull_error)) __attribute__)</code></dt>
<dd><p>Retrieve a tag’s value as a double floating point. </p>
<p>If the tag’s value cannot be converted to double floating point then sets pError to ImebraDataHandlerConversionError.</p>
<p>If the specified tag does not exist then returns the default value set in the defaultValue parameter.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the tag’s value as a double floating point </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">elementNumber</span></code>: the element number within the buffer </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">defaultValue</span></code>: the value to return if the tag doesn’t exist </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pError</span></code>: a pointer to a NSError pointer which is set when an error occurs </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_data_set_1a2f4c7c4506f619fbde56f67913a1b061"></span><code class="sig-name descname">float ImebraDataSet::getFloat:elementNumber:defaultValue:error:(ImebraTagId  * tagId, unsigned int elementNumber, float defaultValue, (swift_error(nonnull_error)) __attribute__)</code></dt>
<dd><p>Retrieve a tag’s value as a floating point value. </p>
<p>If the tag’s value cannot be converted to double floating point then sets pError to ImebraDataHandlerConversionError.</p>
<p>If the specified tag does not exist then returns the default value set in the defaultValue parameter.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the tag’s value as a floating point </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">elementNumber</span></code>: the element number within the buffer </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">defaultValue</span></code>: the value to return if the tag doesn’t exist </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pError</span></code>: a pointer to a NSError pointer which is set when an error occurs </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_data_set_1a4dcd9dd6173006e413a0869159025ec0"></span><code class="sig-name descname">NSString* ImebraDataSet::getString:elementNumber:error:(ImebraTagId  * tagId, unsigned int elementNumber, NSError ** pError)</code></dt>
<dd><p>Retrieve a tag’s value as a string. </p>
<p>If the tag’s value cannot be converted to a string then sets pError to ImebraDataHandlerConversionError.</p>
<p>If the specified tag does not exist then set pError to ImebraMissingTagError or ImebraMissingGroupError.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the tag’s value as a string </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">elementNumber</span></code>: the element number within the buffer </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pError</span></code>: a pointer to a NSError pointer which is set when an error occurs </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_data_set_1abd281a770178c4e6b5c65d5ee3c4f93e"></span><code class="sig-name descname">NSString* ImebraDataSet::getString:elementNumber:defaultValue:error:(ImebraTagId  * tagId, unsigned int elementNumber, NSString * defaultValue, NSError ** pError)</code></dt>
<dd><p>Retrieve a tag’s value as a string. </p>
<p>If the tag’s value cannot be converted to a string then sets pError to ImebraDataHandlerConversionError.</p>
<p>If the specified tag does not exist then returns the default value set in the defaultValue parameter.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the tag’s value as a string </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">elementNumber</span></code>: the element number within the buffer </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">defaultValue</span></code>: the value to return if the tag doesn’t exist </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pError</span></code>: a pointer to a NSError pointer which is set when an error occurs </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_data_set_1a2ab154f475d972cecb43b0cf933a57a1"></span><code class="sig-name descname">ImebraAge* ImebraDataSet::getAge:elementNumber:error:(ImebraTagId  * tagId, unsigned int elementNumber, NSError ** pError)</code></dt>
<dd><p>Retrieve a tag’s value as an <a class="reference internal" href="#interface_imebra_age"><span class="std std-ref">ImebraAge</span></a> object. </p>
<p>If the tag’s value cannot be converted to an <a class="reference internal" href="#interface_imebra_age"><span class="std std-ref">ImebraAge</span></a> object then sets pError to ImebraDataHandlerConversionError.</p>
<p>If the specified tag does not exist then set pError to ImebraMissingTagError or ImebraMissingGroupError.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the tag’s value as an <a class="reference internal" href="#interface_imebra_age"><span class="std std-ref">ImebraAge</span></a> object </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">elementNumber</span></code>: the element number within the buffer </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pError</span></code>: a pointer to a NSError pointer which is set when an error occurs </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_data_set_1a1aa0d44a0b4b377a4891d2a819fa2249"></span><code class="sig-name descname">ImebraAge* ImebraDataSet::getAge:elementNumber:defaultValue:error:(ImebraTagId  * tagId, unsigned int elementNumber, ImebraAge  * defaultValue, NSError ** pError)</code></dt>
<dd><p>Retrieve a tag’s value as an <a class="reference internal" href="#interface_imebra_age"><span class="std std-ref">ImebraAge</span></a> object. </p>
<p>If the tag’s value cannot be converted to an <a class="reference internal" href="#interface_imebra_age"><span class="std std-ref">ImebraAge</span></a> object then sets pError to ImebraDataHandlerConversionError.</p>
<p>If the specified tag does not exist then returns the default value set in the defaultValue parameter.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the tag’s value as an <a class="reference internal" href="#interface_imebra_age"><span class="std std-ref">ImebraAge</span></a> object </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">elementNumber</span></code>: the element number within the buffer </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">defaultValue</span></code>: the value to return if the tag doesn’t exist </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pError</span></code>: a pointer to a NSError pointer which is set when an error occurs </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_data_set_1a9e36e315981aa3e4bdcc4ce842900bf0"></span><code class="sig-name descname">ImebraDate* ImebraDataSet::getDate:elementNumber:error:(ImebraTagId  * tagId, unsigned int elementNumber, NSError ** pError)</code></dt>
<dd><p>Retrieve a tag’s value as an ImebraDate object. </p>
<p>If the tag’s value cannot be converted to an ImebraDate object then sets pError to ImebraDataHandlerConversionError.</p>
<p>If the specified tag does not exist then set pError to ImebraMissingTagError or ImebraMissingGroupError.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the tag’s value as an ImebraDate object </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">elementNumber</span></code>: the element number within the buffer </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pError</span></code>: a pointer to a NSError pointer which is set when an error occurs </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_data_set_1a6a3bf0e45be2007b7778f3e3345cabf5"></span><code class="sig-name descname">ImebraDate* ImebraDataSet::getDate:elementNumber:defaultValue:error:(ImebraTagId  * tagId, unsigned int elementNumber, ImebraDate * defaultValue, NSError ** pError)</code></dt>
<dd><p>Retrieve a tag’s value as an ImebraDate object. </p>
<p>If the tag’s value cannot be converted to an ImebraDate object then sets pError to ImebraDataHandlerConversionError.</p>
<p>If the specified tag does not exist then returns the default value set in the defaultValue parameter.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the tag’s value as an ImebraDate object </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">elementNumber</span></code>: the element number within the buffer </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">defaultValue</span></code>: the value to return if the tag doesn’t exist </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pError</span></code>: a pointer to a NSError pointer which is set when an error occurs </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_data_set_1aa15e547ad697e3a9cfb493a82000cc88"></span><code class="sig-name descname">ImebraPatientName* ImebraDataSet::getPatientName:elementNumber:error:(ImebraTagId  * tagId, unsigned int elementNumber, NSError ** pError)</code></dt>
<dd><p>Retrieve a tag’s value as an ImebraPatientName object. </p>
<p>If the tag’s value cannot be converted to an ImebraPatientName object then sets pError to ImebraDataHandlerConversionError.</p>
<p>If the specified tag does not exist then set pError to ImebraMissingTagError or ImebraMissingGroupError.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the tag’s value as an ImebraDate object </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">elementNumber</span></code>: the element number within the buffer </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pError</span></code>: a pointer to a NSError pointer which is set when an error occurs </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_data_set_1a0fa77e41521e98ac927ea29ae5bf1103"></span><code class="sig-name descname">ImebraPatientName* ImebraDataSet::getPatientName:elementNumber:defaultValue:error:(ImebraTagId  * tagId, unsigned int elementNumber, ImebraPatientName * defaultValue, NSError ** pError)</code></dt>
<dd><p>Retrieve a tag’s value as an ImebraPatientName object. </p>
<p>If the tag’s value cannot be converted to an ImebraPatientName object then sets pError to ImebraDataHandlerConversionError.</p>
<p>If the specified tag does not exist then returns the default value set in the defaultValue parameter.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the tag’s value as an ImebraDate object </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">elementNumber</span></code>: the element number within the buffer </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">defaultValue</span></code>: the value to return if the tag doesn’t exist </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pError</span></code>: a pointer to a NSError pointer which is set when an error occurs </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_data_set_1aa5b592da14e5f9ad6cc6e777ac6b6d20"></span><code class="sig-name descname">ImebraTagType ImebraDataSet::getDataType:error:(ImebraTagId  * tagId, (swift_error(nonnull_error)) __attribute__)</code></dt>
<dd><p>Return the data type (VR) of the specified tag. </p>
<p>If the specified tag does not exist then set pError to ImebraMissingTagError or ImebraMissingGroupError.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the tag’s data type (VR) </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the id of the tag </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pError</span></code>: a pointer to a NSError pointer which is set when an error occurs </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</div>
</div>
<div class="section" id="mutabledataset">
<span id="id2"></span><h3>MutableDataSet<a class="headerlink" href="#mutabledataset" title="Permalink to this headline">¶</a></h3>
<div class="section" id="id3">
<h4>C++<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h4>
<dl class="class">
<dt id="_CPPv4N6imebra14MutableDataSetE">
<span id="_CPPv3N6imebra14MutableDataSetE"></span><span id="_CPPv2N6imebra14MutableDataSetE"></span><span id="imebra::MutableDataSet"></span><span class="target" id="classimebra_1_1_mutable_data_set"></span><em class="property">class </em><code class="sig-name descname">MutableDataSet</code> : <em class="property">public</em> imebra::<a class="reference internal" href="#_CPPv4N6imebra7DataSetE" title="imebra::DataSet">DataSet</a><a class="headerlink" href="#_CPPv4N6imebra14MutableDataSetE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This class represents a mutable DICOM dataset. </p>
<p>The information it contains is organized into groups and each group may contain several tags.</p>
<p>You can create an empty <a class="reference internal" href="#classimebra_1_1_data_set"><span class="std std-ref">DataSet</span></a> that can be filled with data and images and then saved to a DICOM file via <a class="reference internal" href="stream_classes.html#classimebra_1_1_codec_factory_1ac7b5fa45cb5450133fff02b48f70261f"><span class="std std-ref">CodecFactory::save()</span></a>.</p>
<p>When creating an empty <a class="reference internal" href="#classimebra_1_1_data_set"><span class="std std-ref">DataSet</span></a> you should specify the proper transfer syntax in the <a class="reference internal" href="#classimebra_1_1_data_set"><span class="std std-ref">DataSet</span></a> constructor.</p>
<p>To set the <a class="reference internal" href="#classimebra_1_1_data_set"><span class="std std-ref">DataSet</span></a>’s content, use one of the following methods:<ul class="simple">
<li><p><a class="reference internal" href="#classimebra_1_1_mutable_data_set_1a59c642961ca99fbf31a475f4242f98e2"><span class="std std-ref">setImage()</span></a></p></li>
<li><p>setSequenceItem()</p></li>
<li><p><a class="reference internal" href="#classimebra_1_1_mutable_data_set_1a3d6da04ba9e3834baecbcb8ac844cd41"><span class="std std-ref">setInt32()</span></a></p></li>
<li><p><a class="reference internal" href="#classimebra_1_1_mutable_data_set_1a87174a161042505d10e321c0ca25fbb2"><span class="std std-ref">setUint32()</span></a></p></li>
<li><p><a class="reference internal" href="#classimebra_1_1_mutable_data_set_1a86c80370ee588ccf6dcc7c68ad9ef0af"><span class="std std-ref">setInt16()</span></a></p></li>
<li><p><a class="reference internal" href="#classimebra_1_1_mutable_data_set_1a04f3947128c42ffb2ef8902e7c1227e4"><span class="std std-ref">setUint16()</span></a></p></li>
<li><p><a class="reference internal" href="#classimebra_1_1_mutable_data_set_1a8370c98604a513c09fca54752bed6f96"><span class="std std-ref">setInt8()</span></a></p></li>
<li><p><a class="reference internal" href="#classimebra_1_1_mutable_data_set_1abb66ba0b404357cfe351f411f7c2f866"><span class="std std-ref">setUint8()</span></a></p></li>
<li><p><a class="reference internal" href="#classimebra_1_1_mutable_data_set_1a7a58136cdadd5e9687c627fcb75df105"><span class="std std-ref">setDouble()</span></a></p></li>
<li><p><a class="reference internal" href="#classimebra_1_1_mutable_data_set_1a5b9ac24c1e554f7e53ede2d4dbdb7615"><span class="std std-ref">setFloat()</span></a></p></li>
<li><p><a class="reference internal" href="#classimebra_1_1_mutable_data_set_1a8bf2111e96efb240bdb45335955c0c84"><span class="std std-ref">setString()</span></a></p></li>
<li><p><a class="reference internal" href="#classimebra_1_1_mutable_data_set_1a7c09812ae31ac51a6c5cc8339a036b74"><span class="std std-ref">setUnicodeString()</span></a></p></li>
<li><p><a class="reference internal" href="#classimebra_1_1_mutable_data_set_1aab6de4ac863b7f2650e9ae19e8b03fb2"><span class="std std-ref">setAge()</span></a></p></li>
<li><p><a class="reference internal" href="#classimebra_1_1_mutable_data_set_1afdd9bc0e4d3ab6da48d112ea7a64d71b"><span class="std std-ref">setDate()</span></a></p></li>
</ul>
</p>
<p>The previous methods allow to write just the first item in the tag’s content and before writing wipe out the old tag’s content (all the items). If you have to write more than one item in a tag, retrieve a <a class="reference internal" href="#classimebra_1_1_writing_data_handler"><span class="std std-ref">WritingDataHandler</span></a> with <a class="reference internal" href="#classimebra_1_1_mutable_data_set_1ade3a5a8493874714259fd5e3da99dc30"><span class="std std-ref">getWritingDataHandler()</span></a> and then modify all the tag’s items using the <a class="reference internal" href="#classimebra_1_1_writing_data_handler"><span class="std std-ref">WritingDataHandler</span></a>. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv4N6imebra14MutableDataSet14MutableDataSetERK14MutableDataSet">
<span id="_CPPv3N6imebra14MutableDataSet14MutableDataSetERK14MutableDataSet"></span><span id="_CPPv2N6imebra14MutableDataSet14MutableDataSetERK14MutableDataSet"></span><span id="imebra::MutableDataSet::MutableDataSet__MutableDataSetCR"></span><span class="target" id="classimebra_1_1_mutable_data_set_1a90a1b5705be86e80456899b6cabb714f"></span><code class="sig-name descname">MutableDataSet</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N6imebra14MutableDataSet14MutableDataSetERK14MutableDataSet" title="imebra::MutableDataSet::MutableDataSet">MutableDataSet</a> &amp;<em>source</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N6imebra14MutableDataSet14MutableDataSetERK14MutableDataSet" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Copy constructor. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">source</span></code>: the source data set </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N6imebra14MutableDataSet14MutableDataSetEv">
<span id="_CPPv3N6imebra14MutableDataSet14MutableDataSetEv"></span><span id="_CPPv2N6imebra14MutableDataSet14MutableDataSetEv"></span><span id="imebra::MutableDataSet::MutableDataSet"></span><span class="target" id="classimebra_1_1_mutable_data_set_1a6e996d545c241fbfc3c85b0d1a0786ff"></span><code class="sig-name descname">MutableDataSet</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N6imebra14MutableDataSet14MutableDataSetEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Construct an empty DICOM dataset with unspecified transfer syntax (which represents the default value “1.2.840.10008.1.2” or “Implicit VR little endian”) and default charset (“ISO 2022 IR 6”). </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N6imebra14MutableDataSet14MutableDataSetERKNSt6stringE">
<span id="_CPPv3N6imebra14MutableDataSet14MutableDataSetERKNSt6stringE"></span><span id="_CPPv2N6imebra14MutableDataSet14MutableDataSetERKNSt6stringE"></span><span id="imebra::MutableDataSet::MutableDataSet__ssCR"></span><span class="target" id="classimebra_1_1_mutable_data_set_1aa52edbcae419c776b458ec68df989a87"></span><code class="sig-name descname">MutableDataSet</code><span class="sig-paren">(</span><em class="property">const</em> std::string &amp;<em>transferSyntax</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N6imebra14MutableDataSet14MutableDataSetERKNSt6stringE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Construct an empty DICOM dataset with charset “ISO 2022 IR 6” and the desidered transfer syntax. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">transferSyntax</span></code>: the dataSet’s transfer syntax. The following transfer syntaxes are supported:<ul>
<li><p>”1.2.840.10008.1.2” (Implicit VR little endian)</p></li>
<li><p>”1.2.840.10008.1.2.1” (Explicit VR little endian)</p></li>
<li><p>”1.2.840.10008.1.2.2” (Explicit VR big endian)</p></li>
<li><p>”1.2.840.10008.1.2.5” (RLE compression)</p></li>
<li><p>”1.2.840.10008.1.2.4.50” (Jpeg baseline 8 bit lossy)</p></li>
<li><p>”1.2.840.10008.1.2.4.51” (Jpeg extended 12 bit lossy)</p></li>
<li><p>”1.2.840.10008.1.2.4.57” (Jpeg lossless NH)</p></li>
<li><p>”1.2.840.10008.1.2.4.70” (Jpeg lossless NH first order prediction) </p></li>
</ul>
</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N6imebra14MutableDataSet14MutableDataSetERKNSt6stringERK14charsetsList_t">
<span id="_CPPv3N6imebra14MutableDataSet14MutableDataSetERKNSt6stringERK14charsetsList_t"></span><span id="_CPPv2N6imebra14MutableDataSet14MutableDataSetERKNSt6stringERK14charsetsList_t"></span><span id="imebra::MutableDataSet::MutableDataSet__ssCR.charsetsList_tCR"></span><span class="target" id="classimebra_1_1_mutable_data_set_1ad8d2b8e41a12f4d4f8d594808cf5e306"></span><code class="sig-name descname">MutableDataSet</code><span class="sig-paren">(</span><em class="property">const</em> std::string &amp;<em>transferSyntax</em>, <em class="property">const</em> charsetsList_t &amp;<em>charsets</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N6imebra14MutableDataSet14MutableDataSetERKNSt6stringERK14charsetsList_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Construct an empty DICOM dataset and specifies the default charsets. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">transferSyntax</span></code>: the dataSet’s transfer syntax. The following transfer syntaxes are supported:<ul>
<li><p>”1.2.840.10008.1.2” (Implicit VR little endian)</p></li>
<li><p>”1.2.840.10008.1.2.1” (Explicit VR little endian)</p></li>
<li><p>”1.2.840.10008.1.2.2” (Explicit VR big endian)</p></li>
<li><p>”1.2.840.10008.1.2.5” (RLE compression)</p></li>
<li><p>”1.2.840.10008.1.2.4.50” (Jpeg baseline 8 bit lossy)</p></li>
<li><p>”1.2.840.10008.1.2.4.51” (Jpeg extended 12 bit lossy)</p></li>
<li><p>”1.2.840.10008.1.2.4.57” (Jpeg lossless NH)</p></li>
<li><p>”1.2.840.10008.1.2.4.70” (Jpeg lossless NH first order prediction)</p></li>
</ul>
</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">charsets</span></code>: a list of charsets supported by the <a class="reference internal" href="#classimebra_1_1_data_set"><span class="std std-ref">DataSet</span></a> </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N6imebra14MutableDataSet12getTagCreateERK5TagId7tagVR_t">
<span id="_CPPv3N6imebra14MutableDataSet12getTagCreateERK5TagId7tagVR_t"></span><span id="_CPPv2N6imebra14MutableDataSet12getTagCreateERK5TagId7tagVR_t"></span><span id="imebra::MutableDataSet::getTagCreate__TagIdCR.tagVR_t"></span><span class="target" id="classimebra_1_1_mutable_data_set_1af1714173084e94663db8f747d293071d"></span><a class="reference internal" href="#_CPPv4N6imebra10MutableTagE" title="imebra::MutableTag">MutableTag</a> <code class="sig-name descname">getTagCreate</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, <a class="reference internal" href="definition_classes.html#_CPPv4N6imebra7tagVR_tE" title="imebra::tagVR_t">tagVR_t</a> <em>tagVR</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N6imebra14MutableDataSet12getTagCreateERK5TagId7tagVR_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Retrieve the <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a> with the specified ID or create it if it doesn’t exist. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a> with the specified ID </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the ID of the tag to retrieve </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">tagVR</span></code>: the VR to use for the new tag if one doesn’t exist already </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N6imebra14MutableDataSet12getTagCreateERK5TagId">
<span id="_CPPv3N6imebra14MutableDataSet12getTagCreateERK5TagId"></span><span id="_CPPv2N6imebra14MutableDataSet12getTagCreateERK5TagId"></span><span id="imebra::MutableDataSet::getTagCreate__TagIdCR"></span><span class="target" id="classimebra_1_1_mutable_data_set_1ae2fe37df7e8a3f3d9411e3287e4796d6"></span><a class="reference internal" href="#_CPPv4N6imebra10MutableTagE" title="imebra::MutableTag">MutableTag</a> <code class="sig-name descname">getTagCreate</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N6imebra14MutableDataSet12getTagCreateERK5TagId" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Retrieve the <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a> with the specified ID or create it if it doesn’t exist. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a> with the specified ID </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the ID of the tag to retrieve </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N6imebra14MutableDataSet8setImageE6size_tRK5Image14imageQuality_t">
<span id="_CPPv3N6imebra14MutableDataSet8setImageE6size_tRK5Image14imageQuality_t"></span><span id="_CPPv2N6imebra14MutableDataSet8setImageE6size_tRK5Image14imageQuality_t"></span><span id="imebra::MutableDataSet::setImage__s.ImageCR.imageQuality_t"></span><span class="target" id="classimebra_1_1_mutable_data_set_1a59c642961ca99fbf31a475f4242f98e2"></span>void <code class="sig-name descname">setImage</code><span class="sig-paren">(</span>size_t <em>frameNumber</em>, <em class="property">const</em> <a class="reference internal" href="imaging_classes.html#_CPPv4N6imebra5ImageE" title="imebra::Image">Image</a> &amp;<em>image</em>, <a class="reference internal" href="definition_classes.html#_CPPv4N6imebra14imageQuality_tE" title="imebra::imageQuality_t">imageQuality_t</a> <em>quality</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N6imebra14MutableDataSet8setImageE6size_tRK5Image14imageQuality_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Insert an image into the dataset. </p>
<p>In multi-frame datasets the images must be inserted in order: first, insert the frame 0, then the frame 1, then the frame 2 and so on.</p>
<p>All the inserted images must have the same transfer syntax and the same properties (size, color space, high bit, bits allocated).</p>
<p>If the images are inserted in the wrong order then the <a class="reference internal" href="exception_classes.html#classimebra_1_1_data_set_wrong_frame_error"><span class="std std-ref">DataSetWrongFrameError</span></a> exception is thrown.</p>
<p>If the image being inserted has different properties than the ones of the images already in the dataset then the exception <a class="reference internal" href="exception_classes.html#classimebra_1_1_data_set_different_format_error"><span class="std std-ref">DataSetDifferentFormatError</span></a> is thrown.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">frameNumber</span></code>: the frame number (the first frame is 0) </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">image</span></code>: the image </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">quality</span></code>: the quality to use for lossy compression. Ignored if lossless compression is used </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N6imebra14MutableDataSet15getStreamWriterERK5TagId6size_t7tagVR_t">
<span id="_CPPv3N6imebra14MutableDataSet15getStreamWriterERK5TagId6size_t7tagVR_t"></span><span id="_CPPv2N6imebra14MutableDataSet15getStreamWriterERK5TagId6size_t7tagVR_t"></span><span id="imebra::MutableDataSet::getStreamWriter__TagIdCR.s.tagVR_t"></span><span class="target" id="classimebra_1_1_mutable_data_set_1a35f1b999e473845a1dea8fdf09671480"></span><a class="reference internal" href="stream_classes.html#_CPPv4N6imebra12StreamWriterE" title="imebra::StreamWriter">StreamWriter</a> <code class="sig-name descname">getStreamWriter</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, size_t <em>bufferId</em>, <a class="reference internal" href="definition_classes.html#_CPPv4N6imebra7tagVR_tE" title="imebra::tagVR_t">tagVR_t</a> <em>tagVR</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N6imebra14MutableDataSet15getStreamWriterERK5TagId6size_t7tagVR_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get a <a class="reference internal" href="stream_classes.html#classimebra_1_1_stream_writer"><span class="std std-ref">StreamWriter</span></a> connected to a tag buffer’s data. </p>
<p>If the specified <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a> does not exist then it creates a new tag with the VR specified in the tagVR parameter</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the <a class="reference internal" href="stream_classes.html#classimebra_1_1_stream_writer"><span class="std std-ref">StreamWriter</span></a> connected to the buffer’s data. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id for which the <a class="reference internal" href="stream_classes.html#classimebra_1_1_stream_writer"><span class="std std-ref">StreamWriter</span></a> is required </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bufferId</span></code>: the id of the buffer for which the <a class="reference internal" href="stream_classes.html#classimebra_1_1_stream_writer"><span class="std std-ref">StreamWriter</span></a> is required. This parameter is usually 0 </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">tagVR</span></code>: the tag’s VR </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N6imebra14MutableDataSet15getStreamWriterERK5TagId6size_t">
<span id="_CPPv3N6imebra14MutableDataSet15getStreamWriterERK5TagId6size_t"></span><span id="_CPPv2N6imebra14MutableDataSet15getStreamWriterERK5TagId6size_t"></span><span id="imebra::MutableDataSet::getStreamWriter__TagIdCR.s"></span><span class="target" id="classimebra_1_1_mutable_data_set_1af643f0db886571d609026a0d07a34a91"></span><a class="reference internal" href="stream_classes.html#_CPPv4N6imebra12StreamWriterE" title="imebra::StreamWriter">StreamWriter</a> <code class="sig-name descname">getStreamWriter</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, size_t <em>bufferId</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N6imebra14MutableDataSet15getStreamWriterERK5TagId6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get a <a class="reference internal" href="stream_classes.html#classimebra_1_1_stream_writer"><span class="std std-ref">StreamWriter</span></a> connected to a tag buffer’s data. </p>
<p>If the specified <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a> does not exist then it creates a new tag with a default VR retrieved from the <a class="reference internal" href="dicom_dictionary_classes.html#classimebra_1_1_dicom_dictionary"><span class="std std-ref">DicomDictionary</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the <a class="reference internal" href="stream_classes.html#classimebra_1_1_stream_writer"><span class="std std-ref">StreamWriter</span></a> connected to the buffer’s data. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id for which the <a class="reference internal" href="stream_classes.html#classimebra_1_1_stream_writer"><span class="std std-ref">StreamWriter</span></a> is required </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bufferId</span></code>: the id of the buffer for which the <a class="reference internal" href="stream_classes.html#classimebra_1_1_stream_writer"><span class="std std-ref">StreamWriter</span></a> is required. This parameter is usually 0 </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N6imebra14MutableDataSet18appendSequenceItemERK5TagId">
<span id="_CPPv3N6imebra14MutableDataSet18appendSequenceItemERK5TagId"></span><span id="_CPPv2N6imebra14MutableDataSet18appendSequenceItemERK5TagId"></span><span id="imebra::MutableDataSet::appendSequenceItem__TagIdCR"></span><span class="target" id="classimebra_1_1_mutable_data_set_1ae0e2e53fcb3e9ed7e4d85cd2e0d1aef3"></span><a class="reference internal" href="#_CPPv4N6imebra14MutableDataSetE" title="imebra::MutableDataSet">MutableDataSet</a> <code class="sig-name descname">appendSequenceItem</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N6imebra14MutableDataSet18appendSequenceItemERK5TagId" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Append a sequence item. </p>
<p>If the specified <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a> does not exist then creates a new one with VR tagVR_t::SQ.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the <a class="reference internal" href="#classimebra_1_1_mutable_data_set"><span class="std std-ref">MutableDataSet</span></a> representing the added sequence item </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id in which the sequence must be stored </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N6imebra14MutableDataSet21getWritingDataHandlerERK5TagId6size_t7tagVR_t">
<span id="_CPPv3N6imebra14MutableDataSet21getWritingDataHandlerERK5TagId6size_t7tagVR_t"></span><span id="_CPPv2N6imebra14MutableDataSet21getWritingDataHandlerERK5TagId6size_t7tagVR_t"></span><span id="imebra::MutableDataSet::getWritingDataHandler__TagIdCR.s.tagVR_t"></span><span class="target" id="classimebra_1_1_mutable_data_set_1ade3a5a8493874714259fd5e3da99dc30"></span><a class="reference internal" href="#_CPPv4N6imebra18WritingDataHandlerE" title="imebra::WritingDataHandler">WritingDataHandler</a> <code class="sig-name descname">getWritingDataHandler</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, size_t <em>bufferId</em>, <a class="reference internal" href="definition_classes.html#_CPPv4N6imebra7tagVR_tE" title="imebra::tagVR_t">tagVR_t</a> <em>tagVR</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N6imebra14MutableDataSet21getWritingDataHandlerERK5TagId6size_t7tagVR_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Retrieve a <a class="reference internal" href="#classimebra_1_1_writing_data_handler"><span class="std std-ref">WritingDataHandler</span></a> object connected to a specific tag’s buffer. </p>
<p>If the specified <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a> does not exist then it creates a new tag with the VR specified in the tagVR parameter</p>
<p>The returned <a class="reference internal" href="#classimebra_1_1_writing_data_handler"><span class="std std-ref">WritingDataHandler</span></a> is connected to a new buffer which is updated and stored into the tag when <a class="reference internal" href="#classimebra_1_1_writing_data_handler"><span class="std std-ref">WritingDataHandler</span></a> is destroyed.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>a <a class="reference internal" href="#classimebra_1_1_writing_data_handler"><span class="std std-ref">WritingDataHandler</span></a> object connected to a new <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a>’s buffer </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id containing the requested buffer </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bufferId</span></code>: the position where the new buffer has to be stored in the tag. The first buffer position is 0 </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">tagVR</span></code>: the tag’s VR </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N6imebra14MutableDataSet21getWritingDataHandlerERK5TagId6size_t">
<span id="_CPPv3N6imebra14MutableDataSet21getWritingDataHandlerERK5TagId6size_t"></span><span id="_CPPv2N6imebra14MutableDataSet21getWritingDataHandlerERK5TagId6size_t"></span><span id="imebra::MutableDataSet::getWritingDataHandler__TagIdCR.s"></span><span class="target" id="classimebra_1_1_mutable_data_set_1a238899e743034fc439fbedb84033a39a"></span><a class="reference internal" href="#_CPPv4N6imebra18WritingDataHandlerE" title="imebra::WritingDataHandler">WritingDataHandler</a> <code class="sig-name descname">getWritingDataHandler</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, size_t <em>bufferId</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N6imebra14MutableDataSet21getWritingDataHandlerERK5TagId6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Retrieve a <a class="reference internal" href="#classimebra_1_1_writing_data_handler"><span class="std std-ref">WritingDataHandler</span></a> object connected to a specific tag’s buffer. </p>
<p>If the specified <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a> does not exist then it creates a new tag with a default VR retrieved from the <a class="reference internal" href="dicom_dictionary_classes.html#classimebra_1_1_dicom_dictionary"><span class="std std-ref">DicomDictionary</span></a>.</p>
<p>The returned <a class="reference internal" href="#classimebra_1_1_writing_data_handler"><span class="std std-ref">WritingDataHandler</span></a> is connected to a new buffer which is updated and stored into the tag when <a class="reference internal" href="#classimebra_1_1_writing_data_handler"><span class="std std-ref">WritingDataHandler</span></a> is destroyed.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>a <a class="reference internal" href="#classimebra_1_1_writing_data_handler"><span class="std std-ref">WritingDataHandler</span></a> object connected to a new <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a>’s buffer </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id containing the requested buffer </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bufferId</span></code>: the position where the new buffer has to be stored in the tag. The first buffer position is 0 </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N6imebra14MutableDataSet28getWritingDataHandlerNumericERK5TagId6size_t7tagVR_t">
<span id="_CPPv3N6imebra14MutableDataSet28getWritingDataHandlerNumericERK5TagId6size_t7tagVR_t"></span><span id="_CPPv2N6imebra14MutableDataSet28getWritingDataHandlerNumericERK5TagId6size_t7tagVR_t"></span><span id="imebra::MutableDataSet::getWritingDataHandlerNumeric__TagIdCR.s.tagVR_t"></span><span class="target" id="classimebra_1_1_mutable_data_set_1a776e84166b478aaa2c195c7f32995974"></span><a class="reference internal" href="#_CPPv4N6imebra25WritingDataHandlerNumericE" title="imebra::WritingDataHandlerNumeric">WritingDataHandlerNumeric</a> <code class="sig-name descname">getWritingDataHandlerNumeric</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, size_t <em>bufferId</em>, <a class="reference internal" href="definition_classes.html#_CPPv4N6imebra7tagVR_tE" title="imebra::tagVR_t">tagVR_t</a> <em>tagVR</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N6imebra14MutableDataSet28getWritingDataHandlerNumericERK5TagId6size_t7tagVR_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Retrieve a <a class="reference internal" href="#classimebra_1_1_writing_data_handler_numeric"><span class="std std-ref">WritingDataHandlerNumeric</span></a> object connected to a specific tag’s buffer. </p>
<p>If the tag’s VR is not a numeric type then throws std::bad_cast.</p>
<p>If the specified <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a> does not exist then it creates a new tag with the VR specified in the tagVR parameter</p>
<p>The returned <a class="reference internal" href="#classimebra_1_1_writing_data_handler_numeric"><span class="std std-ref">WritingDataHandlerNumeric</span></a> is connected to a new buffer which is updated and stored into the tag when <a class="reference internal" href="#classimebra_1_1_writing_data_handler_numeric"><span class="std std-ref">WritingDataHandlerNumeric</span></a> is destroyed.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>a <a class="reference internal" href="#classimebra_1_1_writing_data_handler_numeric"><span class="std std-ref">WritingDataHandlerNumeric</span></a> object connected to a new <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a>’s buffer </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id containing the requested buffer </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bufferId</span></code>: the position where the new buffer has to be stored in the tag. The first buffer position is 0 </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">tagVR</span></code>: the tag’s VR </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N6imebra14MutableDataSet28getWritingDataHandlerNumericERK5TagId6size_t">
<span id="_CPPv3N6imebra14MutableDataSet28getWritingDataHandlerNumericERK5TagId6size_t"></span><span id="_CPPv2N6imebra14MutableDataSet28getWritingDataHandlerNumericERK5TagId6size_t"></span><span id="imebra::MutableDataSet::getWritingDataHandlerNumeric__TagIdCR.s"></span><span class="target" id="classimebra_1_1_mutable_data_set_1a2350dfb028a6cae762e0dc26278419a5"></span><a class="reference internal" href="#_CPPv4N6imebra25WritingDataHandlerNumericE" title="imebra::WritingDataHandlerNumeric">WritingDataHandlerNumeric</a> <code class="sig-name descname">getWritingDataHandlerNumeric</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, size_t <em>bufferId</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N6imebra14MutableDataSet28getWritingDataHandlerNumericERK5TagId6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Retrieve a <a class="reference internal" href="#classimebra_1_1_writing_data_handler_numeric"><span class="std std-ref">WritingDataHandlerNumeric</span></a> object connected to a specific tag’s buffer. </p>
<p>If the tag’s VR is not a numeric type then throws std::bad_cast.</p>
<p>If the specified <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a> does not exist then it creates a new tag with a default VR retrieved from the <a class="reference internal" href="dicom_dictionary_classes.html#classimebra_1_1_dicom_dictionary"><span class="std std-ref">DicomDictionary</span></a>.</p>
<p>The returned <a class="reference internal" href="#classimebra_1_1_writing_data_handler_numeric"><span class="std std-ref">WritingDataHandlerNumeric</span></a> is connected to a new buffer which is updated and stored into the tag when <a class="reference internal" href="#classimebra_1_1_writing_data_handler_numeric"><span class="std std-ref">WritingDataHandlerNumeric</span></a> is destroyed.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>a <a class="reference internal" href="#classimebra_1_1_writing_data_handler_numeric"><span class="std std-ref">WritingDataHandlerNumeric</span></a> object connected to a new <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a>’s buffer </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id containing the requested buffer </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bufferId</span></code>: the position where the new buffer has to be stored in the tag. The first buffer position is 0 </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N6imebra14MutableDataSet24getWritingDataHandlerRawERK5TagId6size_t7tagVR_t">
<span id="_CPPv3N6imebra14MutableDataSet24getWritingDataHandlerRawERK5TagId6size_t7tagVR_t"></span><span id="_CPPv2N6imebra14MutableDataSet24getWritingDataHandlerRawERK5TagId6size_t7tagVR_t"></span><span id="imebra::MutableDataSet::getWritingDataHandlerRaw__TagIdCR.s.tagVR_t"></span><span class="target" id="classimebra_1_1_mutable_data_set_1a3b0db52e169172f2ce110423d0b7cc75"></span><a class="reference internal" href="#_CPPv4N6imebra25WritingDataHandlerNumericE" title="imebra::WritingDataHandlerNumeric">WritingDataHandlerNumeric</a> <code class="sig-name descname">getWritingDataHandlerRaw</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, size_t <em>bufferId</em>, <a class="reference internal" href="definition_classes.html#_CPPv4N6imebra7tagVR_tE" title="imebra::tagVR_t">tagVR_t</a> <em>tagVR</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N6imebra14MutableDataSet24getWritingDataHandlerRawERK5TagId6size_t7tagVR_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Retrieve a <a class="reference internal" href="#classimebra_1_1_writing_data_handler_numeric"><span class="std std-ref">WritingDataHandlerNumeric</span></a> object connected to a specific tag’s buffer. The handler content is cast to bytes. </p>
<p>If the tag’s VR is not a numeric type then throws std::bad_cast.</p>
<p>If the specified <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a> does not exist then it creates a new tag with the VR specified in the tagVR parameter</p>
<p>The returned <a class="reference internal" href="#classimebra_1_1_writing_data_handler_numeric"><span class="std std-ref">WritingDataHandlerNumeric</span></a> is connected to a new buffer which is updated and stored into the tag when <a class="reference internal" href="#classimebra_1_1_writing_data_handler_numeric"><span class="std std-ref">WritingDataHandlerNumeric</span></a> is destroyed.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>a <a class="reference internal" href="#classimebra_1_1_writing_data_handler_numeric"><span class="std std-ref">WritingDataHandlerNumeric</span></a> object connected to a new <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a>’s buffer </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id containing the requested buffer </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bufferId</span></code>: the position where the new buffer has to be stored in the tag. The first buffer position is 0 </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">tagVR</span></code>: the tag’s VR </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N6imebra14MutableDataSet24getWritingDataHandlerRawERK5TagId6size_t">
<span id="_CPPv3N6imebra14MutableDataSet24getWritingDataHandlerRawERK5TagId6size_t"></span><span id="_CPPv2N6imebra14MutableDataSet24getWritingDataHandlerRawERK5TagId6size_t"></span><span id="imebra::MutableDataSet::getWritingDataHandlerRaw__TagIdCR.s"></span><span class="target" id="classimebra_1_1_mutable_data_set_1a5f0d896f2f957a222dcc63e3d05d1ef1"></span><a class="reference internal" href="#_CPPv4N6imebra25WritingDataHandlerNumericE" title="imebra::WritingDataHandlerNumeric">WritingDataHandlerNumeric</a> <code class="sig-name descname">getWritingDataHandlerRaw</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, size_t <em>bufferId</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N6imebra14MutableDataSet24getWritingDataHandlerRawERK5TagId6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Retrieve a <a class="reference internal" href="#classimebra_1_1_writing_data_handler_numeric"><span class="std std-ref">WritingDataHandlerNumeric</span></a> object connected to a specific tag’s buffer. The handler content is cast to bytes. </p>
<p>If the tag’s VR is not a numeric type then throws std::bad_cast.</p>
<p>If the specified <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a> does not exist then it creates a new tag with a default VR retrieved from the <a class="reference internal" href="dicom_dictionary_classes.html#classimebra_1_1_dicom_dictionary"><span class="std std-ref">DicomDictionary</span></a>.</p>
<p>The returned <a class="reference internal" href="#classimebra_1_1_writing_data_handler_numeric"><span class="std std-ref">WritingDataHandlerNumeric</span></a> is connected to a new buffer which is updated and stored into the tag when <a class="reference internal" href="#classimebra_1_1_writing_data_handler_numeric"><span class="std std-ref">WritingDataHandlerNumeric</span></a> is destroyed.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>a <a class="reference internal" href="#classimebra_1_1_writing_data_handler_numeric"><span class="std std-ref">WritingDataHandlerNumeric</span></a> object connected to a new <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a>’s buffer </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id containing the requested buffer </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bufferId</span></code>: the position where the new buffer has to be stored in the tag. The first buffer position is 0 </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N6imebra14MutableDataSet8setInt32ERK5TagIdNSt7int32_tE7tagVR_t">
<span id="_CPPv3N6imebra14MutableDataSet8setInt32ERK5TagIdNSt7int32_tE7tagVR_t"></span><span id="_CPPv2N6imebra14MutableDataSet8setInt32ERK5TagIdNSt7int32_tE7tagVR_t"></span><span id="imebra::MutableDataSet::setInt32__TagIdCR.std::int32_t.tagVR_t"></span><span class="target" id="classimebra_1_1_mutable_data_set_1a3d6da04ba9e3834baecbcb8ac844cd41"></span>void <code class="sig-name descname">setInt32</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, std::int32_t <em>newValue</em>, <a class="reference internal" href="definition_classes.html#_CPPv4N6imebra7tagVR_tE" title="imebra::tagVR_t">tagVR_t</a> <em>tagVR</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N6imebra14MutableDataSet8setInt32ERK5TagIdNSt7int32_tE7tagVR_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Write a new signed 32 bit integer value into the element 0 of the specified <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a>’s buffer 0. </p>
<p>If the specified <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a> or buffer don’t exist then a new tag is created using the specified data type (VR).</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">newValue</span></code>: the value to write into the tag </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">tagVR</span></code>: the tag’s type to use when a new tag is created. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N6imebra14MutableDataSet13setSignedLongERK5TagIdNSt7int32_tE7tagVR_t">
<span id="_CPPv3N6imebra14MutableDataSet13setSignedLongERK5TagIdNSt7int32_tE7tagVR_t"></span><span id="_CPPv2N6imebra14MutableDataSet13setSignedLongERK5TagIdNSt7int32_tE7tagVR_t"></span><span id="imebra::MutableDataSet::setSignedLong__TagIdCR.std::int32_t.tagVR_t"></span><span class="target" id="classimebra_1_1_mutable_data_set_1a740b48cc3e6710482f7030c8a4db2e55"></span>void <code class="sig-name descname">setSignedLong</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, std::int32_t <em>newValue</em>, <a class="reference internal" href="definition_classes.html#_CPPv4N6imebra7tagVR_tE" title="imebra::tagVR_t">tagVR_t</a> <em>tagVR</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N6imebra14MutableDataSet13setSignedLongERK5TagIdNSt7int32_tE7tagVR_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Deprecated. Use <a class="reference internal" href="#classimebra_1_1_mutable_data_set_1a3d6da04ba9e3834baecbcb8ac844cd41"><span class="std std-ref">setInt32()</span></a> instead. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N6imebra14MutableDataSet8setInt32ERK5TagIdNSt7int32_tE">
<span id="_CPPv3N6imebra14MutableDataSet8setInt32ERK5TagIdNSt7int32_tE"></span><span id="_CPPv2N6imebra14MutableDataSet8setInt32ERK5TagIdNSt7int32_tE"></span><span id="imebra::MutableDataSet::setInt32__TagIdCR.std::int32_t"></span><span class="target" id="classimebra_1_1_mutable_data_set_1a619148fdda0142753ddacf41771bc4db"></span>void <code class="sig-name descname">setInt32</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, std::int32_t <em>newValue</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N6imebra14MutableDataSet8setInt32ERK5TagIdNSt7int32_tE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Write a new signed 32 bit integer value into the element 0 of the specified <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a>’s buffer 0. </p>
<p>If the specified <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a> does not exist then it creates a new tag with a default VR retrieved from the <a class="reference internal" href="dicom_dictionary_classes.html#classimebra_1_1_dicom_dictionary"><span class="std std-ref">DicomDictionary</span></a>.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">newValue</span></code>: the value to write into the tag </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N6imebra14MutableDataSet13setSignedLongERK5TagIdNSt7int32_tE">
<span id="_CPPv3N6imebra14MutableDataSet13setSignedLongERK5TagIdNSt7int32_tE"></span><span id="_CPPv2N6imebra14MutableDataSet13setSignedLongERK5TagIdNSt7int32_tE"></span><span id="imebra::MutableDataSet::setSignedLong__TagIdCR.std::int32_t"></span><span class="target" id="classimebra_1_1_mutable_data_set_1ae8fa12eaee182936c16537b4f1d8f415"></span>void <code class="sig-name descname">setSignedLong</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, std::int32_t <em>newValue</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N6imebra14MutableDataSet13setSignedLongERK5TagIdNSt7int32_tE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Deprecated. Use <a class="reference internal" href="#classimebra_1_1_mutable_data_set_1a3d6da04ba9e3834baecbcb8ac844cd41"><span class="std std-ref">setInt32()</span></a> instead. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N6imebra14MutableDataSet9setUint32ERK5TagIdNSt8uint32_tE7tagVR_t">
<span id="_CPPv3N6imebra14MutableDataSet9setUint32ERK5TagIdNSt8uint32_tE7tagVR_t"></span><span id="_CPPv2N6imebra14MutableDataSet9setUint32ERK5TagIdNSt8uint32_tE7tagVR_t"></span><span id="imebra::MutableDataSet::setUint32__TagIdCR.std::uint32_t.tagVR_t"></span><span class="target" id="classimebra_1_1_mutable_data_set_1a87174a161042505d10e321c0ca25fbb2"></span>void <code class="sig-name descname">setUint32</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, std::uint32_t <em>newValue</em>, <a class="reference internal" href="definition_classes.html#_CPPv4N6imebra7tagVR_tE" title="imebra::tagVR_t">tagVR_t</a> <em>tagVR</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N6imebra14MutableDataSet9setUint32ERK5TagIdNSt8uint32_tE7tagVR_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Write a new unsigned 32 bit integer value into the element 0 of the specified <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a>’s buffer 0. </p>
<p>When setting a value for an AT tag (Attribute <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a>) then the tag’s group must always be in the higher 16 bits of the value.</p>
<p>If the specified <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a> doesn’t exist then a new tag is created using the specified data type (VR).</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">newValue</span></code>: the value to write into the tag </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">tagVR</span></code>: the tag’s type to use when a new tag is created. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N6imebra14MutableDataSet15setUnsignedLongERK5TagIdNSt8uint32_tE7tagVR_t">
<span id="_CPPv3N6imebra14MutableDataSet15setUnsignedLongERK5TagIdNSt8uint32_tE7tagVR_t"></span><span id="_CPPv2N6imebra14MutableDataSet15setUnsignedLongERK5TagIdNSt8uint32_tE7tagVR_t"></span><span id="imebra::MutableDataSet::setUnsignedLong__TagIdCR.std::uint32_t.tagVR_t"></span><span class="target" id="classimebra_1_1_mutable_data_set_1a10893aae2950eb361a941286728c25d0"></span>void <code class="sig-name descname">setUnsignedLong</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, std::uint32_t <em>newValue</em>, <a class="reference internal" href="definition_classes.html#_CPPv4N6imebra7tagVR_tE" title="imebra::tagVR_t">tagVR_t</a> <em>tagVR</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N6imebra14MutableDataSet15setUnsignedLongERK5TagIdNSt8uint32_tE7tagVR_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Deprecated. Use <a class="reference internal" href="#classimebra_1_1_mutable_data_set_1a87174a161042505d10e321c0ca25fbb2"><span class="std std-ref">setUint32()</span></a> instead. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N6imebra14MutableDataSet9setUint32ERK5TagIdNSt8uint32_tE">
<span id="_CPPv3N6imebra14MutableDataSet9setUint32ERK5TagIdNSt8uint32_tE"></span><span id="_CPPv2N6imebra14MutableDataSet9setUint32ERK5TagIdNSt8uint32_tE"></span><span id="imebra::MutableDataSet::setUint32__TagIdCR.std::uint32_t"></span><span class="target" id="classimebra_1_1_mutable_data_set_1a409c6fead04b5ad0f3e4c9dc336c6972"></span>void <code class="sig-name descname">setUint32</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, std::uint32_t <em>newValue</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N6imebra14MutableDataSet9setUint32ERK5TagIdNSt8uint32_tE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Write a new unsigned 32 bit integer value into the element 0 of the specified <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a>’s buffer 0. </p>
<p>If the specified <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a> does not exist then it creates a new tag with a default VR retrieved from the <a class="reference internal" href="dicom_dictionary_classes.html#classimebra_1_1_dicom_dictionary"><span class="std std-ref">DicomDictionary</span></a>.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">newValue</span></code>: the value to write into the tag </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N6imebra14MutableDataSet15setUnsignedLongERK5TagIdNSt8uint32_tE">
<span id="_CPPv3N6imebra14MutableDataSet15setUnsignedLongERK5TagIdNSt8uint32_tE"></span><span id="_CPPv2N6imebra14MutableDataSet15setUnsignedLongERK5TagIdNSt8uint32_tE"></span><span id="imebra::MutableDataSet::setUnsignedLong__TagIdCR.std::uint32_t"></span><span class="target" id="classimebra_1_1_mutable_data_set_1a01e8b3ca23ce2cd6ae2d3c8e2c870744"></span>void <code class="sig-name descname">setUnsignedLong</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, std::uint32_t <em>newValue</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N6imebra14MutableDataSet15setUnsignedLongERK5TagIdNSt8uint32_tE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Deprecated. Use <a class="reference internal" href="#classimebra_1_1_mutable_data_set_1a87174a161042505d10e321c0ca25fbb2"><span class="std std-ref">setUint32()</span></a> instead. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N6imebra14MutableDataSet8setInt16ERK5TagIdNSt7int16_tE7tagVR_t">
<span id="_CPPv3N6imebra14MutableDataSet8setInt16ERK5TagIdNSt7int16_tE7tagVR_t"></span><span id="_CPPv2N6imebra14MutableDataSet8setInt16ERK5TagIdNSt7int16_tE7tagVR_t"></span><span id="imebra::MutableDataSet::setInt16__TagIdCR.std::int16_t.tagVR_t"></span><span class="target" id="classimebra_1_1_mutable_data_set_1a86c80370ee588ccf6dcc7c68ad9ef0af"></span>void <code class="sig-name descname">setInt16</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, std::int16_t <em>newValue</em>, <a class="reference internal" href="definition_classes.html#_CPPv4N6imebra7tagVR_tE" title="imebra::tagVR_t">tagVR_t</a> <em>tagVR</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N6imebra14MutableDataSet8setInt16ERK5TagIdNSt7int16_tE7tagVR_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Write a new signed 16 bit integer value into the element 0 of the specified <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a>’s buffer 0. </p>
<p>If the specified <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a> or buffer don’t exist then a new tag is created using the specified data type (VR).</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">newValue</span></code>: the value to write into the tag </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">tagVR</span></code>: the tag’s type to use when a new tag is created. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N6imebra14MutableDataSet8setInt16ERK5TagIdNSt7int16_tE">
<span id="_CPPv3N6imebra14MutableDataSet8setInt16ERK5TagIdNSt7int16_tE"></span><span id="_CPPv2N6imebra14MutableDataSet8setInt16ERK5TagIdNSt7int16_tE"></span><span id="imebra::MutableDataSet::setInt16__TagIdCR.std::int16_t"></span><span class="target" id="classimebra_1_1_mutable_data_set_1a2dc2aead37d483fe496b1b3d5eaef9dd"></span>void <code class="sig-name descname">setInt16</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, std::int16_t <em>newValue</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N6imebra14MutableDataSet8setInt16ERK5TagIdNSt7int16_tE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Write a new signed 16 bit integer value into the element 0 of the specified <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a>’s buffer 0. </p>
<p>If the specified <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a> does not exist then it creates a new tag with a default VR retrieved from the <a class="reference internal" href="dicom_dictionary_classes.html#classimebra_1_1_dicom_dictionary"><span class="std std-ref">DicomDictionary</span></a>.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">newValue</span></code>: the value to write into the tag </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N6imebra14MutableDataSet9setUint16ERK5TagIdNSt8uint16_tE7tagVR_t">
<span id="_CPPv3N6imebra14MutableDataSet9setUint16ERK5TagIdNSt8uint16_tE7tagVR_t"></span><span id="_CPPv2N6imebra14MutableDataSet9setUint16ERK5TagIdNSt8uint16_tE7tagVR_t"></span><span id="imebra::MutableDataSet::setUint16__TagIdCR.std::uint16_t.tagVR_t"></span><span class="target" id="classimebra_1_1_mutable_data_set_1a04f3947128c42ffb2ef8902e7c1227e4"></span>void <code class="sig-name descname">setUint16</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, std::uint16_t <em>newValue</em>, <a class="reference internal" href="definition_classes.html#_CPPv4N6imebra7tagVR_tE" title="imebra::tagVR_t">tagVR_t</a> <em>tagVR</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N6imebra14MutableDataSet9setUint16ERK5TagIdNSt8uint16_tE7tagVR_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Write a new unsigned 16 bit integer value into the element 0 of the specified <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a>’s buffer 0. </p>
<p>If the specified <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a> doesn’t exist then a new tag is created using the specified data type (VR).</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">newValue</span></code>: the value to write into the tag </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">tagVR</span></code>: the tag’s type to use when a new tag is created. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N6imebra14MutableDataSet9setUint16ERK5TagIdNSt8uint16_tE">
<span id="_CPPv3N6imebra14MutableDataSet9setUint16ERK5TagIdNSt8uint16_tE"></span><span id="_CPPv2N6imebra14MutableDataSet9setUint16ERK5TagIdNSt8uint16_tE"></span><span id="imebra::MutableDataSet::setUint16__TagIdCR.std::uint16_t"></span><span class="target" id="classimebra_1_1_mutable_data_set_1accba3a3ef0a958ea4f7fc6c1a32ac98c"></span>void <code class="sig-name descname">setUint16</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, std::uint16_t <em>newValue</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N6imebra14MutableDataSet9setUint16ERK5TagIdNSt8uint16_tE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Write a new unsigned 16 bit integer value into the element 0 of the specified <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a>’s buffer 0. </p>
<p>If the specified <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a> does not exist then it creates a new tag with a default VR retrieved from the <a class="reference internal" href="dicom_dictionary_classes.html#classimebra_1_1_dicom_dictionary"><span class="std std-ref">DicomDictionary</span></a>.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">newValue</span></code>: the value to write into the tag </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N6imebra14MutableDataSet7setInt8ERK5TagIdNSt6int8_tE7tagVR_t">
<span id="_CPPv3N6imebra14MutableDataSet7setInt8ERK5TagIdNSt6int8_tE7tagVR_t"></span><span id="_CPPv2N6imebra14MutableDataSet7setInt8ERK5TagIdNSt6int8_tE7tagVR_t"></span><span id="imebra::MutableDataSet::setInt8__TagIdCR.std::int8_t.tagVR_t"></span><span class="target" id="classimebra_1_1_mutable_data_set_1a8370c98604a513c09fca54752bed6f96"></span>void <code class="sig-name descname">setInt8</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, std::int8_t <em>newValue</em>, <a class="reference internal" href="definition_classes.html#_CPPv4N6imebra7tagVR_tE" title="imebra::tagVR_t">tagVR_t</a> <em>tagVR</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N6imebra14MutableDataSet7setInt8ERK5TagIdNSt6int8_tE7tagVR_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Write a new signed 8 bit integer value into the element 0 of the specified <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a>’s buffer 0. </p>
<p>If the specified <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a> or buffer don’t exist then a new tag is created using the specified data type (VR).</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">newValue</span></code>: the value to write into the tag </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">tagVR</span></code>: the tag’s type to use when a new tag is created. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N6imebra14MutableDataSet7setInt8ERK5TagIdNSt6int8_tE">
<span id="_CPPv3N6imebra14MutableDataSet7setInt8ERK5TagIdNSt6int8_tE"></span><span id="_CPPv2N6imebra14MutableDataSet7setInt8ERK5TagIdNSt6int8_tE"></span><span id="imebra::MutableDataSet::setInt8__TagIdCR.std::int8_t"></span><span class="target" id="classimebra_1_1_mutable_data_set_1a3a12570c17a12f3297ee5d4534cbf853"></span>void <code class="sig-name descname">setInt8</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, std::int8_t <em>newValue</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N6imebra14MutableDataSet7setInt8ERK5TagIdNSt6int8_tE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Write a new signed 8 bit integer value into the element 0 of the specified <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a>’s buffer 0. </p>
<p>If the specified <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a> does not exist then it creates a new tag with a default VR retrieved from the <a class="reference internal" href="dicom_dictionary_classes.html#classimebra_1_1_dicom_dictionary"><span class="std std-ref">DicomDictionary</span></a>.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">newValue</span></code>: the value to write into the tag </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N6imebra14MutableDataSet8setUint8ERK5TagIdNSt7uint8_tE7tagVR_t">
<span id="_CPPv3N6imebra14MutableDataSet8setUint8ERK5TagIdNSt7uint8_tE7tagVR_t"></span><span id="_CPPv2N6imebra14MutableDataSet8setUint8ERK5TagIdNSt7uint8_tE7tagVR_t"></span><span id="imebra::MutableDataSet::setUint8__TagIdCR.std::uint8_t.tagVR_t"></span><span class="target" id="classimebra_1_1_mutable_data_set_1abb66ba0b404357cfe351f411f7c2f866"></span>void <code class="sig-name descname">setUint8</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, std::uint8_t <em>newValue</em>, <a class="reference internal" href="definition_classes.html#_CPPv4N6imebra7tagVR_tE" title="imebra::tagVR_t">tagVR_t</a> <em>tagVR</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N6imebra14MutableDataSet8setUint8ERK5TagIdNSt7uint8_tE7tagVR_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Write a new unsigned 8 bit integer value into the element 0 of the specified <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a>’s buffer 0. </p>
<p>If the specified <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a> doesn’t exist then a new tag is created using the specified data type (VR).</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">newValue</span></code>: the value to write into the tag </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">tagVR</span></code>: the tag’s type to use when a new tag is created. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N6imebra14MutableDataSet8setUint8ERK5TagIdNSt7uint8_tE">
<span id="_CPPv3N6imebra14MutableDataSet8setUint8ERK5TagIdNSt7uint8_tE"></span><span id="_CPPv2N6imebra14MutableDataSet8setUint8ERK5TagIdNSt7uint8_tE"></span><span id="imebra::MutableDataSet::setUint8__TagIdCR.std::uint8_t"></span><span class="target" id="classimebra_1_1_mutable_data_set_1a2c4182538be8286f0f61649b4bea2245"></span>void <code class="sig-name descname">setUint8</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, std::uint8_t <em>newValue</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N6imebra14MutableDataSet8setUint8ERK5TagIdNSt7uint8_tE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Write a new unsigned 8 bit integer value into the element 0 of the specified <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a>’s buffer 0. </p>
<p>If the specified <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a> does not exist then it creates a new tag with a default VR retrieved from the <a class="reference internal" href="dicom_dictionary_classes.html#classimebra_1_1_dicom_dictionary"><span class="std std-ref">DicomDictionary</span></a>.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">newValue</span></code>: the value to write into the tag </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N6imebra14MutableDataSet9setDoubleERK5TagIdd7tagVR_t">
<span id="_CPPv3N6imebra14MutableDataSet9setDoubleERK5TagIdd7tagVR_t"></span><span id="_CPPv2N6imebra14MutableDataSet9setDoubleERK5TagIdd7tagVR_t"></span><span id="imebra::MutableDataSet::setDouble__TagIdCR.double.tagVR_t"></span><span class="target" id="classimebra_1_1_mutable_data_set_1a7a58136cdadd5e9687c627fcb75df105"></span>void <code class="sig-name descname">setDouble</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, double <em>newValue</em>, <a class="reference internal" href="definition_classes.html#_CPPv4N6imebra7tagVR_tE" title="imebra::tagVR_t">tagVR_t</a> <em>tagVR</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N6imebra14MutableDataSet9setDoubleERK5TagIdd7tagVR_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Write a 64 bit floating point value into the element 0 of the specified <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a>’s buffer 0. </p>
<p>If the specified <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a> or buffer don’t exist then a new tag is created using the specified data type (VR).</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">newValue</span></code>: the value to write into the tag </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">tagVR</span></code>: the tag’s type to use when a new tag is created. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N6imebra14MutableDataSet9setDoubleERK5TagIdd">
<span id="_CPPv3N6imebra14MutableDataSet9setDoubleERK5TagIdd"></span><span id="_CPPv2N6imebra14MutableDataSet9setDoubleERK5TagIdd"></span><span id="imebra::MutableDataSet::setDouble__TagIdCR.double"></span><span class="target" id="classimebra_1_1_mutable_data_set_1ae335e8a1da21ac9008427d17606046e1"></span>void <code class="sig-name descname">setDouble</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, double <em>newValue</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N6imebra14MutableDataSet9setDoubleERK5TagIdd" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Write a 64 bit floating point value into the element 0 of the specified <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a>’s buffer 0. </p>
<p>If the specified <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a> does not exist then it creates a new tag with a default VR retrieved from the <a class="reference internal" href="dicom_dictionary_classes.html#classimebra_1_1_dicom_dictionary"><span class="std std-ref">DicomDictionary</span></a>.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">newValue</span></code>: the value to write into the tag </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N6imebra14MutableDataSet8setFloatERK5TagIdf7tagVR_t">
<span id="_CPPv3N6imebra14MutableDataSet8setFloatERK5TagIdf7tagVR_t"></span><span id="_CPPv2N6imebra14MutableDataSet8setFloatERK5TagIdf7tagVR_t"></span><span id="imebra::MutableDataSet::setFloat__TagIdCR.float.tagVR_t"></span><span class="target" id="classimebra_1_1_mutable_data_set_1a5b9ac24c1e554f7e53ede2d4dbdb7615"></span>void <code class="sig-name descname">setFloat</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, float <em>newValue</em>, <a class="reference internal" href="definition_classes.html#_CPPv4N6imebra7tagVR_tE" title="imebra::tagVR_t">tagVR_t</a> <em>tagVR</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N6imebra14MutableDataSet8setFloatERK5TagIdf7tagVR_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Write a 32 bit floating point value into the element 0 of the specified <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a>’s buffer 0. </p>
<p>If the specified <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a> or buffer don’t exist then a new tag is created using the specified data type (VR).</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">newValue</span></code>: the value to write into the tag </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">tagVR</span></code>: the tag’s type to use when a new tag is created. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N6imebra14MutableDataSet8setFloatERK5TagIdf">
<span id="_CPPv3N6imebra14MutableDataSet8setFloatERK5TagIdf"></span><span id="_CPPv2N6imebra14MutableDataSet8setFloatERK5TagIdf"></span><span id="imebra::MutableDataSet::setFloat__TagIdCR.float"></span><span class="target" id="classimebra_1_1_mutable_data_set_1aa5797bd746fecd011bd2c16252e5441a"></span>void <code class="sig-name descname">setFloat</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, float <em>newValue</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N6imebra14MutableDataSet8setFloatERK5TagIdf" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Write a 32 bit floating point value into the element 0 of the specified <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a>’s buffer 0. </p>
<p>If the specified <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a> does not exist then it creates a new tag with a default VR retrieved from the <a class="reference internal" href="dicom_dictionary_classes.html#classimebra_1_1_dicom_dictionary"><span class="std std-ref">DicomDictionary</span></a>.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">newValue</span></code>: the value to write into the tag </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N6imebra14MutableDataSet9setStringERK5TagIdRKNSt6stringE7tagVR_t">
<span id="_CPPv3N6imebra14MutableDataSet9setStringERK5TagIdRKNSt6stringE7tagVR_t"></span><span id="_CPPv2N6imebra14MutableDataSet9setStringERK5TagIdRKNSt6stringE7tagVR_t"></span><span id="imebra::MutableDataSet::setString__TagIdCR.ssCR.tagVR_t"></span><span class="target" id="classimebra_1_1_mutable_data_set_1a8bf2111e96efb240bdb45335955c0c84"></span>void <code class="sig-name descname">setString</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, <em class="property">const</em> std::string &amp;<em>newString</em>, <a class="reference internal" href="definition_classes.html#_CPPv4N6imebra7tagVR_tE" title="imebra::tagVR_t">tagVR_t</a> <em>tagVR</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N6imebra14MutableDataSet9setStringERK5TagIdRKNSt6stringE7tagVR_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Write a UTF8 string value into the element 0 of the specified <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a>’s buffer 0. </p>
<p>If the specified <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a> does not exist then it creates a new tag with a specific VR.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">newString</span></code>: the string to write into the tag </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">tagVR</span></code>: the tag’s type to use when a new tag is created. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N6imebra14MutableDataSet9setStringERK5TagIdRKNSt6stringE">
<span id="_CPPv3N6imebra14MutableDataSet9setStringERK5TagIdRKNSt6stringE"></span><span id="_CPPv2N6imebra14MutableDataSet9setStringERK5TagIdRKNSt6stringE"></span><span id="imebra::MutableDataSet::setString__TagIdCR.ssCR"></span><span class="target" id="classimebra_1_1_mutable_data_set_1a290b4ea994dba9919e5f07eb1b2fd4b5"></span>void <code class="sig-name descname">setString</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, <em class="property">const</em> std::string &amp;<em>newString</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N6imebra14MutableDataSet9setStringERK5TagIdRKNSt6stringE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Write a UTF8 string value into the element 0 of the specified <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a>’s buffer 0. </p>
<p>If the specified <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a> does not exist then it creates a new tag with a default VR retrieved from the <a class="reference internal" href="dicom_dictionary_classes.html#classimebra_1_1_dicom_dictionary"><span class="std std-ref">DicomDictionary</span></a>.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">newString</span></code>: the string to write into the tag </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N6imebra14MutableDataSet16setUnicodeStringERK5TagIdRKNSt7wstringE7tagVR_t">
<span id="_CPPv3N6imebra14MutableDataSet16setUnicodeStringERK5TagIdRKNSt7wstringE7tagVR_t"></span><span id="_CPPv2N6imebra14MutableDataSet16setUnicodeStringERK5TagIdRKNSt7wstringE7tagVR_t"></span><span id="imebra::MutableDataSet::setUnicodeString__TagIdCR.std::wstringCR.tagVR_t"></span><span class="target" id="classimebra_1_1_mutable_data_set_1a7c09812ae31ac51a6c5cc8339a036b74"></span>void <code class="sig-name descname">setUnicodeString</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, <em class="property">const</em> std::wstring &amp;<em>newString</em>, <a class="reference internal" href="definition_classes.html#_CPPv4N6imebra7tagVR_tE" title="imebra::tagVR_t">tagVR_t</a> <em>tagVR</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N6imebra14MutableDataSet16setUnicodeStringERK5TagIdRKNSt7wstringE7tagVR_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Write an unicode string value into the element 0 of the specified <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a>’s buffer 0. </p>
<p>If the specified <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a> doesn’t exist then a new tag is created using the specified VR.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">newString</span></code>: the string to write into the tag </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">tagVR</span></code>: the tag’s type to use when a new tag is created. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N6imebra14MutableDataSet16setUnicodeStringERK5TagIdRKNSt7wstringE">
<span id="_CPPv3N6imebra14MutableDataSet16setUnicodeStringERK5TagIdRKNSt7wstringE"></span><span id="_CPPv2N6imebra14MutableDataSet16setUnicodeStringERK5TagIdRKNSt7wstringE"></span><span id="imebra::MutableDataSet::setUnicodeString__TagIdCR.std::wstringCR"></span><span class="target" id="classimebra_1_1_mutable_data_set_1a9751828b6c8913d58e027f580c0941a5"></span>void <code class="sig-name descname">setUnicodeString</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, <em class="property">const</em> std::wstring &amp;<em>newString</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N6imebra14MutableDataSet16setUnicodeStringERK5TagIdRKNSt7wstringE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Write an unicode string value into the element 0 of the specified <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a>’s buffer 0. </p>
<p>If the specified <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a> does not exist then it creates a new tag with a default VR retrieved from the <a class="reference internal" href="dicom_dictionary_classes.html#classimebra_1_1_dicom_dictionary"><span class="std std-ref">DicomDictionary</span></a>.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">newString</span></code>: the string to write into the tag </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N6imebra14MutableDataSet6setAgeERK5TagIdRK3Age">
<span id="_CPPv3N6imebra14MutableDataSet6setAgeERK5TagIdRK3Age"></span><span id="_CPPv2N6imebra14MutableDataSet6setAgeERK5TagIdRK3Age"></span><span id="imebra::MutableDataSet::setAge__TagIdCR.AgeCR"></span><span class="target" id="classimebra_1_1_mutable_data_set_1aab6de4ac863b7f2650e9ae19e8b03fb2"></span>void <code class="sig-name descname">setAge</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, <em class="property">const</em> <a class="reference internal" href="#_CPPv4N6imebra3AgeE" title="imebra::Age">Age</a> &amp;<em>age</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N6imebra14MutableDataSet6setAgeERK5TagIdRK3Age" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Write an <a class="reference internal" href="#classimebra_1_1_age"><span class="std std-ref">Age</span></a> string into the element 0 of the specified <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a>’s buffer 0. </p>
<p>If the specified <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a> doesn’t exist then a new tag and is created using the VR tagVR_t::AS.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">age</span></code>: the <a class="reference internal" href="#classimebra_1_1_age"><span class="std std-ref">Age</span></a> to write into the tag </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N6imebra14MutableDataSet7setDateERK5TagIdRK4Date7tagVR_t">
<span id="_CPPv3N6imebra14MutableDataSet7setDateERK5TagIdRK4Date7tagVR_t"></span><span id="_CPPv2N6imebra14MutableDataSet7setDateERK5TagIdRK4Date7tagVR_t"></span><span id="imebra::MutableDataSet::setDate__TagIdCR.DateCR.tagVR_t"></span><span class="target" id="classimebra_1_1_mutable_data_set_1afdd9bc0e4d3ab6da48d112ea7a64d71b"></span>void <code class="sig-name descname">setDate</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, <em class="property">const</em> <a class="reference internal" href="#_CPPv4N6imebra4DateE" title="imebra::Date">Date</a> &amp;<em>date</em>, <a class="reference internal" href="definition_classes.html#_CPPv4N6imebra7tagVR_tE" title="imebra::tagVR_t">tagVR_t</a> <em>tagVR</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N6imebra14MutableDataSet7setDateERK5TagIdRK4Date7tagVR_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Write a <a class="reference internal" href="#classimebra_1_1_date"><span class="std std-ref">Date</span></a> string into the element 0 of the specified <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a>’s buffer 0. </p>
<p>If the specified <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a> or buffer don’t exist then a new tag and/or buffer are created using the specified data type (VR).</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">date</span></code>: the <a class="reference internal" href="#classimebra_1_1_date"><span class="std std-ref">Date</span></a> to write into the tag </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">tagVR</span></code>: the tag’s type to use when a new tag is created. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N6imebra14MutableDataSet7setDateERK5TagIdRK4Date">
<span id="_CPPv3N6imebra14MutableDataSet7setDateERK5TagIdRK4Date"></span><span id="_CPPv2N6imebra14MutableDataSet7setDateERK5TagIdRK4Date"></span><span id="imebra::MutableDataSet::setDate__TagIdCR.DateCR"></span><span class="target" id="classimebra_1_1_mutable_data_set_1acf8cae134364b8fc6e781522cfd50bc5"></span>void <code class="sig-name descname">setDate</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, <em class="property">const</em> <a class="reference internal" href="#_CPPv4N6imebra4DateE" title="imebra::Date">Date</a> &amp;<em>date</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N6imebra14MutableDataSet7setDateERK5TagIdRK4Date" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Write a <a class="reference internal" href="#classimebra_1_1_date"><span class="std std-ref">Date</span></a> string into the element 0 of the specified <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a>’s buffer 0. </p>
<p>If the specified <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a> does not exist then it creates a new tag with a default VR retrieved from the <a class="reference internal" href="dicom_dictionary_classes.html#classimebra_1_1_dicom_dictionary"><span class="std std-ref">DicomDictionary</span></a>.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">date</span></code>: the <a class="reference internal" href="#classimebra_1_1_date"><span class="std std-ref">Date</span></a> to write into the tag </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N6imebra14MutableDataSet14setPatientNameERK5TagIdRK11PatientName">
<span id="_CPPv3N6imebra14MutableDataSet14setPatientNameERK5TagIdRK11PatientName"></span><span id="_CPPv2N6imebra14MutableDataSet14setPatientNameERK5TagIdRK11PatientName"></span><span id="imebra::MutableDataSet::setPatientName__TagIdCR.PatientNameCR"></span><span class="target" id="classimebra_1_1_mutable_data_set_1ace02db134bdfcc8c20e1f9e0529ca546"></span>void <code class="sig-name descname">setPatientName</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, <em class="property">const</em> <a class="reference internal" href="#_CPPv4N6imebra11PatientNameE" title="imebra::PatientName">PatientName</a> &amp;<em>patientName</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N6imebra14MutableDataSet14setPatientNameERK5TagIdRK11PatientName" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Write a Patient Name into the element 0 of the specified <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a>’s buffer 0. </p>
<p>If the specified <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a> does not exist then it creates a new tag with a VR PN.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">date</span></code>: the Patient Name to write into the tag </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N6imebra14MutableDataSet21setUnicodePatientNameERK5TagIdRK18UnicodePatientName">
<span id="_CPPv3N6imebra14MutableDataSet21setUnicodePatientNameERK5TagIdRK18UnicodePatientName"></span><span id="_CPPv2N6imebra14MutableDataSet21setUnicodePatientNameERK5TagIdRK18UnicodePatientName"></span><span id="imebra::MutableDataSet::setUnicodePatientName__TagIdCR.UnicodePatientNameCR"></span><span class="target" id="classimebra_1_1_mutable_data_set_1a04363ec994e3114b7fdcb83e72afe877"></span>void <code class="sig-name descname">setUnicodePatientName</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, <em class="property">const</em> <a class="reference internal" href="#_CPPv4N6imebra18UnicodePatientNameE" title="imebra::UnicodePatientName">UnicodePatientName</a> &amp;<em>patientName</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N6imebra14MutableDataSet21setUnicodePatientNameERK5TagIdRK18UnicodePatientName" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Write a Unicode Patient Name into the element 0 of the specified <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a>’s buffer 0. </p>
<p>If the specified <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a> does not exist then it creates a new tag with a VR PN.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">date</span></code>: the Unicode Patient Name to write into the tag </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</div>
<div class="section" id="id4">
<h4>Objective-C/Swift<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h4>
<dl class="class">
<dt id="_CPPv420ImebraMutableDataSet">
<span id="_CPPv320ImebraMutableDataSet"></span><span id="_CPPv220ImebraMutableDataSet"></span><span id="ImebraMutableDataSet"></span><span class="target" id="interface_imebra_mutable_data_set"></span><em class="property">class </em><code class="sig-name descname">ImebraMutableDataSet</code> : <em class="property">public</em> <a class="reference internal" href="#_CPPv413ImebraDataSet" title="ImebraDataSet">ImebraDataSet</a><a class="headerlink" href="#_CPPv420ImebraMutableDataSet" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This class represents a mutableDICOM dataset. </p>
<p>The information it contains is organized into groups and each group may contain several tags.</p>
<p>You can create an empty <a class="reference internal" href="#interface_imebra_mutable_data_set"><span class="std std-ref">ImebraMutableDataSet</span></a> that can be filled with data and images and then saved to a DICOM file via ImebraCodecFactory::save().</p>
<p>When creating an empty <a class="reference internal" href="#interface_imebra_mutable_data_set"><span class="std std-ref">ImebraMutableDataSet</span></a> you should specify the proper transfer syntax in the init method.</p>
<p>To set the <a class="reference internal" href="#interface_imebra_mutable_data_set"><span class="std std-ref">ImebraMutableDataSet</span></a>’s content, use one of the following methods:<ul class="simple">
<li><p>setImage()</p></li>
<li><p>appendSequenceItem()</p></li>
<li><p>setInt32()</p></li>
<li><p>setInt16()</p></li>
<li><p>setInt8()</p></li>
<li><p>setUint32()</p></li>
<li><p>setUint16()</p></li>
<li><p>setUint8()</p></li>
<li><p>setDouble()</p></li>
<li><p>setFloat()</p></li>
<li><p>setString()</p></li>
<li><p>setUnicodeString()</p></li>
<li><p>setAge()</p></li>
<li><p>setDate()</p></li>
<li><p>setPatientName()</p></li>
</ul>
</p>
<p>The previous methods allow to write just the first item in the tag’s content and before writing wipe out the old tag’s content (all the items). If you have to write more than one item in a tag, retrieve a <a class="reference internal" href="#interface_imebra_writing_data_handler"><span class="std std-ref">ImebraWritingDataHandler</span></a> with getWritingDataHandler() and then modify all the tag’s items using the <a class="reference internal" href="#interface_imebra_writing_data_handler"><span class="std std-ref">ImebraWritingDataHandler</span></a>. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv4N20ImebraMutableDataSet4initEv">
<span id="_CPPv3N20ImebraMutableDataSet4initEv"></span><span id="_CPPv2N20ImebraMutableDataSet4initEv"></span><span id="ImebraMutableDataSet::init"></span><span class="target" id="interface_imebra_mutable_data_set_1a2ebe6dc00e383f68f4e9355a46de5cb8"></span>id <code class="sig-name descname">init</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N20ImebraMutableDataSet4initEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Construct an empty DICOM dataset with unspecified transfer syntax (e.g. to be used in a sequence) charset “ISO 2022 IR 6”. </p>
<p>Use this method when creating a DataSet that will be embedded in a sequence item. </p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_mutable_data_set_1a16c7846b60df1d72ceba82dd61a3be70"></span><code class="sig-name descname">id ImebraMutableDataSet::initWithTransferSyntax:(NSString * transferSyntax)</code></dt>
<dd><p>Construct an empty DICOM dataset with charset “ISO 2022 IR 6” and the desidered transfer syntax. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">transferSyntax</span></code>: the dataSet’s transfer syntax. The following transfer syntaxes are supported:<ul>
<li><p>”1.2.840.10008.1.2” (Implicit VR little endian)</p></li>
<li><p>”1.2.840.10008.1.2.1” (Explicit VR little endian)</p></li>
<li><p>”1.2.840.10008.1.2.2” (Explicit VR big endian)</p></li>
<li><p>”1.2.840.10008.1.2.5” (RLE compression)</p></li>
<li><p>”1.2.840.10008.1.2.4.50” (Jpeg baseline 8 bit lossy)</p></li>
<li><p>”1.2.840.10008.1.2.4.51” (Jpeg extended 12 bit lossy)</p></li>
<li><p>”1.2.840.10008.1.2.4.57” (Jpeg lossless NH)</p></li>
<li><p>”1.2.840.10008.1.2.4.70” (Jpeg lossless NH first order prediction) </p></li>
</ul>
</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_mutable_data_set_1a74eaf4d98f561533455160498ba6cbee"></span><code class="sig-name descname">id ImebraMutableDataSet::initWithTransferSyntax:charsets:(NSString * transferSyntax, NSArray * pCharsets)</code></dt>
<dd><p>Construct an empty DICOM dataset and specifies the default charsets. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">transferSyntax</span></code>: the dataSet’s transfer syntax. The following transfer syntaxes are supported:<ul>
<li><p>”1.2.840.10008.1.2” (Implicit VR little endian)</p></li>
<li><p>”1.2.840.10008.1.2.1” (Explicit VR little endian)</p></li>
<li><p>”1.2.840.10008.1.2.2” (Explicit VR big endian)</p></li>
<li><p>”1.2.840.10008.1.2.5” (RLE compression)</p></li>
<li><p>”1.2.840.10008.1.2.4.50” (Jpeg baseline 8 bit lossy)</p></li>
<li><p>”1.2.840.10008.1.2.4.51” (Jpeg extended 12 bit lossy)</p></li>
<li><p>”1.2.840.10008.1.2.4.57” (Jpeg lossless NH)</p></li>
<li><p>”1.2.840.10008.1.2.4.70” (Jpeg lossless NH first order prediction)</p></li>
</ul>
</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pCharsets</span></code>: a NSArray of NSString specifying the charsets supported by the DataSet </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_mutable_data_set_1ae5841a045f21bdf5cdfbbd6fe2dace96"></span><code class="sig-name descname">ImebraMutableTag* ImebraMutableDataSet::getTagCreate:tagVR:error:(ImebraTagId  * tagId, ImebraTagType tagVR, NSError ** pError)</code></dt>
<dd><p>Retrieve the <a class="reference internal" href="#interface_imebra_tag"><span class="std std-ref">ImebraTag</span></a> with the specified ID or create it if it doesn’t exist. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the Tag with the specified ID </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the ID of the tag to retrieve </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">tagVR</span></code>: the VR to use for the new tag if one doesn’t exist already </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pError</span></code>: set if an error occurs </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_mutable_data_set_1a66bd2d50548a8082ea3cacecf6aad3d5"></span><code class="sig-name descname">ImebraMutableTag* ImebraMutableDataSet::getTagCreate:error:(ImebraTagId  * tagId, NSError ** pError)</code></dt>
<dd><p>Retrieve the <a class="reference internal" href="#interface_imebra_tag"><span class="std std-ref">ImebraTag</span></a> with the specified ID or create it if it doesn’t exist. Set the proper VR according to the tag ID. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the Tag with the specified ID </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the ID of the tag to retrieve </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pError</span></code>: set if an error occurs </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_mutable_data_set_1a90f7c9912e33c631f441e00cd344d1af"></span><code class="sig-name descname">void ImebraMutableDataSet::setImage:image:quality:error:(unsigned int frameNumber, ImebraImage  * image, ImebraImageQuality quality, (swift_error(nonnull_error)) __attribute__)</code></dt>
<dd><p>Insert an image into the dataset. </p>
<p>In multi-frame datasets the images must be inserted in order: first insert the frame 0, then the frame 1, then the frame 2 and so on.</p>
<p>All the inserted images must have the same transfer syntax and the same properties (size, color space, high bit, bits allocated).</p>
<p>If the images are inserted in the wrong order then the ImebraDataSetWrongFrameError is set in pError.</p>
<p>If the image being inserted has different properties than the ones of the images already in the dataset then the exception ImebraDataSetDifferentFormatError is set in pError.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">frameNumber</span></code>: the frame number (the first frame is 0) </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">image</span></code>: the image </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">quality</span></code>: the quality to use for lossy compression. Ignored if lossless compression is used </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pError</span></code>: a pointer to a NSError pointer which is set when an error occurs </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_mutable_data_set_1ae9caee28257b0bfbd18734b348718a72"></span><code class="sig-name descname">void ImebraMutableDataSet::setOverlay:overlay:error:(unsigned int overlayNumber, ImebraOverlay  * overlay, (swift_error(nonnull_error)) __attribute__)</code></dt>
<dd><p>Insert an overlay into the dataset. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">overlayNumber</span></code>: the overlay number (0…127) </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">overlay</span></code>: the overlay to insert into the dataset </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pError</span></code>: a pointer to a NSError pointer which is set when an error occurs </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_mutable_data_set_1a4662f9cb6ebcf33da42cf48c6a570853"></span><code class="sig-name descname">ImebraStreamWriter* ImebraMutableDataSet::getStreamWriter:bufferId:error:(ImebraTagId  * pTagId, unsigned int bufferId, NSError ** pError)</code></dt>
<dd><p>Get a StreamWriter connected to a buffer’s data. </p>
<p>If the specified tag does not exist then it creates a new tag with the VR specified in DICOM dictionary</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the StreamWriter connected to the buffer’s data. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pTagId</span></code>: the tag’s id for which the StreamWriter is required </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bufferId</span></code>: the id of the buffer for which the StreamWriter is required. This parameter is usually 0 </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pError</span></code>: set to a NSError derived class in case of error </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_mutable_data_set_1a70c40ea5e5af8ec7032972dc69bd459a"></span><code class="sig-name descname">ImebraStreamWriter* ImebraMutableDataSet::getStreamWriter:bufferId:tagVR:error:(ImebraTagId  * pTagId, unsigned int bufferId, ImebraTagType tagVR, NSError ** pError)</code></dt>
<dd><p>Get a StreamWriter connected to a buffer’s data. </p>
<p>If the specified tag does not exist then it creates a new tag with the VR specified in the tagVR parameter</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the StreamWriter connected to the buffer’s data. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pTagId</span></code>: the tag’s id for which the StreamWriter is required </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bufferId</span></code>: the id of the buffer for which the StreamWriter is required. This parameter is usually 0 </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pError</span></code>: set to a NSError derived class in case of error </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_mutable_data_set_1abd0283d301f602d0aff70aad8d054083"></span><code class="sig-name descname">ImebraMutableDataSet* ImebraMutableDataSet::appendSequenceItem:error:(ImebraTagId  * pTagId, NSError ** pError)</code></dt>
<dd><p>Append a sequence item. </p>
<p>If the specified tag does not exist then creates a new one with VR ImebraTagTypeSQ.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the dataset representing the appended sequence item </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pTagId</span></code>: the tag’s id in which the sequence must be stored </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pError</span></code>: a pointer to a NSError pointer which is set when an error occurs </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_mutable_data_set_1a2598f9a561ef61c250532614aebacb89"></span><code class="sig-name descname">ImebraWritingDataHandler* ImebraMutableDataSet::getWritingDataHandler:bufferId:tagVR:error:(ImebraTagId  * tagId, unsigned int bufferId, ImebraTagType tagVR, NSError ** pError)</code></dt>
<dd><p>Retrieve an <a class="reference internal" href="#interface_imebra_writing_data_handler"><span class="std std-ref">ImebraWritingDataHandler</span></a> object connected to a specific tag’s buffer and sets its data type (VR). </p>
<p>If the specified tag does not exist then it creates a new tag with the VR specified in the tagVR parameter</p>
<p>The returned <a class="reference internal" href="#interface_imebra_writing_data_handler"><span class="std std-ref">ImebraWritingDataHandler</span></a> is connected to a new buffer which is updated and stored into the tag when the <a class="reference internal" href="#interface_imebra_writing_data_handler"><span class="std std-ref">ImebraWritingDataHandler</span></a> object is destroyed.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>a <a class="reference internal" href="#interface_imebra_writing_data_handler"><span class="std std-ref">ImebraWritingDataHandler</span></a> object connected to a new tag’s buffer </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id containing the requested buffer </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bufferId</span></code>: the position where the new buffer has to be stored in the tag. The first buffer position is 0 </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">tagVR</span></code>: the tag’s VR </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pError</span></code>: a pointer to a NSError pointer which is set when an error occurs </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_mutable_data_set_1a26e8aca20164ba8bb71f94d5238811c9"></span><code class="sig-name descname">ImebraWritingDataHandler* ImebraMutableDataSet::getWritingDataHandler:bufferId:error:(ImebraTagId  * tagId, unsigned int bufferId, NSError ** pError)</code></dt>
<dd><p>Retrieve a <a class="reference internal" href="#interface_imebra_writing_data_handler"><span class="std std-ref">ImebraWritingDataHandler</span></a> object connected to a specific tag’s buffer. </p>
<p>If the specified tag does not exist then it creates a new tag with a default VR retrieved from the <a class="reference internal" href="dicom_dictionary_classes.html#interface_imebra_dicom_dictionary"><span class="std std-ref">ImebraDicomDictionary</span></a>.</p>
<p>The returned <a class="reference internal" href="#interface_imebra_writing_data_handler"><span class="std std-ref">ImebraWritingDataHandler</span></a> is connected to a new buffer which is updated and stored into the tag when the <a class="reference internal" href="#interface_imebra_writing_data_handler"><span class="std std-ref">ImebraWritingDataHandler</span></a> object is destroyed.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>a <a class="reference internal" href="#interface_imebra_writing_data_handler"><span class="std std-ref">ImebraWritingDataHandler</span></a> object connected to a new tag’s buffer </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id containing the requested buffer </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bufferId</span></code>: the position where the new buffer has to be stored in the tag. The first buffer position is 0 </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pError</span></code>: a pointer to a NSError pointer which is set when an error occurs </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_mutable_data_set_1a787c1acd76c6c5b97d39c28aa95041e5"></span><code class="sig-name descname">ImebraWritingDataHandlerNumeric* ImebraMutableDataSet::getWritingDataHandlerNumeric:bufferId:tagVR:error:(ImebraTagId  * tagId, unsigned long bufferId, ImebraTagType tagVR, NSError ** pError)</code></dt>
<dd><p>Retrieve a <a class="reference internal" href="#interface_imebra_writing_data_handler_numeric"><span class="std std-ref">ImebraWritingDataHandlerNumeric</span></a> object connected to a specific tag’s buffer. </p>
<p>If the tag’s VR is not a numeric type then throws std::bad_cast.</p>
<p>If the specified tag does not exist then it creates a new tag with the VR specified in the tagVR parameter</p>
<p>The returned <a class="reference internal" href="#interface_imebra_writing_data_handler_numeric"><span class="std std-ref">ImebraWritingDataHandlerNumeric</span></a> is connected to a new buffer which is updated and stored into the tag when <a class="reference internal" href="#interface_imebra_writing_data_handler_numeric"><span class="std std-ref">ImebraWritingDataHandlerNumeric</span></a> is destroyed.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>a <a class="reference internal" href="#interface_imebra_writing_data_handler_numeric"><span class="std std-ref">ImebraWritingDataHandlerNumeric</span></a> object connected to a new tag’s buffer </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id containing the requested buffer </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bufferId</span></code>: the position where the new buffer has to be stored in the tag. The first buffer position is 0 </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">tagVR</span></code>: the tag’s VR </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pError</span></code>: a pointer to a NSError pointer which is set when an error occurs </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_mutable_data_set_1af49032d1621193d0b2ef6c3157520f3c"></span><code class="sig-name descname">ImebraWritingDataHandlerNumeric* ImebraMutableDataSet::getWritingDataHandlerNumeric:bufferId:error:(ImebraTagId  * tagId, unsigned long bufferId, NSError ** pError)</code></dt>
<dd><p>Retrieve a <a class="reference internal" href="#interface_imebra_writing_data_handler_numeric"><span class="std std-ref">ImebraWritingDataHandlerNumeric</span></a> object connected to a specific tag’s buffer. </p>
<p>If the tag’s VR is not a numeric type then throws std::bad_cast.</p>
<p>If the specified tag does not exist then it creates a new tag with a default VR retrieved from the <a class="reference internal" href="dicom_dictionary_classes.html#interface_imebra_dicom_dictionary"><span class="std std-ref">ImebraDicomDictionary</span></a>.</p>
<p>The returned <a class="reference internal" href="#interface_imebra_writing_data_handler_numeric"><span class="std std-ref">ImebraWritingDataHandlerNumeric</span></a> is connected to a new buffer which is updated and stored into the tag when <a class="reference internal" href="#interface_imebra_writing_data_handler_numeric"><span class="std std-ref">ImebraWritingDataHandlerNumeric</span></a> is destroyed.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>a <a class="reference internal" href="#interface_imebra_writing_data_handler_numeric"><span class="std std-ref">ImebraWritingDataHandlerNumeric</span></a> object connected to a new tag’s buffer </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id containing the requested buffer </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bufferId</span></code>: the position where the new buffer has to be stored in the tag. The first buffer position is 0 </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pError</span></code>: a pointer to a NSError pointer which is set when an error occurs </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_mutable_data_set_1a606991303322a0bd19e7ab8cbc787aa0"></span><code class="sig-name descname">void ImebraMutableDataSet::setInt32:newValue:tagVR:error:(ImebraTagId  * tagId, signed int newValue, ImebraTagType tagVR, (swift_error(nonnull_error)) __attribute__)</code></dt>
<dd><p>Write a new signed 32 bit integer value into the element 0 of the specified tag’s buffer 0. </p>
<p>If the specified tag doesn’t exist then a new tag is created using the specified data type (VR).</p>
<p>If the new value cannot be converted to the specified VR then sets pError to ImebraDataHandlerConversionError.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">newValue</span></code>: the value to write into the tag </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">tagVR</span></code>: the tag’s type to use when a new tag is created. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pError</span></code>: a pointer to a NSError pointer which is set when an error occurs </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_mutable_data_set_1a167d36823a1fb8108ab0bb5aa71ddd8a"></span><code class="sig-name descname">void ImebraMutableDataSet::setSignedLong:newValue:tagVR:error:(ImebraTagId  * tagId, signed int newValue, ImebraTagType tagVR, (swift_error(nonnull_error)) __attribute__)</code></dt>
<dd><p>Deprecated. Use setInt32() instead. </p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_mutable_data_set_1a22dde6b675e8a257b33fab7ffaccffbd"></span><code class="sig-name descname">void ImebraMutableDataSet::setInt16:newValue:tagVR:error:(ImebraTagId  * tagId, signed short newValue, ImebraTagType tagVR, (swift_error(nonnull_error)) __attribute__)</code></dt>
<dd><p>Write a new signed 16 bit integer value into the element 0 of the specified tag’s buffer 0. </p>
<p>If the specified tag doesn’t exist then a new tag is created using the specified data type (VR).</p>
<p>If the new value cannot be converted to the specified VR then sets pError to ImebraDataHandlerConversionError.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">newValue</span></code>: the value to write into the tag </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">tagVR</span></code>: the tag’s type to use when a new tag is created. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pError</span></code>: a pointer to a NSError pointer which is set when an error occurs </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_mutable_data_set_1a7c06de65bc30732e5ac3e115fc6ef712"></span><code class="sig-name descname">void ImebraMutableDataSet::setInt8:newValue:tagVR:error:(ImebraTagId  * tagId, signed char newValue, ImebraTagType tagVR, (swift_error(nonnull_error)) __attribute__)</code></dt>
<dd><p>Write a new signed 8 bit integer value into the element 0 of the specified tag’s buffer 0. </p>
<p>If the specified tag doesn’t exist then a new tag is created using the specified data type (VR).</p>
<p>If the new value cannot be converted to the specified VR then sets pError to ImebraDataHandlerConversionError.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">newValue</span></code>: the value to write into the tag </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">tagVR</span></code>: the tag’s type to use when a new tag is created. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pError</span></code>: a pointer to a NSError pointer which is set when an error occurs </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_mutable_data_set_1a1a80ebc6b96ad16fbd75ca58b4283d40"></span><code class="sig-name descname">void ImebraMutableDataSet::setInt32:newValue:error:(ImebraTagId  * tagId, signed int newValue, (swift_error(nonnull_error)) __attribute__)</code></dt>
<dd><p>Write a new signed 32 bit integer value into the element 0 of the specified tag’s buffer 0. </p>
<p>If the specified tag doesn’t exist then a new tag is created using the data type (VR) retrieved from the <a class="reference internal" href="dicom_dictionary_classes.html#interface_imebra_dicom_dictionary"><span class="std std-ref">ImebraDicomDictionary</span></a>.</p>
<p>If the new value cannot be converted to the VR returned by the <a class="reference internal" href="dicom_dictionary_classes.html#interface_imebra_dicom_dictionary"><span class="std std-ref">ImebraDicomDictionary</span></a> then sets pError to ImebraDataHandlerConversionError.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">newValue</span></code>: the value to write into the tag </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pError</span></code>: a pointer to a NSError pointer which is set when an error occurs </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_mutable_data_set_1afe5bc20e50617bbdc86b773fe2457fe3"></span><code class="sig-name descname">void ImebraMutableDataSet::setSignedLong:newValue:error:(ImebraTagId  * tagId, signed int newValue, (swift_error(nonnull_error)) __attribute__)</code></dt>
<dd><p>Deprecated. Use setInt32() instead. </p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_mutable_data_set_1adac32f64f321f107376ae3090afe1eb7"></span><code class="sig-name descname">void ImebraMutableDataSet::setInt16:newValue:error:(ImebraTagId  * tagId, signed short newValue, (swift_error(nonnull_error)) __attribute__)</code></dt>
<dd><p>Write a new signed 16 bit integer value into the element 0 of the specified tag’s buffer 0. </p>
<p>If the specified tag doesn’t exist then a new tag is created using the data type (VR) retrieved from the <a class="reference internal" href="dicom_dictionary_classes.html#interface_imebra_dicom_dictionary"><span class="std std-ref">ImebraDicomDictionary</span></a>.</p>
<p>If the new value cannot be converted to the VR returned by the <a class="reference internal" href="dicom_dictionary_classes.html#interface_imebra_dicom_dictionary"><span class="std std-ref">ImebraDicomDictionary</span></a> then sets pError to ImebraDataHandlerConversionError.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">newValue</span></code>: the value to write into the tag </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pError</span></code>: a pointer to a NSError pointer which is set when an error occurs </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_mutable_data_set_1a25b7fa9a0eed9a5437171bafc95d979d"></span><code class="sig-name descname">void ImebraMutableDataSet::setInt8:newValue:error:(ImebraTagId  * tagId, signed char newValue, (swift_error(nonnull_error)) __attribute__)</code></dt>
<dd><p>Write a new signed 8 bit integer value into the element 0 of the specified tag’s buffer 0. </p>
<p>If the specified tag doesn’t exist then a new tag is created using the data type (VR) retrieved from the <a class="reference internal" href="dicom_dictionary_classes.html#interface_imebra_dicom_dictionary"><span class="std std-ref">ImebraDicomDictionary</span></a>.</p>
<p>If the new value cannot be converted to the VR returned by the <a class="reference internal" href="dicom_dictionary_classes.html#interface_imebra_dicom_dictionary"><span class="std std-ref">ImebraDicomDictionary</span></a> then sets pError to ImebraDataHandlerConversionError.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">newValue</span></code>: the value to write into the tag </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pError</span></code>: a pointer to a NSError pointer which is set when an error occurs </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_mutable_data_set_1a1fffd092f16a281100f2f6496912a9c5"></span><code class="sig-name descname">void ImebraMutableDataSet::setUint32:newValue:tagVR:error:(ImebraTagId  * tagId, unsigned int newValue, ImebraTagType tagVR, (swift_error(nonnull_error)) __attribute__)</code></dt>
<dd><p>Write a new unsigned 32 bit integer value into the element 0 of the specified tag’s buffer 0. </p>
<p>When setting a value for an AT tag (Attribute Tag) then the tag’s group must always be in the higher 16 bits of the value.</p>
<p>If the specified tag doesn’t exist then a new tag is created using the specified data type (VR).</p>
<p>If the new value cannot be converted to the specified VR then sets pError to ImebraDataHandlerConversionError.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">newValue</span></code>: the value to write into the tag </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">tagVR</span></code>: the tag’s type to use when a new tag is created. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pError</span></code>: a pointer to a NSError pointer which is set when an error occurs </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_mutable_data_set_1a3cb5df09887f2e723ab6d4b23e0cac63"></span><code class="sig-name descname">void ImebraMutableDataSet::setUnsignedLong:newValue:tagVR:error:(ImebraTagId  * tagId, unsigned int newValue, ImebraTagType tagVR, (swift_error(nonnull_error)) __attribute__)</code></dt>
<dd><p>Deprecated. Use setUint32() instead. </p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_mutable_data_set_1a521ad052ed9b3385b19a8cfa14a425f3"></span><code class="sig-name descname">void ImebraMutableDataSet::setUint16:newValue:tagVR:error:(ImebraTagId  * tagId, unsigned short newValue, ImebraTagType tagVR, (swift_error(nonnull_error)) __attribute__)</code></dt>
<dd><p>Write a new unsigned 16 bit integer value into the element 0 of the specified tag’s buffer 0. </p>
<p>If the specified tag doesn’t exist then a new tag is created using the specified data type (VR).</p>
<p>If the new value cannot be converted to the specified VR then sets pError to ImebraDataHandlerConversionError.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">newValue</span></code>: the value to write into the tag </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">tagVR</span></code>: the tag’s type to use when a new tag is created. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pError</span></code>: a pointer to a NSError pointer which is set when an error occurs </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_mutable_data_set_1ac8650410b0637cc1823c80e8cec9e88d"></span><code class="sig-name descname">void ImebraMutableDataSet::setUint8:newValue:tagVR:error:(ImebraTagId  * tagId, unsigned char newValue, ImebraTagType tagVR, (swift_error(nonnull_error)) __attribute__)</code></dt>
<dd><p>Write a new unsigned 8 bit integer value into the element 0 of the specified tag’s buffer 0. </p>
<p>If the specified tag doesn’t exist then a new tag is created using the specified data type (VR).</p>
<p>If the new value cannot be converted to the specified VR then sets pError to ImebraDataHandlerConversionError.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">newValue</span></code>: the value to write into the tag </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">tagVR</span></code>: the tag’s type to use when a new tag is created. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pError</span></code>: a pointer to a NSError pointer which is set when an error occurs </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_mutable_data_set_1a207e5b4f5cd5992d59b27843867b8c75"></span><code class="sig-name descname">void ImebraMutableDataSet::setUint32:newValue:error:(ImebraTagId  * tagId, unsigned int newValue, (swift_error(nonnull_error)) __attribute__)</code></dt>
<dd><p>Write a new unsigned 32 bit integer value into the element 0 of the specified tag’s buffer 0. </p>
<p>When setting a value for an AT tag (Attribute Tag) then the tag’s group must always be in the higher 16 bits of the value.</p>
<p>If the specified tag doesn’t exist then a new tag is created using the data type (VR) retrieved from the <a class="reference internal" href="dicom_dictionary_classes.html#interface_imebra_dicom_dictionary"><span class="std std-ref">ImebraDicomDictionary</span></a>.</p>
<p>If the new value cannot be converted to the VR returned by the <a class="reference internal" href="dicom_dictionary_classes.html#interface_imebra_dicom_dictionary"><span class="std std-ref">ImebraDicomDictionary</span></a> then sets pError to ImebraDataHandlerConversionError.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">newValue</span></code>: the value to write into the tag </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pError</span></code>: a pointer to a NSError pointer which is set when an error occurs </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_mutable_data_set_1aee95369362aa8b2dca24b2d5f2f5235b"></span><code class="sig-name descname">void ImebraMutableDataSet::setUnsignedLong:newValue:error:(ImebraTagId  * tagId, unsigned int newValue, (swift_error(nonnull_error)) __attribute__)</code></dt>
<dd><p>Deprecated. Use setUint32() instead. </p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_mutable_data_set_1a8c39d2145508ee54ce1428e31dad142d"></span><code class="sig-name descname">void ImebraMutableDataSet::setUint16:newValue:error:(ImebraTagId  * tagId, unsigned short newValue, (swift_error(nonnull_error)) __attribute__)</code></dt>
<dd><p>Write a new unsigned 16 bit integer value into the element 0 of the specified tag’s buffer 0. </p>
<p>If the specified tag doesn’t exist then a new tag is created using the data type (VR) retrieved from the <a class="reference internal" href="dicom_dictionary_classes.html#interface_imebra_dicom_dictionary"><span class="std std-ref">ImebraDicomDictionary</span></a>.</p>
<p>If the new value cannot be converted to the VR returned by the <a class="reference internal" href="dicom_dictionary_classes.html#interface_imebra_dicom_dictionary"><span class="std std-ref">ImebraDicomDictionary</span></a> then sets pError to ImebraDataHandlerConversionError.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">newValue</span></code>: the value to write into the tag </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pError</span></code>: a pointer to a NSError pointer which is set when an error occurs </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_mutable_data_set_1a8e588e5ef138f5c3dc2665ca9aace5b5"></span><code class="sig-name descname">void ImebraMutableDataSet::setUint8:newValue:error:(ImebraTagId  * tagId, unsigned char newValue, (swift_error(nonnull_error)) __attribute__)</code></dt>
<dd><p>Write a new unsigned 8 bit integer value into the element 0 of the specified tag’s buffer 0. </p>
<p>If the specified tag doesn’t exist then a new tag is created using the data type (VR) retrieved from the <a class="reference internal" href="dicom_dictionary_classes.html#interface_imebra_dicom_dictionary"><span class="std std-ref">ImebraDicomDictionary</span></a>.</p>
<p>If the new value cannot be converted to the VR returned by the <a class="reference internal" href="dicom_dictionary_classes.html#interface_imebra_dicom_dictionary"><span class="std std-ref">ImebraDicomDictionary</span></a> then sets pError to ImebraDataHandlerConversionError.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">newValue</span></code>: the value to write into the tag </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pError</span></code>: a pointer to a NSError pointer which is set when an error occurs </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_mutable_data_set_1a0319411461848a9767b87300773b9516"></span><code class="sig-name descname">void ImebraMutableDataSet::setDouble:newValue:tagVR:error:(ImebraTagId  * tagId, double newValue, ImebraTagType tagVR, (swift_error(nonnull_error)) __attribute__)</code></dt>
<dd><p>Write a new double floating point value into the element 0 of the specified tag’s buffer 0. </p>
<p>If the specified tag doesn’t exist then a new tag is created using the specified data type (VR).</p>
<p>If the new value cannot be converted to the specified VR then sets pError to ImebraDataHandlerConversionError.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">newValue</span></code>: the value to write into the tag </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">tagVR</span></code>: the tag’s type to use when a new tag is created. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pError</span></code>: a pointer to a NSError pointer which is set when an error occurs </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_mutable_data_set_1aeef70f31da7992a00c4e284fc95c18ca"></span><code class="sig-name descname">void ImebraMutableDataSet::setFloat:newValue:tagVR:error:(ImebraTagId  * tagId, float newValue, ImebraTagType tagVR, (swift_error(nonnull_error)) __attribute__)</code></dt>
<dd><p>Write a new floating point value into the element 0 of the specified tag’s buffer 0. </p>
<p>If the specified tag doesn’t exist then a new tag is created using the specified data type (VR).</p>
<p>If the new value cannot be converted to the specified VR then sets pError to ImebraDataHandlerConversionError.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">newValue</span></code>: the value to write into the tag </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">tagVR</span></code>: the tag’s type to use when a new tag is created. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pError</span></code>: a pointer to a NSError pointer which is set when an error occurs </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_mutable_data_set_1a8be84225effdb15490789c9919e616ae"></span><code class="sig-name descname">void ImebraMutableDataSet::setDouble:newValue:error:(ImebraTagId  * tagId, double newValue, (swift_error(nonnull_error)) __attribute__)</code></dt>
<dd><p>Write a new double floating point value into the element 0 of the specified tag’s buffer 0. </p>
<p>If the specified tag doesn’t exist then a new tag is created using the data type (VR) retrieved from the <a class="reference internal" href="dicom_dictionary_classes.html#interface_imebra_dicom_dictionary"><span class="std std-ref">ImebraDicomDictionary</span></a>.</p>
<p>If the new value cannot be converted to the VR returned by the <a class="reference internal" href="dicom_dictionary_classes.html#interface_imebra_dicom_dictionary"><span class="std std-ref">ImebraDicomDictionary</span></a> then sets pError to ImebraDataHandlerConversionError.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">newValue</span></code>: the value to write into the tag </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pError</span></code>: a pointer to a NSError pointer which is set when an error occurs </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_mutable_data_set_1ad38d510258f9bfe0360fddab87a3fa64"></span><code class="sig-name descname">void ImebraMutableDataSet::setFloat:newValue:error:(ImebraTagId  * tagId, float newValue, (swift_error(nonnull_error)) __attribute__)</code></dt>
<dd><p>Write a new floating point value into the element 0 of the specified tag’s buffer 0. </p>
<p>If the specified tag doesn’t exist then a new tag is created using the data type (VR) retrieved from the <a class="reference internal" href="dicom_dictionary_classes.html#interface_imebra_dicom_dictionary"><span class="std std-ref">ImebraDicomDictionary</span></a>.</p>
<p>If the new value cannot be converted to the VR returned by the <a class="reference internal" href="dicom_dictionary_classes.html#interface_imebra_dicom_dictionary"><span class="std std-ref">ImebraDicomDictionary</span></a> then sets pError to ImebraDataHandlerConversionError.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">newValue</span></code>: the value to write into the tag </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pError</span></code>: a pointer to a NSError pointer which is set when an error occurs </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_mutable_data_set_1a7031f0a87be86b99e0432fb7df18c4da"></span><code class="sig-name descname">void ImebraMutableDataSet::setString:newValue:tagVR:error:(ImebraTagId  * tagId, NSString * newValue, ImebraTagType tagVR, (swift_error(nonnull_error)) __attribute__)</code></dt>
<dd><p>Write a new string value into the element 0 of the specified tag’s buffer 0. </p>
<p>If the specified tag doesn’t exist then a new tag is created using the specified data type (VR).</p>
<p>If the new value cannot be converted to the specified VR then sets pError to ImebraDataHandlerConversionError.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">newValue</span></code>: the value to write into the tag </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">tagVR</span></code>: the tag’s type to use when a new tag is created. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pError</span></code>: a pointer to a NSError pointer which is set when an error occurs </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_mutable_data_set_1a19c5cf4dd085993914e583928a4c448a"></span><code class="sig-name descname">void ImebraMutableDataSet::setString:newValue:error:(ImebraTagId  * tagId, NSString * newValue, (swift_error(nonnull_error)) __attribute__)</code></dt>
<dd><p>Write a new string value into the element 0 of the specified tag’s buffer 0. </p>
<p>If the specified tag doesn’t exist then a new tag is created using the data type (VR) retrieved from the <a class="reference internal" href="dicom_dictionary_classes.html#interface_imebra_dicom_dictionary"><span class="std std-ref">ImebraDicomDictionary</span></a>.</p>
<p>If the new value cannot be converted to the VR returned by the <a class="reference internal" href="dicom_dictionary_classes.html#interface_imebra_dicom_dictionary"><span class="std std-ref">ImebraDicomDictionary</span></a> then sets pError to ImebraDataHandlerConversionError.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">newValue</span></code>: the value to write into the tag </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pError</span></code>: a pointer to a NSError pointer which is set when an error occurs </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_mutable_data_set_1add553dc9e4002dc028642b61abfdb77b"></span><code class="sig-name descname">void ImebraMutableDataSet::setAge:newValue:error:(ImebraTagId  * tagId, ImebraAge  * newValue, (swift_error(nonnull_error)) __attribute__)</code></dt>
<dd><p>Write a new <a class="reference internal" href="#interface_imebra_age"><span class="std std-ref">ImebraAge</span></a> value into the element 0 of the specified tag’s buffer 0. </p>
<p>If the specified tag doesn’t exist then a new tag is created using the data type (VR) AS.</p>
<p>If the new value cannot be converted to the VR “AS” then sets pError to ImebraDataHandlerConversionError.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">newValue</span></code>: the value to write into the tag </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pError</span></code>: a pointer to a NSError pointer which is set when an error occurs </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_mutable_data_set_1a0338c9602c8670c98af2eae3d31ce694"></span><code class="sig-name descname">void ImebraMutableDataSet::setDate:newValue:tagVR:error:(ImebraTagId  * tagId, ImebraDate * newValue, ImebraTagType tagVR, (swift_error(nonnull_error)) __attribute__)</code></dt>
<dd><p>Write a new ImebraDate value into the element 0 of the specified tag’s buffer 0. </p>
<p>If the specified tag doesn’t exist then a new tag is created using the specified data type (VR).</p>
<p>If the new value cannot be converted to the specified VR then sets pError to ImebraDataHandlerConversionError.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">newValue</span></code>: the value to write into the tag </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">tagVR</span></code>: the tag’s type to use when a new tag is created. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pError</span></code>: a pointer to a NSError pointer which is set when an error occurs </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_mutable_data_set_1a0fd51279637d01ec863d77c712003ecd"></span><code class="sig-name descname">void ImebraMutableDataSet::setDate:newValue:error:(ImebraTagId  * tagId, ImebraDate * newValue, (swift_error(nonnull_error)) __attribute__)</code></dt>
<dd><p>Write a new ImebraDate value into the element 0 of the specified tag’s buffer 0. </p>
<p>If the specified tag doesn’t exist then a new tag is created using the data type (VR) retrieved from the <a class="reference internal" href="dicom_dictionary_classes.html#interface_imebra_dicom_dictionary"><span class="std std-ref">ImebraDicomDictionary</span></a>.</p>
<p>If the new value cannot be converted to the VR returned by the <a class="reference internal" href="dicom_dictionary_classes.html#interface_imebra_dicom_dictionary"><span class="std std-ref">ImebraDicomDictionary</span></a> then sets pError to ImebraDataHandlerConversionError.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">newValue</span></code>: the value to write into the tag </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pError</span></code>: a pointer to a NSError pointer which is set when an error occurs </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_mutable_data_set_1aa521ad250eb821bc3f389100cea80c0d"></span><code class="sig-name descname">void ImebraMutableDataSet::setPatientName:newValue:error:(ImebraTagId  * tagId, ImebraPatientName * newValue, (swift_error(nonnull_error)) __attribute__)</code></dt>
<dd><p>Write a new ImebraPatientName value into the element 0 of the specified tag’s buffer 0. </p>
<p>If the specified tag doesn’t exist then a new tag is created using the data type (VR) PN.</p>
<p>If the new value cannot be converted to a patient name then sets pError to ImebraDataHandlerConversionError.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">newValue</span></code>: the value to write into the tag </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pError</span></code>: a pointer to a NSError pointer which is set when an error occurs </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</div>
</div>
<div class="section" id="tag">
<span id="id5"></span><h3>Tag<a class="headerlink" href="#tag" title="Permalink to this headline">¶</a></h3>
<div class="section" id="id6">
<h4>C++<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h4>
<dl class="class">
<dt id="_CPPv4N6imebra3TagE">
<span id="_CPPv3N6imebra3TagE"></span><span id="_CPPv2N6imebra3TagE"></span><span id="imebra::Tag"></span><span class="target" id="classimebra_1_1_tag"></span><em class="property">class </em><code class="sig-name descname">Tag</code><a class="headerlink" href="#_CPPv4N6imebra3TagE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This class represents an immutable DICOM tag. </p>
<p>Subclassed by <a class="reference internal" href="#classimebra_1_1_mutable_tag"><span class="std std-ref">imebra::MutableTag</span></a></p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv4N6imebra3Tag3TagERK3Tag">
<span id="_CPPv3N6imebra3Tag3TagERK3Tag"></span><span id="_CPPv2N6imebra3Tag3TagERK3Tag"></span><span id="imebra::Tag::Tag__TagCR"></span><span class="target" id="classimebra_1_1_tag_1a9a50b0913f4134bc1a58d1e56b81f772"></span><code class="sig-name descname">Tag</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N6imebra3Tag3TagERK3Tag" title="imebra::Tag::Tag">Tag</a> &amp;<em>source</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N6imebra3Tag3TagERK3Tag" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Copy constructor. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">source</span></code>: source <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a> object </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK6imebra3Tag15getBuffersCountEv">
<span id="_CPPv3NK6imebra3Tag15getBuffersCountEv"></span><span id="_CPPv2NK6imebra3Tag15getBuffersCountEv"></span><span id="imebra::Tag::getBuffersCountC"></span><span class="target" id="classimebra_1_1_tag_1add16b13b9808887f817e725163331b33"></span>size_t <code class="sig-name descname">getBuffersCount</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK6imebra3Tag15getBuffersCountEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns the number of buffers in the tag. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the number of buffers in the tag </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK6imebra3Tag12bufferExistsE6size_t">
<span id="_CPPv3NK6imebra3Tag12bufferExistsE6size_t"></span><span id="_CPPv2NK6imebra3Tag12bufferExistsE6size_t"></span><span id="imebra::Tag::bufferExists__sC"></span><span class="target" id="classimebra_1_1_tag_1a1600316d28d97c4d421b22931548a2b6"></span>bool <code class="sig-name descname">bufferExists</code><span class="sig-paren">(</span>size_t <em>bufferId</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK6imebra3Tag12bufferExistsE6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns true if the specified buffer exists, otherwise it returns false. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>true if the buffer exists, false otherwise </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">bufferId</span></code>: the zero-based buffer’s id the function has to check for </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK6imebra3Tag13getBufferSizeE6size_t">
<span id="_CPPv3NK6imebra3Tag13getBufferSizeE6size_t"></span><span id="_CPPv2NK6imebra3Tag13getBufferSizeE6size_t"></span><span id="imebra::Tag::getBufferSize__sC"></span><span class="target" id="classimebra_1_1_tag_1abc051a38f616f2a4eadda4edc75dd15c"></span>size_t <code class="sig-name descname">getBufferSize</code><span class="sig-paren">(</span>size_t <em>bufferId</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK6imebra3Tag13getBufferSizeE6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns the size of a buffer, in bytes. </p>
<p>If the buffer doesn’t exist then throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_missing_buffer_error"><span class="std std-ref">MissingBufferError</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the buffer’s size in bytes </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">bufferId</span></code>: the zero-based buffer’s id the function has to check for </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK6imebra3Tag21getReadingDataHandlerE6size_t">
<span id="_CPPv3NK6imebra3Tag21getReadingDataHandlerE6size_t"></span><span id="_CPPv2NK6imebra3Tag21getReadingDataHandlerE6size_t"></span><span id="imebra::Tag::getReadingDataHandler__sC"></span><span class="target" id="classimebra_1_1_tag_1ab65f0621e9f94ce6d81413aa9b7af63e"></span><a class="reference internal" href="#_CPPv4N6imebra18ReadingDataHandlerE" title="imebra::ReadingDataHandler">ReadingDataHandler</a> <code class="sig-name descname">getReadingDataHandler</code><span class="sig-paren">(</span>size_t <em>bufferId</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK6imebra3Tag21getReadingDataHandlerE6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Retrieve a <a class="reference internal" href="#classimebra_1_1_reading_data_handler"><span class="std std-ref">ReadingDataHandler</span></a> object connected to a specific buffer. </p>
<p>If the specified buffer does not exist then throws or <a class="reference internal" href="exception_classes.html#classimebra_1_1_missing_buffer_error"><span class="std std-ref">MissingBufferError</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>a <a class="reference internal" href="#classimebra_1_1_reading_data_handler"><span class="std std-ref">ReadingDataHandler</span></a> object connected to the requested buffer </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">bufferId</span></code>: the buffer to connect to the <a class="reference internal" href="#classimebra_1_1_reading_data_handler"><span class="std std-ref">ReadingDataHandler</span></a> object. The first buffer has an Id = 0 </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK6imebra3Tag28getReadingDataHandlerNumericE6size_t">
<span id="_CPPv3NK6imebra3Tag28getReadingDataHandlerNumericE6size_t"></span><span id="_CPPv2NK6imebra3Tag28getReadingDataHandlerNumericE6size_t"></span><span id="imebra::Tag::getReadingDataHandlerNumeric__sC"></span><span class="target" id="classimebra_1_1_tag_1aea3eefc0904f345fee1c6db0520b19ef"></span><a class="reference internal" href="#_CPPv4N6imebra25ReadingDataHandlerNumericE" title="imebra::ReadingDataHandlerNumeric">ReadingDataHandlerNumeric</a> <code class="sig-name descname">getReadingDataHandlerNumeric</code><span class="sig-paren">(</span>size_t <em>bufferId</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK6imebra3Tag28getReadingDataHandlerNumericE6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Retrieve a <a class="reference internal" href="#classimebra_1_1_reading_data_handler_numeric"><span class="std std-ref">ReadingDataHandlerNumeric</span></a> object connected to the <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a>’s numeric buffer. </p>
<p>If the tag’s VR is not a numeric type then throws std::bad_cast.</p>
<p>If the specified <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a> does not contain the specified buffer then throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_missing_buffer_error"><span class="std std-ref">MissingBufferError</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>a <a class="reference internal" href="#classimebra_1_1_reading_data_handler_numeric"><span class="std std-ref">ReadingDataHandlerNumeric</span></a> object connected to the <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a>’s buffer </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">bufferId</span></code>: the buffer to connect to the <a class="reference internal" href="#classimebra_1_1_reading_data_handler"><span class="std std-ref">ReadingDataHandler</span></a> object. The first buffer has an Id = 0 </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK6imebra3Tag24getReadingDataHandlerRawE6size_t">
<span id="_CPPv3NK6imebra3Tag24getReadingDataHandlerRawE6size_t"></span><span id="_CPPv2NK6imebra3Tag24getReadingDataHandlerRawE6size_t"></span><span id="imebra::Tag::getReadingDataHandlerRaw__sC"></span><span class="target" id="classimebra_1_1_tag_1a3ad99bb29f896f87c172c7e69b8b6eef"></span><a class="reference internal" href="#_CPPv4N6imebra25ReadingDataHandlerNumericE" title="imebra::ReadingDataHandlerNumeric">ReadingDataHandlerNumeric</a> <code class="sig-name descname">getReadingDataHandlerRaw</code><span class="sig-paren">(</span>size_t <em>bufferId</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK6imebra3Tag24getReadingDataHandlerRawE6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Retrieve a <a class="reference internal" href="#classimebra_1_1_reading_data_handler_numeric"><span class="std std-ref">ReadingDataHandlerNumeric</span></a> object connected to the <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a>’s raw data buffer (8 bit unsigned integers). </p>
<p>If the tag’s VR is not a numeric type then throws std::bad_cast.</p>
<p>If the specified <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a> does not contain the specified buffer then throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_missing_buffer_error"><span class="std std-ref">MissingBufferError</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>a <a class="reference internal" href="#classimebra_1_1_reading_data_handler_numeric"><span class="std std-ref">ReadingDataHandlerNumeric</span></a> object connected to the <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a>’s buffer (raw content represented by 8 bit unsigned integers) </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">bufferId</span></code>: the buffer to connect to the <a class="reference internal" href="#classimebra_1_1_reading_data_handler"><span class="std std-ref">ReadingDataHandler</span></a> object. The first buffer has an Id = 0 </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK6imebra3Tag15getStreamReaderE6size_t">
<span id="_CPPv3NK6imebra3Tag15getStreamReaderE6size_t"></span><span id="_CPPv2NK6imebra3Tag15getStreamReaderE6size_t"></span><span id="imebra::Tag::getStreamReader__sC"></span><span class="target" id="classimebra_1_1_tag_1a388576cee06af72654c232ab7e627b1a"></span><a class="reference internal" href="stream_classes.html#_CPPv4N6imebra12StreamReaderE" title="imebra::StreamReader">StreamReader</a> <code class="sig-name descname">getStreamReader</code><span class="sig-paren">(</span>size_t <em>bufferId</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK6imebra3Tag15getStreamReaderE6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get a <a class="reference internal" href="stream_classes.html#classimebra_1_1_stream_reader"><span class="std std-ref">StreamReader</span></a> connected to a buffer’s data. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the <a class="reference internal" href="stream_classes.html#classimebra_1_1_stream_reader"><span class="std std-ref">StreamReader</span></a> connected to the buffer’s data. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">bufferId</span></code>: the id of the buffer for which the <a class="reference internal" href="stream_classes.html#classimebra_1_1_stream_reader"><span class="std std-ref">StreamReader</span></a> is required. This parameter is usually 0 </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK6imebra3Tag15getSequenceItemE6size_t">
<span id="_CPPv3NK6imebra3Tag15getSequenceItemE6size_t"></span><span id="_CPPv2NK6imebra3Tag15getSequenceItemE6size_t"></span><span id="imebra::Tag::getSequenceItem__sC"></span><span class="target" id="classimebra_1_1_tag_1a00690eac6f7129673d23ce9f77fbb798"></span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N6imebra7DataSetE" title="imebra::DataSet">DataSet</a> <code class="sig-name descname">getSequenceItem</code><span class="sig-paren">(</span>size_t <em>dataSetId</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK6imebra3Tag15getSequenceItemE6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Retrieve an embedded <a class="reference internal" href="#classimebra_1_1_data_set"><span class="std std-ref">DataSet</span></a>. </p>
<p>Sequence tags (VR=SQ) store embedded dicom structures.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the sequence <a class="reference internal" href="#classimebra_1_1_data_set"><span class="std std-ref">DataSet</span></a> </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">dataSetId</span></code>: the ID of the sequence item to retrieve. Several sequence items can be embedded in one tag. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK6imebra3Tag18sequenceItemExistsE6size_t">
<span id="_CPPv3NK6imebra3Tag18sequenceItemExistsE6size_t"></span><span id="_CPPv2NK6imebra3Tag18sequenceItemExistsE6size_t"></span><span id="imebra::Tag::sequenceItemExists__sC"></span><span class="target" id="classimebra_1_1_tag_1a95e0efd4b5c56e0968513a0f6b7b32e1"></span>bool <code class="sig-name descname">sequenceItemExists</code><span class="sig-paren">(</span>size_t <em>dataSetId</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK6imebra3Tag18sequenceItemExistsE6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Check for the existance of a sequence item. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>true if the sequence item exists, false otherwise </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">dataSetId</span></code>: the ID of the sequence item to check for </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK6imebra3Tag11getDataTypeEv">
<span id="_CPPv3NK6imebra3Tag11getDataTypeEv"></span><span id="_CPPv2NK6imebra3Tag11getDataTypeEv"></span><span id="imebra::Tag::getDataTypeC"></span><span class="target" id="classimebra_1_1_tag_1a89f96a04cbb3e44a2fb9f5e09182071e"></span><a class="reference internal" href="definition_classes.html#_CPPv4N6imebra7tagVR_tE" title="imebra::tagVR_t">tagVR_t</a> <code class="sig-name descname">getDataType</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK6imebra3Tag11getDataTypeEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get the tag’s data type. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the tag’s data type </p>
</dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</div>
<div class="section" id="id7">
<h4>Objective-C/Swift<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h4>
<dl class="class">
<dt id="_CPPv49ImebraTag">
<span id="_CPPv39ImebraTag"></span><span id="_CPPv29ImebraTag"></span><span id="ImebraTag"></span><span class="target" id="interface_imebra_tag"></span><em class="property">class </em><code class="sig-name descname">ImebraTag</code> : <em class="property">public</em> NSObject<a class="headerlink" href="#_CPPv49ImebraTag" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This class represents a DICOM tag. </p>
<p>Subclassed by <a class="reference internal" href="#interface_imebra_mutable_tag"><span class="std std-ref">ImebraMutableTag</span></a></p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv4N9ImebraTag15getBuffersCountEv">
<span id="_CPPv3N9ImebraTag15getBuffersCountEv"></span><span id="_CPPv2N9ImebraTag15getBuffersCountEv"></span><span id="ImebraTag::getBuffersCount"></span><span class="target" id="interface_imebra_tag_1a9ed2852f15422dbfe322a21daf640658"></span>unsigned int <code class="sig-name descname">getBuffersCount</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N9ImebraTag15getBuffersCountEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns the number of buffers in the tag. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the number of buffers in the tag </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_tag_1ac4be15d1e412cc22560a777572168a7e"></span><code class="sig-name descname">BOOL ImebraTag::bufferExists:(unsigned int bufferId)</code></dt>
<dd><p>Returns true if the specified buffer exists, otherwise it returns false. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>true if the buffer exists, false otherwise </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">bufferId</span></code>: the zero-based buffer’s id the function has to check for </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_tag_1ad75d1ec12918a3331b049b93d3ec1ade"></span><code class="sig-name descname">unsigned int ImebraTag::getBufferSize:error:(unsigned int bufferId, (swift_error(nonnull_error)) __attribute__)</code></dt>
<dd><p>Returns the size of a buffer, in bytes. </p>
<p>If the buffer doesn’t exist then set pError to ImebraMissingBufferError.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the buffer’s size in bytes </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">bufferId</span></code>: the zero-based buffer’s id the function has to check for </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pError</span></code>: set to a NSError derived class in case of error </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_tag_1aa06187f3e81b4fa3c06024554df4ca1f"></span><code class="sig-name descname">ImebraReadingDataHandler* ImebraTag::getReadingDataHandler:error:(unsigned int bufferId, NSError ** pError)</code></dt>
<dd><p>Retrieve a <a class="reference internal" href="#interface_imebra_reading_data_handler"><span class="std std-ref">ImebraReadingDataHandler</span></a> object connected to a specific buffer. </p>
<p>If the buffer doesn’t exist then set pError to ImebraMissingBufferError.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>a <a class="reference internal" href="#interface_imebra_reading_data_handler"><span class="std std-ref">ImebraReadingDataHandler</span></a> object connected to the requested buffer </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">bufferId</span></code>: the buffer to connect to the ReadingDataHandler object. The first buffer has an Id = 0 </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pError</span></code>: set to a NSError derived class in case of error </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_tag_1af9fdb89f331383e789eb40faf27f6366"></span><code class="sig-name descname">ImebraReadingDataHandlerNumeric* ImebraTag::getReadingDataHandlerNumeric:error:(unsigned int bufferId, NSError ** pError)</code></dt>
<dd><p>Retrieve a <a class="reference internal" href="#interface_imebra_reading_data_handler_numeric"><span class="std std-ref">ImebraReadingDataHandlerNumeric</span></a> object connected to the Tag’s numeric buffer. </p>
<p>If the tag’s VR is not a numeric type then throws std::bad_cast.</p>
<p>If the tag does not contain the specified buffer then set pError to ImebraMissingBufferError.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>a <a class="reference internal" href="#interface_imebra_reading_data_handler_numeric"><span class="std std-ref">ImebraReadingDataHandlerNumeric</span></a> object connected to the Tag’s buffer </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">bufferId</span></code>: the buffer to connect to the <a class="reference internal" href="#interface_imebra_reading_data_handler"><span class="std std-ref">ImebraReadingDataHandler</span></a> object. The first buffer has an Id = 0 </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pError</span></code>: set to a NSError derived class in case of error </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_tag_1a6b2b2b228deee82362827894311512ef"></span><code class="sig-name descname">ImebraReadingDataHandlerNumeric* ImebraTag::getReadingDataHandlerRaw:error:(unsigned int bufferId, NSError ** pError)</code></dt>
<dd><p>Retrieve a ReadingDataHandlerNumeric object connected to the Tag’s raw data buffer (8 bit unsigned integers). </p>
<p>If the tag’s VR is not a numeric type then throws std::bad_cast.</p>
<p>If the specified Tag does not contain the specified buffer then throws MissingBufferError.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>a ReadingDataHandlerNumeric object connected to the Tag’s buffer (raw content represented by 8 bit unsigned integers) </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">bufferId</span></code>: the buffer to connect to the ReadingDataHandler object. The first buffer has an Id = 0 </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pError</span></code>: set to a NSError derived class in case of error </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_tag_1af958392f3776db58487664f41245af22"></span><code class="sig-name descname">ImebraStreamReader* ImebraTag::getStreamReader:error:(unsigned int bufferId, NSError ** pError)</code></dt>
<dd><p>Get a StreamReader connected to a buffer’s data. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the streamReader connected to the buffer’s data. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">bufferId</span></code>: the id of the buffer for which the StreamReader is required. This parameter is usually 0 </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pError</span></code>: set to a NSError derived class in case of error </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_tag_1a3021d2b4ba239056007b584be9cc2e82"></span><code class="sig-name descname">ImebraDataSet* ImebraTag::getSequenceItem:error:(unsigned int dataSetId, NSError ** pError)</code></dt>
<dd><p>Retrieve an embedded DataSet. </p>
<p>Sequence tags (VR=SQ) store embedded dicom structures.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the sequence DataSet </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">dataSetId</span></code>: the ID of the sequence item to retrieve. Several sequence items can be embedded in one tag. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pError</span></code>: set to a NSError derived class in case of error </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_tag_1afcf7787e3f363acb90bed9bba4b5c631"></span><code class="sig-name descname">BOOL ImebraTag::sequenceItemExists:(unsigned int dataSetId)</code></dt>
<dd><p>Check for the existance of a sequence item. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>true if the sequence item exists, false otherwise </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">dataSetId</span></code>: the ID of the sequence item to check for </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Property</p>
<dl class="member">
<dt>
<span class="target" id="interface_imebra_tag_1a3099f6a3ae9feae32fe67b676800b43f"></span><em class="property">property </em><code class="sig-name descname">ImebraTag::dataType</code></dt>
<dd><p>Get the tag’s data type. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the tag’s data type </p>
</dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</div>
</div>
<div class="section" id="mutabletag">
<span id="id8"></span><h3>MutableTag<a class="headerlink" href="#mutabletag" title="Permalink to this headline">¶</a></h3>
<div class="section" id="id9">
<h4>C++<a class="headerlink" href="#id9" title="Permalink to this headline">¶</a></h4>
<dl class="class">
<dt id="_CPPv4N6imebra10MutableTagE">
<span id="_CPPv3N6imebra10MutableTagE"></span><span id="_CPPv2N6imebra10MutableTagE"></span><span id="imebra::MutableTag"></span><span class="target" id="classimebra_1_1_mutable_tag"></span><em class="property">class </em><code class="sig-name descname">MutableTag</code> : <em class="property">public</em> imebra::<a class="reference internal" href="#_CPPv4N6imebra3TagE" title="imebra::Tag">Tag</a><a class="headerlink" href="#_CPPv4N6imebra10MutableTagE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This class represents a mutable DICOM tag. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv4N6imebra10MutableTag10MutableTagERK10MutableTag">
<span id="_CPPv3N6imebra10MutableTag10MutableTagERK10MutableTag"></span><span id="_CPPv2N6imebra10MutableTag10MutableTagERK10MutableTag"></span><span id="imebra::MutableTag::MutableTag__MutableTagCR"></span><span class="target" id="classimebra_1_1_mutable_tag_1a3d9e1a91737cde802a494a60c51e35ba"></span><code class="sig-name descname">MutableTag</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N6imebra10MutableTag10MutableTagERK10MutableTag" title="imebra::MutableTag::MutableTag">MutableTag</a> &amp;<em>source</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N6imebra10MutableTag10MutableTagERK10MutableTag" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Copy constructor. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">source</span></code>: source <a class="reference internal" href="#classimebra_1_1_mutable_tag"><span class="std std-ref">MutableTag</span></a> object </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N6imebra10MutableTag21getWritingDataHandlerE6size_t">
<span id="_CPPv3N6imebra10MutableTag21getWritingDataHandlerE6size_t"></span><span id="_CPPv2N6imebra10MutableTag21getWritingDataHandlerE6size_t"></span><span id="imebra::MutableTag::getWritingDataHandler__s"></span><span class="target" id="classimebra_1_1_mutable_tag_1a801856e40f0d2d00ec18177bf1f688f6"></span><a class="reference internal" href="#_CPPv4N6imebra18WritingDataHandlerE" title="imebra::WritingDataHandler">WritingDataHandler</a> <code class="sig-name descname">getWritingDataHandler</code><span class="sig-paren">(</span>size_t <em>bufferId</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N6imebra10MutableTag21getWritingDataHandlerE6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Retrieve a <a class="reference internal" href="#classimebra_1_1_writing_data_handler"><span class="std std-ref">WritingDataHandler</span></a> object connected to a specific tag’s buffer. </p>
<p>If the specified <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a> does not exist then it creates a new tag with the VR specified in the tagVR parameter</p>
<p>The returned <a class="reference internal" href="#classimebra_1_1_writing_data_handler"><span class="std std-ref">WritingDataHandler</span></a> is connected to a new buffer which is updated and stored in the tag when <a class="reference internal" href="#classimebra_1_1_writing_data_handler"><span class="std std-ref">WritingDataHandler</span></a> is destroyed.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>a <a class="reference internal" href="#classimebra_1_1_writing_data_handler"><span class="std std-ref">WritingDataHandler</span></a> object connected to a new <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a>’s buffer </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">bufferId</span></code>: the position where the new buffer has to be stored into the tag. The first buffer position is 0 </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N6imebra10MutableTag28getWritingDataHandlerNumericE6size_t">
<span id="_CPPv3N6imebra10MutableTag28getWritingDataHandlerNumericE6size_t"></span><span id="_CPPv2N6imebra10MutableTag28getWritingDataHandlerNumericE6size_t"></span><span id="imebra::MutableTag::getWritingDataHandlerNumeric__s"></span><span class="target" id="classimebra_1_1_mutable_tag_1a5faf3ad33421ecc4beca80c0c6ff19ad"></span><a class="reference internal" href="#_CPPv4N6imebra25WritingDataHandlerNumericE" title="imebra::WritingDataHandlerNumeric">WritingDataHandlerNumeric</a> <code class="sig-name descname">getWritingDataHandlerNumeric</code><span class="sig-paren">(</span>size_t <em>bufferId</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N6imebra10MutableTag28getWritingDataHandlerNumericE6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Retrieve a <a class="reference internal" href="#classimebra_1_1_writing_data_handler_numeric"><span class="std std-ref">WritingDataHandlerNumeric</span></a> object connected to the <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a>’s buffer. </p>
<p>If the tag’s VR is not a numeric type then throws std::bad_cast.</p>
<p>The returned <a class="reference internal" href="#classimebra_1_1_writing_data_handler_numeric"><span class="std std-ref">WritingDataHandlerNumeric</span></a> is connected to a new buffer which is updated and stored into the tag when <a class="reference internal" href="#classimebra_1_1_writing_data_handler_numeric"><span class="std std-ref">WritingDataHandlerNumeric</span></a> is destroyed.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>a <a class="reference internal" href="#classimebra_1_1_writing_data_handler_numeric"><span class="std std-ref">WritingDataHandlerNumeric</span></a> object connected to a new <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a>’s buffer </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">bufferId</span></code>: the position where the new buffer has to be stored in the tag. The first buffer position is 0 </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N6imebra10MutableTag24getWritingDataHandlerRawE6size_t">
<span id="_CPPv3N6imebra10MutableTag24getWritingDataHandlerRawE6size_t"></span><span id="_CPPv2N6imebra10MutableTag24getWritingDataHandlerRawE6size_t"></span><span id="imebra::MutableTag::getWritingDataHandlerRaw__s"></span><span class="target" id="classimebra_1_1_mutable_tag_1a1d6002fea9f4cb24a7a1cec768a467ab"></span><a class="reference internal" href="#_CPPv4N6imebra25WritingDataHandlerNumericE" title="imebra::WritingDataHandlerNumeric">WritingDataHandlerNumeric</a> <code class="sig-name descname">getWritingDataHandlerRaw</code><span class="sig-paren">(</span>size_t <em>bufferId</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N6imebra10MutableTag24getWritingDataHandlerRawE6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Retrieve a <a class="reference internal" href="#classimebra_1_1_writing_data_handler_numeric"><span class="std std-ref">WritingDataHandlerNumeric</span></a> object connected to the <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a>’s raw data buffer (8 bit unsigned integers). </p>
<p>If the tag’s VR is not a numeric type then throws std::bad_cast.</p>
<p>The returned <a class="reference internal" href="#classimebra_1_1_writing_data_handler_numeric"><span class="std std-ref">WritingDataHandlerNumeric</span></a> is connected to a new buffer which is updated and stored into the tag when <a class="reference internal" href="#classimebra_1_1_writing_data_handler_numeric"><span class="std std-ref">WritingDataHandlerNumeric</span></a> is destroyed.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>a <a class="reference internal" href="#classimebra_1_1_writing_data_handler_numeric"><span class="std std-ref">WritingDataHandlerNumeric</span></a> object connected to a new <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a>’s buffer (the buffer contains raw data of 8 bit integers) </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">bufferId</span></code>: the position where the new buffer has to be stored in the tag. The first buffer position is 0 </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N6imebra10MutableTag15getStreamWriterE6size_t">
<span id="_CPPv3N6imebra10MutableTag15getStreamWriterE6size_t"></span><span id="_CPPv2N6imebra10MutableTag15getStreamWriterE6size_t"></span><span id="imebra::MutableTag::getStreamWriter__s"></span><span class="target" id="classimebra_1_1_mutable_tag_1a59dbdd6a18a05abdda767859b83c0400"></span><a class="reference internal" href="stream_classes.html#_CPPv4N6imebra12StreamWriterE" title="imebra::StreamWriter">StreamWriter</a> <code class="sig-name descname">getStreamWriter</code><span class="sig-paren">(</span>size_t <em>bufferId</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N6imebra10MutableTag15getStreamWriterE6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get a <a class="reference internal" href="stream_classes.html#classimebra_1_1_stream_writer"><span class="std std-ref">StreamWriter</span></a> connected to a buffer’s data. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the <a class="reference internal" href="stream_classes.html#classimebra_1_1_stream_writer"><span class="std std-ref">StreamWriter</span></a> connected to the buffer’s data. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">bufferId</span></code>: the id of the buffer for which the <a class="reference internal" href="stream_classes.html#classimebra_1_1_stream_writer"><span class="std std-ref">StreamWriter</span></a> is required. This parameter is usually 0 </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N6imebra10MutableTag18appendSequenceItemEv">
<span id="_CPPv3N6imebra10MutableTag18appendSequenceItemEv"></span><span id="_CPPv2N6imebra10MutableTag18appendSequenceItemEv"></span><span id="imebra::MutableTag::appendSequenceItem"></span><span class="target" id="classimebra_1_1_mutable_tag_1a3c8d3cbc42d4b564e2b31ff68aeb8995"></span><a class="reference internal" href="#_CPPv4N6imebra14MutableDataSetE" title="imebra::MutableDataSet">MutableDataSet</a> <code class="sig-name descname">appendSequenceItem</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N6imebra10MutableTag18appendSequenceItemEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Append a sequence item into the <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a>. </p>
<p>Several sequence items can be nested one inside each other. When a sequence item is embedded into a <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a>, then the tag will have a sequence VR (VR = SQ).</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the <a class="reference internal" href="#classimebra_1_1_mutable_data_set"><span class="std std-ref">MutableDataSet</span></a> representing the added sequence item </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N6imebra10MutableTag9setStreamE6size_tR15FileStreamInput">
<span id="_CPPv3N6imebra10MutableTag9setStreamE6size_tR15FileStreamInput"></span><span id="_CPPv2N6imebra10MutableTag9setStreamE6size_tR15FileStreamInput"></span><span id="imebra::MutableTag::setStream__s.FileStreamInputR"></span><span class="target" id="classimebra_1_1_mutable_tag_1a08ac23bda23df1bf56233d1f1a864d8e"></span>void <code class="sig-name descname">setStream</code><span class="sig-paren">(</span>size_t <em>bufferId</em>, <a class="reference internal" href="stream_classes.html#_CPPv4N6imebra15FileStreamInputE" title="imebra::FileStreamInput">FileStreamInput</a> &amp;<em>streamInput</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N6imebra10MutableTag9setStreamE6size_tR15FileStreamInput" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Set the tag’s content to the content of a file. </p>
<p>The tag will just keep a reference to the file content.</p>
<p>This is useful when embedding large objects into a dataset (e.g. a MPEG file acquired by the device).</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">bufferId</span></code>: the id of the buffer to which the content is added </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">streamInput</span></code>: the file into which the tag’s content is stored </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</div>
<div class="section" id="id10">
<h4>Objective-C/Swift<a class="headerlink" href="#id10" title="Permalink to this headline">¶</a></h4>
<dl class="class">
<dt id="_CPPv416ImebraMutableTag">
<span id="_CPPv316ImebraMutableTag"></span><span id="_CPPv216ImebraMutableTag"></span><span id="ImebraMutableTag"></span><span class="target" id="interface_imebra_mutable_tag"></span><em class="property">class </em><code class="sig-name descname">ImebraMutableTag</code> : <em class="property">public</em> <a class="reference internal" href="#_CPPv49ImebraTag" title="ImebraTag">ImebraTag</a><a class="headerlink" href="#_CPPv416ImebraMutableTag" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This class represents a DICOM tag. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt>
<span class="target" id="interface_imebra_mutable_tag_1a27f27335b3d78947d4b18c934e7f6aa2"></span><code class="sig-name descname">ImebraWritingDataHandler* ImebraMutableTag::getWritingDataHandler:error:(unsigned int bufferId, NSError ** pError)</code></dt>
<dd><p>Retrieve a <a class="reference internal" href="#interface_imebra_writing_data_handler"><span class="std std-ref">ImebraWritingDataHandler</span></a> object connected to a specific tag’s buffer. </p>
<p>If the specified buffer does not exist then it creates a new buffer.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>a <a class="reference internal" href="#interface_imebra_writing_data_handler"><span class="std std-ref">ImebraWritingDataHandler</span></a> object connected to a new tag’s buffer </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">bufferId</span></code>: the position where the new buffer has to be stored into the tag. The first buffer position is 0 </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pError</span></code>: set to a NSError derived class in case of error </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_mutable_tag_1a03c565ea48f3775a618beb3cd2e0528a"></span><code class="sig-name descname">ImebraWritingDataHandlerNumeric* ImebraMutableTag::getWritingDataHandlerNumeric:error:(unsigned int bufferId, NSError ** pError)</code></dt>
<dd><p>Retrieve a WritingDataHandlerNumeric object connected to the Tag’s buffer. </p>
<p>If the tag’s VR is not a numeric type then throws std::bad_cast.</p>
<p>The returned WritingDataHandlerNumeric is connected to a new buffer which is updated and stored into the tag when WritingDataHandlerNumeric is destroyed.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>a WritingDataHandlerNumeric object connected to a new Tag’s buffer </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">bufferId</span></code>: the position where the new buffer has to be stored in the tag. The first buffer position is 0 </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pError</span></code>: set to a NSError derived class in case of error </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_mutable_tag_1a7df2c747fc08d693f349241229dac3e2"></span><code class="sig-name descname">ImebraWritingDataHandlerNumeric* ImebraMutableTag::getWritingDataHandlerRaw:error:(unsigned int bufferId, NSError ** pError)</code></dt>
<dd><p>Retrieve a WritingDataHandlerNumeric object connected to the Tag’s raw data buffer (8 bit unsigned integers). </p>
<p>If the tag’s VR is not a numeric type then throws std::bad_cast.</p>
<p>The returned WritingDataHandlerNumeric is connected to a new buffer which is updated and stored into the tag when WritingDataHandlerNumeric is destroyed.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>a WritingDataHandlerNumeric object connected to a new Tag’s buffer (the buffer contains raw data of 8 bit integers) </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">bufferId</span></code>: the position where the new buffer has to be stored in the tag. The first buffer position is 0 </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pError</span></code>: set to a NSError derived class in case of error </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_mutable_tag_1a8d76ffc8445433f9a8f81ace004d3275"></span><code class="sig-name descname">ImebraStreamWriter* ImebraMutableTag::getStreamWriter:error:(unsigned int bufferId, NSError ** pError)</code></dt>
<dd><p>Get a StreamWriter connected to a buffer’s data. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the StreamWriter connected to the buffer’s data. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">bufferId</span></code>: the id of the buffer for which the StreamWriter is required. This parameter is usually 0 </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pError</span></code>: set to a NSError derived class in case of error </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_mutable_tag_1a264a74e8fa816596c3b7e6abb0bfb66c"></span><code class="sig-name descname">ImebraMutableDataSet* ImebraMutableTag::appendSequenceItem:((swift_error(nonnull_error)) __attribute__)</code></dt>
<dd><p>Append a sequence item into the Tag. </p>
<p>Several sequence items can be nested one inside each other. When a sequence item is embedded into a Tag, then the tag will have a sequence VR (VR = SQ).</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>a MutableDataSet representing the added sequence item </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pError</span></code>: set to a NSError derived class in case of error </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_mutable_tag_1a5d7e49bd6126a23ab6e2ae1f5489cd27"></span><code class="sig-name descname">void ImebraMutableTag::setStream:stream:error:(unsigned int bufferId, ImebraFileStreamInput  * pStream, NSError ** pError)</code></dt>
<dd><p>Set the tag’s content to the content of a file. </p>
<p>The tag will just keep a reference to the file content.</p>
<p>This is useful when embedding large objects into a dataset (e.g. a MPEG file acquired by the device).</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">bufferId</span></code>: the id of the buffer to which the content is added </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">streamInput</span></code>: the file into which the tag’s content is stored </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</div>
</div>
</div>
<div class="section" id="data-access">
<h2>Data access<a class="headerlink" href="#data-access" title="Permalink to this headline">¶</a></h2>
<p>The data handler allow to read and write the data stored in the tags.</p>
<p>In order to write data into a tag you can:</p>
<ul class="simple">
<li><p>use the helper methods in <a class="reference internal" href="#dataset"><span class="std std-ref">DataSet</span></a></p></li>
<li><p>obtain a <a class="reference internal" href="#writingdatahandler"><span class="std std-ref">WritingDataHandler</span></a> for the desidered tag and use it to write the data.</p></li>
</ul>
<p>The <a class="reference internal" href="#writingdatahandler"><span class="std std-ref">WritingDataHandler</span></a> has the advantage of being able to write multiple elements in the <a class="reference internal" href="#tag"><span class="std std-ref">Tag</span></a>, while
the helper methods in the <a class="reference internal" href="#dataset"><span class="std std-ref">DataSet</span></a> can write only the first element.</p>
<p>The <a class="reference internal" href="#writingdatahandler"><span class="std std-ref">WritingDataHandler</span></a> writes all the data into a new buffer, which replaces the old buffer in the <a class="reference internal" href="#tag"><span class="std std-ref">Tag</span></a>
only when the data handler is deleted.</p>
<div class="figure align-default" id="id35" style="width: 100%">
<a class="reference external image-reference" href="_images/sequence_createDataWithDataHandler.jpg"><img alt="Data related classes" src="_images/sequence_createDataWithDataHandler.jpg" /></a>
<p class="caption"><span class="caption-text">Sequence diagram showing how to use a <a class="reference internal" href="#writingdatahandler"><span class="std std-ref">WritingDataHandler</span></a></span><a class="headerlink" href="#id35" title="Permalink to this image">¶</a></p>
</div>
<div class="section" id="tagid">
<span id="id11"></span><h3>TagId<a class="headerlink" href="#tagid" title="Permalink to this headline">¶</a></h3>
<div class="section" id="id12">
<h4>C++<a class="headerlink" href="#id12" title="Permalink to this headline">¶</a></h4>
<dl class="class">
<dt id="_CPPv4N6imebra5TagIdE">
<span id="_CPPv3N6imebra5TagIdE"></span><span id="_CPPv2N6imebra5TagIdE"></span><span id="imebra::TagId"></span><span class="target" id="classimebra_1_1_tag_id"></span><em class="property">class </em><code class="sig-name descname">TagId</code><a class="headerlink" href="#_CPPv4N6imebra5TagIdE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Represents a Dicom tag’s identification. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv4N6imebra5TagId5TagIdEv">
<span id="_CPPv3N6imebra5TagId5TagIdEv"></span><span id="_CPPv2N6imebra5TagId5TagIdEv"></span><span id="imebra::TagId::TagId"></span><span class="target" id="classimebra_1_1_tag_id_1a0f6f102237de0448186e304dd08901b4"></span><code class="sig-name descname">TagId</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N6imebra5TagId5TagIdEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Default constructor. </p>
<p>Initializes the group id and the tag id to 0. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N6imebra5TagId5TagIdENSt8uint16_tENSt8uint16_tE">
<span id="_CPPv3N6imebra5TagId5TagIdENSt8uint16_tENSt8uint16_tE"></span><span id="_CPPv2N6imebra5TagId5TagIdENSt8uint16_tENSt8uint16_tE"></span><span id="imebra::TagId::TagId__std::uint16_t.std::uint16_t"></span><span class="target" id="classimebra_1_1_tag_id_1a75bd191ce3e71c55ecc90636a8ce58df"></span><code class="sig-name descname">TagId</code><span class="sig-paren">(</span>std::uint16_t <em>groupId</em>, std::uint16_t <em>tagId</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N6imebra5TagId5TagIdENSt8uint16_tENSt8uint16_tE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Constructor. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">groupId</span></code>: the group id </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag id </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N6imebra5TagId5TagIdENSt8uint16_tENSt8uint32_tENSt8uint16_tE">
<span id="_CPPv3N6imebra5TagId5TagIdENSt8uint16_tENSt8uint32_tENSt8uint16_tE"></span><span id="_CPPv2N6imebra5TagId5TagIdENSt8uint16_tENSt8uint32_tENSt8uint16_tE"></span><span id="imebra::TagId::TagId__std::uint16_t.std::uint32_t.std::uint16_t"></span><span class="target" id="classimebra_1_1_tag_id_1a0a5f5ddfa7726cf777087b17d6204e8b"></span><code class="sig-name descname">TagId</code><span class="sig-paren">(</span>std::uint16_t <em>groupId</em>, std::uint32_t <em>groupOrder</em>, std::uint16_t <em>tagId</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N6imebra5TagId5TagIdENSt8uint16_tENSt8uint32_tENSt8uint16_tE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Constructor. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">groupId</span></code>: the group id </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">groupOrder</span></code>: old DICOM files may have several groups with the same id. This parameter specifies which of the groups with the same id must be taken into consideration </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag id </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N6imebra5TagId5TagIdE7tagId_t">
<span id="_CPPv3N6imebra5TagId5TagIdE7tagId_t"></span><span id="_CPPv2N6imebra5TagId5TagIdE7tagId_t"></span><span id="imebra::TagId::TagId__tagId_t"></span><span class="target" id="classimebra_1_1_tag_id_1ad19878723a6f0c8234c56d108e891fad"></span><code class="sig-name descname">TagId</code><span class="sig-paren">(</span><a class="reference internal" href="definition_classes.html#_CPPv4N6imebra7tagId_tE" title="imebra::tagId_t">tagId_t</a> <em>id</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N6imebra5TagId5TagIdE7tagId_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Constructor. </p>
<p><dl class="simple">
<dt><strong>Warning</strong></dt><dd><p>Very large enumeration classes cause an error in Java, therefore the tagId_t enumeration is not supported in Java. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">id</span></code>: an enumeration representing a tag group and id</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N6imebra5TagId5TagIdE7tagId_tNSt8uint32_tE">
<span id="_CPPv3N6imebra5TagId5TagIdE7tagId_tNSt8uint32_tE"></span><span id="_CPPv2N6imebra5TagId5TagIdE7tagId_tNSt8uint32_tE"></span><span id="imebra::TagId::TagId__tagId_t.std::uint32_t"></span><span class="target" id="classimebra_1_1_tag_id_1ad2a33774c78d73e060d535d00739140e"></span><code class="sig-name descname">TagId</code><span class="sig-paren">(</span><a class="reference internal" href="definition_classes.html#_CPPv4N6imebra7tagId_tE" title="imebra::tagId_t">tagId_t</a> <em>id</em>, std::uint32_t <em>groupOrder</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N6imebra5TagId5TagIdE7tagId_tNSt8uint32_tE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Constructor. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">id</span></code>: an enumeration representing a tag group and id </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">groupOrder</span></code>: old DICOM files may have several groups with the same id. This parameter specifies which of the groups with the same id must be taken into consideration </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK6imebra5TagId10getGroupIdEv">
<span id="_CPPv3NK6imebra5TagId10getGroupIdEv"></span><span id="_CPPv2NK6imebra5TagId10getGroupIdEv"></span><span id="imebra::TagId::getGroupIdC"></span><span class="target" id="classimebra_1_1_tag_id_1aba2275b649f6882a9767931dd1b32df7"></span>std::uint16_t <code class="sig-name descname">getGroupId</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK6imebra5TagId10getGroupIdEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Retrieve the group id. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the group id </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK6imebra5TagId13getGroupOrderEv">
<span id="_CPPv3NK6imebra5TagId13getGroupOrderEv"></span><span id="_CPPv2NK6imebra5TagId13getGroupOrderEv"></span><span id="imebra::TagId::getGroupOrderC"></span><span class="target" id="classimebra_1_1_tag_id_1a6bf581615bbe8d2c868166bc4fbb7aa8"></span>std::uint32_t <code class="sig-name descname">getGroupOrder</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK6imebra5TagId13getGroupOrderEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return the group order. Old DICOM files may have several groups with the same id. This value specifies which of the groups with the same id has been taken into consideration. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the group order </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK6imebra5TagId8getTagIdEv">
<span id="_CPPv3NK6imebra5TagId8getTagIdEv"></span><span id="_CPPv2NK6imebra5TagId8getTagIdEv"></span><span id="imebra::TagId::getTagIdC"></span><span class="target" id="classimebra_1_1_tag_id_1ade25b4abec432fdc46bb58d29eafa110"></span>std::uint16_t <code class="sig-name descname">getTagId</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK6imebra5TagId8getTagIdEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Retrieve the tag id. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the tag id </p>
</dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</div>
<div class="section" id="id13">
<h4>Objective-C/Swift<a class="headerlink" href="#id13" title="Permalink to this headline">¶</a></h4>
<dl class="class">
<dt id="_CPPv411ImebraTagId">
<span id="_CPPv311ImebraTagId"></span><span id="_CPPv211ImebraTagId"></span><span id="ImebraTagId"></span><span class="target" id="interface_imebra_tag_id"></span><em class="property">class </em><code class="sig-name descname">ImebraTagId</code> : <em class="property">public</em> NSObject<a class="headerlink" href="#_CPPv411ImebraTagId" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Represents a Dicom tag’s identification. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt>
<span class="target" id="interface_imebra_tag_id_1a5fe70bbf47f8db18759dbc4914c6fb03"></span><code class="sig-name descname">id ImebraTagId::initWithGroup:tag:(unsigned short groupId, unsigned short tagId)</code></dt>
<dd><p>Initializer. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">groupId</span></code>: the group id </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag id </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_tag_id_1a9f8e44cfc9c9747947af00c4f2c5e7e9"></span><code class="sig-name descname">id ImebraTagId::initWithId:(ImebraTagEnum tagId)</code></dt>
<dd><p>Initializer. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">id</span></code>: an enumeration representing a tag group and id </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_tag_id_1a560adb387a4fdf4d0f835abbb9b6ad39"></span><code class="sig-name descname">id ImebraTagId::initWithGroup:groupOrder:tag:(unsigned short groupId, unsigned int groupOrder, unsigned short tagId)</code></dt>
<dd><p>Initializer. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">groupId</span></code>: the group id </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">groupOrder</span></code>: old DICOM files may have several groups with the same id. This parameter specifies which of the groups with the same id must be taken into consideration </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag id </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Property</p>
<dl class="member">
<dt>
<span class="target" id="interface_imebra_tag_id_1acdf1c9bda91541a319ec8dab12fb5f54"></span><em class="property">property </em><code class="sig-name descname">ImebraTagId::groupId</code></dt>
<dd><p>Retrieve the group id. </p>
</dd></dl>

<dl class="member">
<dt>
<span class="target" id="interface_imebra_tag_id_1a2130a740d4c86c17102e6e2088b29ecd"></span><em class="property">property </em><code class="sig-name descname">ImebraTagId::groupOrder</code></dt>
<dd><p>Return the group order. Old DICOM files may have several groups with the same id. This value specifies which of the groups with the same id has been taken into consideration. </p>
</dd></dl>

<dl class="member">
<dt>
<span class="target" id="interface_imebra_tag_id_1a62cfb64e0ec05aa883a2ab54fc02083e"></span><em class="property">property </em><code class="sig-name descname">ImebraTagId::tagId</code></dt>
<dd><p>Retrieve the tag id. </p>
</dd></dl>

</div>
</dd></dl>

</div>
</div>
<div class="section" id="readingdatahandler">
<span id="id14"></span><h3>ReadingDataHandler<a class="headerlink" href="#readingdatahandler" title="Permalink to this headline">¶</a></h3>
<div class="section" id="id15">
<h4>C++<a class="headerlink" href="#id15" title="Permalink to this headline">¶</a></h4>
<dl class="class">
<dt id="_CPPv4N6imebra18ReadingDataHandlerE">
<span id="_CPPv3N6imebra18ReadingDataHandlerE"></span><span id="_CPPv2N6imebra18ReadingDataHandlerE"></span><span id="imebra::ReadingDataHandler"></span><span class="target" id="classimebra_1_1_reading_data_handler"></span><em class="property">class </em><code class="sig-name descname">ReadingDataHandler</code><a class="headerlink" href="#_CPPv4N6imebra18ReadingDataHandlerE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The <a class="reference internal" href="#classimebra_1_1_reading_data_handler"><span class="std std-ref">ReadingDataHandler</span></a> class allows reading the content of a Dicom <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a>. </p>
<p><a class="reference internal" href="#classimebra_1_1_reading_data_handler"><span class="std std-ref">ReadingDataHandler</span></a> is able to return the <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a>’s content as a string, a number, a date/time or an age.</p>
<p>In order to obtain a <a class="reference internal" href="#classimebra_1_1_reading_data_handler"><span class="std std-ref">ReadingDataHandler</span></a> object for a specific <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a> stored in a <a class="reference internal" href="#classimebra_1_1_data_set"><span class="std std-ref">DataSet</span></a>, call <a class="reference internal" href="#classimebra_1_1_data_set_1a28ac2de1400b6a8c40762a687d27292b"><span class="std std-ref">DataSet::getReadingDataHandler()</span></a> or <a class="reference internal" href="#classimebra_1_1_tag_1ab65f0621e9f94ce6d81413aa9b7af63e"><span class="std std-ref">Tag::getReadingDataHandler()</span></a>.</p>
<p>The <a class="reference internal" href="#classimebra_1_1_reading_data_handler"><span class="std std-ref">ReadingDataHandler</span></a> object keeps a reference to the buffer’s memory: the buffer’s memory is never modified but only replaced by a new memory area, therefore the <a class="reference internal" href="#classimebra_1_1_reading_data_handler"><span class="std std-ref">ReadingDataHandler</span></a> client does not need to worry about other clients modifying the memory being read. </p>
<p>Subclassed by <a class="reference internal" href="#classimebra_1_1_reading_data_handler_numeric"><span class="std std-ref">imebra::ReadingDataHandlerNumeric</span></a></p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv4N6imebra18ReadingDataHandler18ReadingDataHandlerERK18ReadingDataHandler">
<span id="_CPPv3N6imebra18ReadingDataHandler18ReadingDataHandlerERK18ReadingDataHandler"></span><span id="_CPPv2N6imebra18ReadingDataHandler18ReadingDataHandlerERK18ReadingDataHandler"></span><span id="imebra::ReadingDataHandler::ReadingDataHandler__ReadingDataHandlerCR"></span><span class="target" id="classimebra_1_1_reading_data_handler_1a1f8a58aeac30aad14195f6a49aa368b2"></span><code class="sig-name descname">ReadingDataHandler</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N6imebra18ReadingDataHandler18ReadingDataHandlerERK18ReadingDataHandler" title="imebra::ReadingDataHandler::ReadingDataHandler">ReadingDataHandler</a> &amp;<em>source</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N6imebra18ReadingDataHandler18ReadingDataHandlerERK18ReadingDataHandler" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Copy constructor. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">source</span></code>: source <a class="reference internal" href="#classimebra_1_1_reading_data_handler"><span class="std std-ref">ReadingDataHandler</span></a> object </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK6imebra18ReadingDataHandler7getSizeEv">
<span id="_CPPv3NK6imebra18ReadingDataHandler7getSizeEv"></span><span id="_CPPv2NK6imebra18ReadingDataHandler7getSizeEv"></span><span id="imebra::ReadingDataHandler::getSizeC"></span><span class="target" id="classimebra_1_1_reading_data_handler_1a2d8cfaedeaa9052c9ad9f4cdbe953db7"></span>size_t <code class="sig-name descname">getSize</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK6imebra18ReadingDataHandler7getSizeEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns the number of elements in the <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a>’s buffer handled by the data handler. </p>
<p>If the <a class="reference internal" href="#classimebra_1_1_reading_data_handler"><span class="std std-ref">ReadingDataHandler</span></a> object is related to a buffer that contains strings then it returns the number of strings stored in the buffer. Multiple strings are separated by a separator char.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the number of elements stored in the handled Dicom buffer </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK6imebra18ReadingDataHandler11getDataTypeEv">
<span id="_CPPv3NK6imebra18ReadingDataHandler11getDataTypeEv"></span><span id="_CPPv2NK6imebra18ReadingDataHandler11getDataTypeEv"></span><span id="imebra::ReadingDataHandler::getDataTypeC"></span><span class="target" id="classimebra_1_1_reading_data_handler_1a345ae68bc9b71ef7de082143981b27f0"></span><a class="reference internal" href="definition_classes.html#_CPPv4N6imebra7tagVR_tE" title="imebra::tagVR_t">tagVR_t</a> <code class="sig-name descname">getDataType</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK6imebra18ReadingDataHandler11getDataTypeEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns the data type (VR) of the data handled by the data handler. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the data type of the handled data </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK6imebra18ReadingDataHandler8getInt32E6size_t">
<span id="_CPPv3NK6imebra18ReadingDataHandler8getInt32E6size_t"></span><span id="_CPPv2NK6imebra18ReadingDataHandler8getInt32E6size_t"></span><span id="imebra::ReadingDataHandler::getInt32__sC"></span><span class="target" id="classimebra_1_1_reading_data_handler_1a7c6f38376c0642b3f6e9d5e09953062a"></span>std::int32_t <code class="sig-name descname">getInt32</code><span class="sig-paren">(</span>size_t <em>index</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK6imebra18ReadingDataHandler8getInt32E6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Retrieve a buffer’s value as signed long integer (32 bit). </p>
<p>If the buffer’s value cannot be converted to a signed long integer then throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_data_handler_conversion_error"><span class="std std-ref">DataHandlerConversionError</span></a>.</p>
<p>Throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_missing_item_error"><span class="std std-ref">MissingItemError</span></a> if the requested index does not exist.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the tag’s value as a signed 32 bit integer </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">index</span></code>: the element number within the buffer. Must be smaller than <a class="reference internal" href="#classimebra_1_1_reading_data_handler_1a2d8cfaedeaa9052c9ad9f4cdbe953db7"><span class="std std-ref">getSize()</span></a> </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK6imebra18ReadingDataHandler13getSignedLongE6size_t">
<span id="_CPPv3NK6imebra18ReadingDataHandler13getSignedLongE6size_t"></span><span id="_CPPv2NK6imebra18ReadingDataHandler13getSignedLongE6size_t"></span><span id="imebra::ReadingDataHandler::getSignedLong__sC"></span><span class="target" id="classimebra_1_1_reading_data_handler_1a8b5be6aa4f7ef32f3ed8b0f036ea7ba2"></span>std::int32_t <code class="sig-name descname">getSignedLong</code><span class="sig-paren">(</span>size_t <em>index</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK6imebra18ReadingDataHandler13getSignedLongE6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Deprecated. Use <a class="reference internal" href="#classimebra_1_1_reading_data_handler_1a7c6f38376c0642b3f6e9d5e09953062a"><span class="std std-ref">getInt32()</span></a> instead. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK6imebra18ReadingDataHandler9getUint32E6size_t">
<span id="_CPPv3NK6imebra18ReadingDataHandler9getUint32E6size_t"></span><span id="_CPPv2NK6imebra18ReadingDataHandler9getUint32E6size_t"></span><span id="imebra::ReadingDataHandler::getUint32__sC"></span><span class="target" id="classimebra_1_1_reading_data_handler_1a3d2781a8654d3d2ff9861067ed3590a2"></span>std::uint32_t <code class="sig-name descname">getUint32</code><span class="sig-paren">(</span>size_t <em>index</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK6imebra18ReadingDataHandler9getUint32E6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Retrieve a buffer’s value as an unsigned long integer (32 bit). </p>
<p>When calling <a class="reference internal" href="#classimebra_1_1_reading_data_handler_1a3d2781a8654d3d2ff9861067ed3590a2"><span class="std std-ref">getUint32()</span></a> on an AT tag (Attribute <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a>) then the tag group is always in the high word of the returned value.</p>
<p>If the buffer’s value cannot be converted to an unsigned long integer then throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_data_handler_conversion_error"><span class="std std-ref">DataHandlerConversionError</span></a>.</p>
<p>Throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_missing_item_error"><span class="std std-ref">MissingItemError</span></a> if the requested index does not exist.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the tag’s value as an unsigned 32 bit integer </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">index</span></code>: the element number within the buffer. Must be smaller than <a class="reference internal" href="#classimebra_1_1_reading_data_handler_1a2d8cfaedeaa9052c9ad9f4cdbe953db7"><span class="std std-ref">getSize()</span></a> </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK6imebra18ReadingDataHandler15getUnsignedLongE6size_t">
<span id="_CPPv3NK6imebra18ReadingDataHandler15getUnsignedLongE6size_t"></span><span id="_CPPv2NK6imebra18ReadingDataHandler15getUnsignedLongE6size_t"></span><span id="imebra::ReadingDataHandler::getUnsignedLong__sC"></span><span class="target" id="classimebra_1_1_reading_data_handler_1ad28111aa707511a2a18a1d5a831e4ec4"></span>std::uint32_t <code class="sig-name descname">getUnsignedLong</code><span class="sig-paren">(</span>size_t <em>index</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK6imebra18ReadingDataHandler15getUnsignedLongE6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Deprecated. Use <a class="reference internal" href="#classimebra_1_1_reading_data_handler_1a3d2781a8654d3d2ff9861067ed3590a2"><span class="std std-ref">getUint32()</span></a> instead. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK6imebra18ReadingDataHandler8getInt16E6size_t">
<span id="_CPPv3NK6imebra18ReadingDataHandler8getInt16E6size_t"></span><span id="_CPPv2NK6imebra18ReadingDataHandler8getInt16E6size_t"></span><span id="imebra::ReadingDataHandler::getInt16__sC"></span><span class="target" id="classimebra_1_1_reading_data_handler_1ac419deed06c52532158fbdcab1e0da20"></span>std::int16_t <code class="sig-name descname">getInt16</code><span class="sig-paren">(</span>size_t <em>index</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK6imebra18ReadingDataHandler8getInt16E6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Retrieve a buffer’s value as signed long integer (16 bit). </p>
<p>If the buffer’s value cannot be converted to a signed long integer then throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_data_handler_conversion_error"><span class="std std-ref">DataHandlerConversionError</span></a>.</p>
<p>Throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_missing_item_error"><span class="std std-ref">MissingItemError</span></a> if the requested index does not exist.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the tag’s value as a signed 32 bit integer </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">index</span></code>: the element number within the buffer. Must be smaller than <a class="reference internal" href="#classimebra_1_1_reading_data_handler_1a2d8cfaedeaa9052c9ad9f4cdbe953db7"><span class="std std-ref">getSize()</span></a> </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK6imebra18ReadingDataHandler9getUint16E6size_t">
<span id="_CPPv3NK6imebra18ReadingDataHandler9getUint16E6size_t"></span><span id="_CPPv2NK6imebra18ReadingDataHandler9getUint16E6size_t"></span><span id="imebra::ReadingDataHandler::getUint16__sC"></span><span class="target" id="classimebra_1_1_reading_data_handler_1aa9c7d416342759cc5356c69ea10fec94"></span>std::uint16_t <code class="sig-name descname">getUint16</code><span class="sig-paren">(</span>size_t <em>index</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK6imebra18ReadingDataHandler9getUint16E6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Retrieve a buffer’s value as an unsigned long integer (16 bit). </p>
<p>If the buffer’s value cannot be converted to an unsigned long integer then throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_data_handler_conversion_error"><span class="std std-ref">DataHandlerConversionError</span></a>.</p>
<p>Throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_missing_item_error"><span class="std std-ref">MissingItemError</span></a> if the requested index does not exist.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the tag’s value as an unsigned 32 bit integer </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">index</span></code>: the element number within the buffer. Must be smaller than <a class="reference internal" href="#classimebra_1_1_reading_data_handler_1a2d8cfaedeaa9052c9ad9f4cdbe953db7"><span class="std std-ref">getSize()</span></a> </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK6imebra18ReadingDataHandler7getInt8E6size_t">
<span id="_CPPv3NK6imebra18ReadingDataHandler7getInt8E6size_t"></span><span id="_CPPv2NK6imebra18ReadingDataHandler7getInt8E6size_t"></span><span id="imebra::ReadingDataHandler::getInt8__sC"></span><span class="target" id="classimebra_1_1_reading_data_handler_1a9fc09c903ee84ebfbfbb0c3d45ceb316"></span>std::int8_t <code class="sig-name descname">getInt8</code><span class="sig-paren">(</span>size_t <em>index</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK6imebra18ReadingDataHandler7getInt8E6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Retrieve a buffer’s value as signed long integer (8 bit). </p>
<p>If the buffer’s value cannot be converted to a signed long integer then throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_data_handler_conversion_error"><span class="std std-ref">DataHandlerConversionError</span></a>.</p>
<p>Throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_missing_item_error"><span class="std std-ref">MissingItemError</span></a> if the requested index does not exist.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the tag’s value as a signed 32 bit integer </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">index</span></code>: the element number within the buffer. Must be smaller than <a class="reference internal" href="#classimebra_1_1_reading_data_handler_1a2d8cfaedeaa9052c9ad9f4cdbe953db7"><span class="std std-ref">getSize()</span></a> </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK6imebra18ReadingDataHandler8getUint8E6size_t">
<span id="_CPPv3NK6imebra18ReadingDataHandler8getUint8E6size_t"></span><span id="_CPPv2NK6imebra18ReadingDataHandler8getUint8E6size_t"></span><span id="imebra::ReadingDataHandler::getUint8__sC"></span><span class="target" id="classimebra_1_1_reading_data_handler_1a1071291417790b3fb04b5ca72dde864b"></span>std::uint8_t <code class="sig-name descname">getUint8</code><span class="sig-paren">(</span>size_t <em>index</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK6imebra18ReadingDataHandler8getUint8E6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Retrieve a buffer’s value as an unsigned long integer (8 bit). </p>
<p>If the buffer’s value cannot be converted to an unsigned long integer then throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_data_handler_conversion_error"><span class="std std-ref">DataHandlerConversionError</span></a>.</p>
<p>Throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_missing_item_error"><span class="std std-ref">MissingItemError</span></a> if the requested index does not exist.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the tag’s value as an unsigned 32 bit integer </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">index</span></code>: the element number within the buffer. Must be smaller than <a class="reference internal" href="#classimebra_1_1_reading_data_handler_1a2d8cfaedeaa9052c9ad9f4cdbe953db7"><span class="std std-ref">getSize()</span></a> </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK6imebra18ReadingDataHandler9getDoubleE6size_t">
<span id="_CPPv3NK6imebra18ReadingDataHandler9getDoubleE6size_t"></span><span id="_CPPv2NK6imebra18ReadingDataHandler9getDoubleE6size_t"></span><span id="imebra::ReadingDataHandler::getDouble__sC"></span><span class="target" id="classimebra_1_1_reading_data_handler_1a3115b57cf76aaff679f3a703b3c6e48b"></span>double <code class="sig-name descname">getDouble</code><span class="sig-paren">(</span>size_t <em>index</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK6imebra18ReadingDataHandler9getDoubleE6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Retrieve a buffer’s value as a double floating point value (64 bit). </p>
<p>If the buffer’s value cannot be converted to a double value then throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_data_handler_conversion_error"><span class="std std-ref">DataHandlerConversionError</span></a>.</p>
<p>Throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_missing_item_error"><span class="std std-ref">MissingItemError</span></a> if the requested index does not exist.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the tag’s value as a double floating point value (64 bit) </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">index</span></code>: the element number within the buffer. Must be smaller than <a class="reference internal" href="#classimebra_1_1_reading_data_handler_1a2d8cfaedeaa9052c9ad9f4cdbe953db7"><span class="std std-ref">getSize()</span></a> </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK6imebra18ReadingDataHandler8getFloatE6size_t">
<span id="_CPPv3NK6imebra18ReadingDataHandler8getFloatE6size_t"></span><span id="_CPPv2NK6imebra18ReadingDataHandler8getFloatE6size_t"></span><span id="imebra::ReadingDataHandler::getFloat__sC"></span><span class="target" id="classimebra_1_1_reading_data_handler_1a72516611b9f38ab20beb6b6df7b41081"></span>float <code class="sig-name descname">getFloat</code><span class="sig-paren">(</span>size_t <em>index</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK6imebra18ReadingDataHandler8getFloatE6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Retrieve a buffer’s value as a floating point value (32 bit). </p>
<p>If the buffer’s value cannot be converted to a float value then throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_data_handler_conversion_error"><span class="std std-ref">DataHandlerConversionError</span></a>.</p>
<p>Throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_missing_item_error"><span class="std std-ref">MissingItemError</span></a> if the requested index does not exist.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the tag’s value as a floating point value (32 bit) </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">index</span></code>: the element number within the buffer. Must be smaller than <a class="reference internal" href="#classimebra_1_1_reading_data_handler_1a2d8cfaedeaa9052c9ad9f4cdbe953db7"><span class="std std-ref">getSize()</span></a> </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK6imebra18ReadingDataHandler9getStringE6size_t">
<span id="_CPPv3NK6imebra18ReadingDataHandler9getStringE6size_t"></span><span id="_CPPv2NK6imebra18ReadingDataHandler9getStringE6size_t"></span><span id="imebra::ReadingDataHandler::getString__sC"></span><span class="target" id="classimebra_1_1_reading_data_handler_1a1100ec671004eb51f1cfc930b87535f6"></span>std::string <code class="sig-name descname">getString</code><span class="sig-paren">(</span>size_t <em>index</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK6imebra18ReadingDataHandler9getStringE6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Retrieve a buffer’s value as a UTF8 string. </p>
<p>If the buffer’s value cannot be converted to a string then throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_data_handler_conversion_error"><span class="std std-ref">DataHandlerConversionError</span></a>.</p>
<p>Throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_missing_item_error"><span class="std std-ref">MissingItemError</span></a> if the requested index does not exist.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the tag’s value as an ASCII string </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">index</span></code>: the element number within the buffer. Must be smaller than <a class="reference internal" href="#classimebra_1_1_reading_data_handler_1a2d8cfaedeaa9052c9ad9f4cdbe953db7"><span class="std std-ref">getSize()</span></a> </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK6imebra18ReadingDataHandler16getUnicodeStringE6size_t">
<span id="_CPPv3NK6imebra18ReadingDataHandler16getUnicodeStringE6size_t"></span><span id="_CPPv2NK6imebra18ReadingDataHandler16getUnicodeStringE6size_t"></span><span id="imebra::ReadingDataHandler::getUnicodeString__sC"></span><span class="target" id="classimebra_1_1_reading_data_handler_1ab03dc6a99a99c5ede9159357d84efa45"></span>std::wstring <code class="sig-name descname">getUnicodeString</code><span class="sig-paren">(</span>size_t <em>index</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK6imebra18ReadingDataHandler16getUnicodeStringE6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Retrieve a buffer’s value as a Unicode string. </p>
<p>If the buffer’s value cannot be converted to a string then throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_data_handler_conversion_error"><span class="std std-ref">DataHandlerConversionError</span></a>.</p>
<p>Throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_missing_item_error"><span class="std std-ref">MissingItemError</span></a> if the requested index does not exist.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the tag’s value as a Unicode string </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">index</span></code>: the element number within the buffer. Must be smaller than <a class="reference internal" href="#classimebra_1_1_reading_data_handler_1a2d8cfaedeaa9052c9ad9f4cdbe953db7"><span class="std std-ref">getSize()</span></a> </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK6imebra18ReadingDataHandler7getDateE6size_t">
<span id="_CPPv3NK6imebra18ReadingDataHandler7getDateE6size_t"></span><span id="_CPPv2NK6imebra18ReadingDataHandler7getDateE6size_t"></span><span id="imebra::ReadingDataHandler::getDate__sC"></span><span class="target" id="classimebra_1_1_reading_data_handler_1a3b2f57561d94f703a508c93c1dab2447"></span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N6imebra4DateE" title="imebra::Date">Date</a> <code class="sig-name descname">getDate</code><span class="sig-paren">(</span>size_t <em>index</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK6imebra18ReadingDataHandler7getDateE6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Retrieve a buffer’s value a date or time. </p>
<p>If the buffer’s value cannot be converted to a date or time then throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_data_handler_conversion_error"><span class="std std-ref">DataHandlerConversionError</span></a>.</p>
<p>Throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_missing_item_error"><span class="std std-ref">MissingItemError</span></a> if the requested index does not exist.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the tag’s value as a date or time </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">index</span></code>: the element number within the buffer. Must be smaller than <a class="reference internal" href="#classimebra_1_1_reading_data_handler_1a2d8cfaedeaa9052c9ad9f4cdbe953db7"><span class="std std-ref">getSize()</span></a> </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK6imebra18ReadingDataHandler6getAgeE6size_t">
<span id="_CPPv3NK6imebra18ReadingDataHandler6getAgeE6size_t"></span><span id="_CPPv2NK6imebra18ReadingDataHandler6getAgeE6size_t"></span><span id="imebra::ReadingDataHandler::getAge__sC"></span><span class="target" id="classimebra_1_1_reading_data_handler_1ae4b6c2cde544792e5e3d2e9c9f01ac15"></span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N6imebra3AgeE" title="imebra::Age">Age</a> <code class="sig-name descname">getAge</code><span class="sig-paren">(</span>size_t <em>index</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK6imebra18ReadingDataHandler6getAgeE6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Retrieve a buffer’s value as an <a class="reference internal" href="#classimebra_1_1_age"><span class="std std-ref">Age</span></a>. </p>
<p>If the buffer’s value cannot be converted to an <a class="reference internal" href="#classimebra_1_1_age"><span class="std std-ref">Age</span></a> then throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_data_handler_conversion_error"><span class="std std-ref">DataHandlerConversionError</span></a>.</p>
<p>Throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_missing_item_error"><span class="std std-ref">MissingItemError</span></a> if the requested index does not exist.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the tag’s value as an <a class="reference internal" href="#classimebra_1_1_age"><span class="std std-ref">Age</span></a> </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">index</span></code>: the element number within the buffer. Must be smaller than <a class="reference internal" href="#classimebra_1_1_reading_data_handler_1a2d8cfaedeaa9052c9ad9f4cdbe953db7"><span class="std std-ref">getSize()</span></a> </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK6imebra18ReadingDataHandler14getPatientNameE6size_t">
<span id="_CPPv3NK6imebra18ReadingDataHandler14getPatientNameE6size_t"></span><span id="_CPPv2NK6imebra18ReadingDataHandler14getPatientNameE6size_t"></span><span id="imebra::ReadingDataHandler::getPatientName__sC"></span><span class="target" id="classimebra_1_1_reading_data_handler_1a5f24bd059c41d270d5fb1f911f777568"></span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N6imebra11PatientNameE" title="imebra::PatientName">PatientName</a> <code class="sig-name descname">getPatientName</code><span class="sig-paren">(</span>size_t <em>index</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK6imebra18ReadingDataHandler14getPatientNameE6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Retrieve a tag’s value as a Patient Name. </p>
<p>If the tag’s value cannot be converted to a patient name then throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_data_handler_conversion_error"><span class="std std-ref">DataHandlerConversionError</span></a>.</p>
<p>Throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_missing_item_error"><span class="std std-ref">MissingItemError</span></a> if the requested index does not exist.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the tag’s value as a Patient Name </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">index</span></code>: the element number within the buffer. Must be smaller than <a class="reference internal" href="#classimebra_1_1_reading_data_handler_1a2d8cfaedeaa9052c9ad9f4cdbe953db7"><span class="std std-ref">getSize()</span></a> </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK6imebra18ReadingDataHandler21getUnicodePatientNameE6size_t">
<span id="_CPPv3NK6imebra18ReadingDataHandler21getUnicodePatientNameE6size_t"></span><span id="_CPPv2NK6imebra18ReadingDataHandler21getUnicodePatientNameE6size_t"></span><span id="imebra::ReadingDataHandler::getUnicodePatientName__sC"></span><span class="target" id="classimebra_1_1_reading_data_handler_1a11251c21489b0ee48bbdd098c53930e0"></span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N6imebra18UnicodePatientNameE" title="imebra::UnicodePatientName">UnicodePatientName</a> <code class="sig-name descname">getUnicodePatientName</code><span class="sig-paren">(</span>size_t <em>index</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK6imebra18ReadingDataHandler21getUnicodePatientNameE6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Retrieve a tag’s value as a Unicode Patient Name. </p>
<p>If the tag’s value cannot be converted to a patient name then throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_data_handler_conversion_error"><span class="std std-ref">DataHandlerConversionError</span></a>.</p>
<p>Throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_missing_item_error"><span class="std std-ref">MissingItemError</span></a> if the requested index does not exist.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the tag’s value as a Unicode Patient Name </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">index</span></code>: the element number within the buffer. Must be smaller than <a class="reference internal" href="#classimebra_1_1_reading_data_handler_1a2d8cfaedeaa9052c9ad9f4cdbe953db7"><span class="std std-ref">getSize()</span></a> </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</div>
<div class="section" id="id16">
<h4>Objective-C/Swift<a class="headerlink" href="#id16" title="Permalink to this headline">¶</a></h4>
<dl class="class">
<dt id="_CPPv424ImebraReadingDataHandler">
<span id="_CPPv324ImebraReadingDataHandler"></span><span id="_CPPv224ImebraReadingDataHandler"></span><span id="ImebraReadingDataHandler"></span><span class="target" id="interface_imebra_reading_data_handler"></span><em class="property">class </em><code class="sig-name descname">ImebraReadingDataHandler</code> : <em class="property">public</em> NSObject<a class="headerlink" href="#_CPPv424ImebraReadingDataHandler" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><a class="reference internal" href="#interface_imebra_reading_data_handler"><span class="std std-ref">ImebraReadingDataHandler</span></a> allows reading the content of a Dicom Tag. </p>
<p><a class="reference internal" href="#interface_imebra_reading_data_handler"><span class="std std-ref">ImebraReadingDataHandler</span></a> is able to return the Tag’s content as a string, a number, a date/time or an age.</p>
<p>In order to obtain a <a class="reference internal" href="#interface_imebra_reading_data_handler"><span class="std std-ref">ImebraReadingDataHandler</span></a> object for a specific <a class="reference internal" href="#interface_imebra_tag"><span class="std std-ref">ImebraTag</span></a> stored in a <a class="reference internal" href="#interface_imebra_data_set"><span class="std std-ref">ImebraDataSet</span></a>, call ImebraDataSet::getReadingDataHandler() or ImebraTag::getReadingDataHandler().</p>
<p><a class="reference internal" href="#interface_imebra_reading_data_handler"><span class="std std-ref">ImebraReadingDataHandler</span></a> keeps a reference to the buffer’s memory: the buffer’s memory is never modified but only replaced by a new memory area, therefore the ReadingDataHandler client does not need to worry about other clients modifying the memory being read. </p>
<p>Subclassed by <a class="reference internal" href="#interface_imebra_reading_data_handler_numeric"><span class="std std-ref">ImebraReadingDataHandlerNumeric</span></a></p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt>
<span class="target" id="interface_imebra_reading_data_handler_1a2436756f3ec1a4475e95104d2f59e663"></span><code class="sig-name descname">signed int ImebraReadingDataHandler::getInt32:error:(unsigned int index, (swift_error(nonnull_error)) __attribute__)</code></dt>
<dd><p>Retrieve a buffer’s value as signed long integer (32 bit). </p>
<p>If the buffer’s value cannot be converted to a signed long integer then set pError to ImebraDataHandlerConversionError.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the tag’s value as a signed 32 bit integer </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">index</span></code>: the element number within the buffer. Must be smaller than getSize() </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pError</span></code>: set to a NSError derived class in case of error </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_reading_data_handler_1ad2a824b4cc97d9afbb7f8f1265c02bab"></span><code class="sig-name descname">signed int ImebraReadingDataHandler::getSignedLong:error:(unsigned int index, (swift_error(nonnull_error)) __attribute__)</code></dt>
<dd><p>Deprecated. Use getInt32() instead. </p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_reading_data_handler_1a6fe70aad082cf303a8487abfc47166f3"></span><code class="sig-name descname">signed short ImebraReadingDataHandler::getInt16:error:(unsigned int index, (swift_error(nonnull_error)) __attribute__)</code></dt>
<dd><p>Retrieve a buffer’s value as signed short integer (16 bit). </p>
<p>If the buffer’s value cannot be converted to a signed long integer then set pError to ImebraDataHandlerConversionError.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the tag’s value as a signed 16 bit integer </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">index</span></code>: the element number within the buffer. Must be smaller than getSize() </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pError</span></code>: set to a NSError derived class in case of error </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_reading_data_handler_1a0f90f042dfb63aba960716cf3d8eded4"></span><code class="sig-name descname">signed char ImebraReadingDataHandler::getInt8:error:(unsigned int index, (swift_error(nonnull_error)) __attribute__)</code></dt>
<dd><p>Retrieve a buffer’s value as signed char integer (8 bit). </p>
<p>If the buffer’s value cannot be converted to a signed long integer then set pError to ImebraDataHandlerConversionError.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the tag’s value as a signed 8 bit integer </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">index</span></code>: the element number within the buffer. Must be smaller than getSize() </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pError</span></code>: set to a NSError derived class in case of error </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_reading_data_handler_1af2e37282e102ef8aae3c86181b196c27"></span><code class="sig-name descname">unsigned int ImebraReadingDataHandler::getUint32:error:(unsigned int index, (swift_error(nonnull_error)) __attribute__)</code></dt>
<dd><p>Retrieve a buffer’s value as an unsigned long integer (32 bit). </p>
<p>When calling getUint32() on an AT tag (Attribute Tag) then the tag group is always in the high word of the returned value.</p>
<p>If the buffer’s value cannot be converted to a unsigned long integer then set pError to ImebraDataHandlerConversionError.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the tag’s value as an unsigned 32 bit integer </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">index</span></code>: the element number within the buffer. Must be smaller than getSize() </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pError</span></code>: set to a NSError derived class in case of error </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_reading_data_handler_1a423e0bd54abdb3b6bdf0040d9d49197a"></span><code class="sig-name descname">unsigned int ImebraReadingDataHandler::getUnsignedLong:error:(unsigned int index, (swift_error(nonnull_error)) __attribute__)</code></dt>
<dd><p>Deprecated. Use getUint32() instead. </p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_reading_data_handler_1adc69aabeb327cbe1acd8ab709800d51c"></span><code class="sig-name descname">unsigned short ImebraReadingDataHandler::getUint16:error:(unsigned int index, (swift_error(nonnull_error)) __attribute__)</code></dt>
<dd><p>Retrieve a buffer’s value as an unsigned short integer (16 bit). </p>
<p>If the buffer’s value cannot be converted to a unsigned long integer then set pError to ImebraDataHandlerConversionError.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the tag’s value as an unsigned 16 bit integer </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">index</span></code>: the element number within the buffer. Must be smaller than getSize() </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pError</span></code>: set to a NSError derived class in case of error </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_reading_data_handler_1a2aa65c82ab23722c5c7f6a9f0a4443c1"></span><code class="sig-name descname">unsigned char ImebraReadingDataHandler::getUint8:error:(unsigned int index, (swift_error(nonnull_error)) __attribute__)</code></dt>
<dd><p>Retrieve a buffer’s value as an unsigned char integer (8 bit). </p>
<p>If the buffer’s value cannot be converted to a unsigned long integer then set pError to ImebraDataHandlerConversionError.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the tag’s value as an unsigned 8 bit integer </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">index</span></code>: the element number within the buffer. Must be smaller than getSize() </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pError</span></code>: set to a NSError derived class in case of error </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_reading_data_handler_1ab81dad6446a6e688b53ed070eb871e25"></span><code class="sig-name descname">double ImebraReadingDataHandler::getDouble:error:(unsigned int index, (swift_error(nonnull_error)) __attribute__)</code></dt>
<dd><p>Retrieve a buffer’s value as a double floating point value (64 bit). </p>
<p>If the buffer’s value cannot be converted to a double floating point then set pError to ImebraDataHandlerConversionError.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the tag’s value as a double floating point value (64 bit) </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">index</span></code>: the element number within the buffer. Must be smaller than getSize() </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pError</span></code>: set to a NSError derived class in case of error </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_reading_data_handler_1a68b7788cbab191722c60968c78d059b1"></span><code class="sig-name descname">float ImebraReadingDataHandler::getFloat:error:(unsigned int index, (swift_error(nonnull_error)) __attribute__)</code></dt>
<dd><p>Retrieve a buffer’s value as a floating point value (32 bit). </p>
<p>If the buffer’s value cannot be converted to a double floating point then set pError to ImebraDataHandlerConversionError.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the tag’s value as a floating point value (32 bit) </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">index</span></code>: the element number within the buffer. Must be smaller than getSize() </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pError</span></code>: set to a NSError derived class in case of error </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_reading_data_handler_1a37db53fe23e7c3d009020c18acfd26ae"></span><code class="sig-name descname">NSString* ImebraReadingDataHandler::getString:error:(unsigned int index, NSError ** pError)</code></dt>
<dd><p>Retrieve a buffer’s value as a string. </p>
<p>If the buffer’s value cannot be converted to a string then set pError to ImebraDataHandlerConversionError.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the tag’s value as a string </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">index</span></code>: the element number within the buffer. Must be smaller than getSize() </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pError</span></code>: set to a NSError derived class in case of error </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_reading_data_handler_1acebbd07729a319ce85a6f0205667e3a7"></span><code class="sig-name descname">ImebraDate* ImebraReadingDataHandler::getDate:error:(unsigned int index, NSError ** pError)</code></dt>
<dd><p>Retrieve a buffer’s value as date or time. </p>
<p>If the buffer’s value cannot be converted to a date or time then set pError to ImebraDataHandlerConversionError.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the tag’s value as a date or time </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">index</span></code>: the element number within the buffer. Must be smaller than getSize() </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pError</span></code>: set to a NSError derived class in case of error </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_reading_data_handler_1a6cfd5ec021e914dc2a19c0ee1dd58951"></span><code class="sig-name descname">ImebraPatientName* ImebraReadingDataHandler::getPatientName:error:(unsigned int index, NSError ** pError)</code></dt>
<dd><p>Retrieve a buffer’s value as patient name. </p>
<p>If the buffer’s value cannot be converted to a patient name then set pError to ImebraDataHandlerConversionError.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the tag’s value as a date or time </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">index</span></code>: the element number within the buffer. Must be smaller than getSize() </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pError</span></code>: set to a NSError derived class in case of error </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_reading_data_handler_1a315e6ac4d8826e5b8c486b141b33ebaa"></span><code class="sig-name descname">ImebraAge* ImebraReadingDataHandler::getAge:error:(unsigned int index, NSError ** pError)</code></dt>
<dd><p>Retrieve a buffer’s value as an age. </p>
<p>If the buffer’s value cannot be converted to an age then set pError to ImebraDataHandlerConversionError.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the tag’s value as an Age </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">index</span></code>: the element number within the buffer. Must be smaller than getSize() </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pError</span></code>: set to a NSError derived class in case of error </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Property</p>
<dl class="member">
<dt>
<span class="target" id="interface_imebra_reading_data_handler_1a50858147be24221dfb1a12d5a816a2e5"></span><em class="property">property </em><code class="sig-name descname">ImebraReadingDataHandler::size</code></dt>
<dd><p>Returns the number of elements in the tag’s buffer handled by the data handler. </p>
<p>If the <a class="reference internal" href="#interface_imebra_reading_data_handler"><span class="std std-ref">ImebraReadingDataHandler</span></a> object is related to a buffer that contains strings then it returns the number of strings stored in the buffer. Multiple strings are separated by a separator char. </p>
</dd></dl>

</div>
</dd></dl>

</div>
</div>
<div class="section" id="readingdatahandlernumeric">
<span id="id17"></span><h3>ReadingDataHandlerNumeric<a class="headerlink" href="#readingdatahandlernumeric" title="Permalink to this headline">¶</a></h3>
<div class="section" id="id18">
<h4>C++<a class="headerlink" href="#id18" title="Permalink to this headline">¶</a></h4>
<dl class="class">
<dt id="_CPPv4N6imebra25ReadingDataHandlerNumericE">
<span id="_CPPv3N6imebra25ReadingDataHandlerNumericE"></span><span id="_CPPv2N6imebra25ReadingDataHandlerNumericE"></span><span id="imebra::ReadingDataHandlerNumeric"></span><span class="target" id="classimebra_1_1_reading_data_handler_numeric"></span><em class="property">class </em><code class="sig-name descname">ReadingDataHandlerNumeric</code> : <em class="property">public</em> imebra::<a class="reference internal" href="#_CPPv4N6imebra18ReadingDataHandlerE" title="imebra::ReadingDataHandler">ReadingDataHandler</a><a class="headerlink" href="#_CPPv4N6imebra25ReadingDataHandlerNumericE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Specialized <a class="reference internal" href="#classimebra_1_1_reading_data_handler"><span class="std std-ref">ReadingDataHandler</span></a> for numeric data types. </p>
<p>Includes few methods that allow accessing the raw memory containing the buffer’s data. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv4N6imebra25ReadingDataHandlerNumeric25ReadingDataHandlerNumericERK25ReadingDataHandlerNumeric">
<span id="_CPPv3N6imebra25ReadingDataHandlerNumeric25ReadingDataHandlerNumericERK25ReadingDataHandlerNumeric"></span><span id="_CPPv2N6imebra25ReadingDataHandlerNumeric25ReadingDataHandlerNumericERK25ReadingDataHandlerNumeric"></span><span id="imebra::ReadingDataHandlerNumeric::ReadingDataHandlerNumeric__ReadingDataHandlerNumericCR"></span><span class="target" id="classimebra_1_1_reading_data_handler_numeric_1a4b137d23f0f70da83fcab27c52ee5185"></span><code class="sig-name descname">ReadingDataHandlerNumeric</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N6imebra25ReadingDataHandlerNumeric25ReadingDataHandlerNumericERK25ReadingDataHandlerNumeric" title="imebra::ReadingDataHandlerNumeric::ReadingDataHandlerNumeric">ReadingDataHandlerNumeric</a> &amp;<em>source</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N6imebra25ReadingDataHandlerNumeric25ReadingDataHandlerNumericERK25ReadingDataHandlerNumeric" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Copy constructor. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">source</span></code>: source <a class="reference internal" href="#classimebra_1_1_reading_data_handler_numeric"><span class="std std-ref">ReadingDataHandlerNumeric</span></a> object </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK6imebra25ReadingDataHandlerNumeric9getMemoryEv">
<span id="_CPPv3NK6imebra25ReadingDataHandlerNumeric9getMemoryEv"></span><span id="_CPPv2NK6imebra25ReadingDataHandlerNumeric9getMemoryEv"></span><span id="imebra::ReadingDataHandlerNumeric::getMemoryC"></span><span class="target" id="classimebra_1_1_reading_data_handler_numeric_1aeaf29b0fc469baf518851e6950d32462"></span><em class="property">const</em> <a class="reference internal" href="memory_management_classes.html#_CPPv4N6imebra6MemoryE" title="imebra::Memory">Memory</a> <code class="sig-name descname">getMemory</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK6imebra25ReadingDataHandlerNumeric9getMemoryEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return a <a class="reference internal" href="memory_management_classes.html#classimebra_1_1_memory"><span class="std std-ref">Memory</span></a> object referencing the raw buffer’s data. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>a <a class="reference internal" href="memory_management_classes.html#classimebra_1_1_memory"><span class="std std-ref">Memory</span></a> object referencing the raw buffer’s data </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK6imebra25ReadingDataHandlerNumeric4dataEPc6size_t">
<span id="_CPPv3NK6imebra25ReadingDataHandlerNumeric4dataEPc6size_t"></span><span id="_CPPv2NK6imebra25ReadingDataHandlerNumeric4dataEPc6size_t"></span><span id="imebra::ReadingDataHandlerNumeric::data__cP.sC"></span><span class="target" id="classimebra_1_1_reading_data_handler_numeric_1a66b4d058c212fa6b904a0d9f577d5cfb"></span>size_t <code class="sig-name descname">data</code><span class="sig-paren">(</span>char *<em>destination</em>, size_t <em>destinationSize</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK6imebra25ReadingDataHandlerNumeric4dataEPc6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Copies the buffer’s raw memory content into the specified buffer. </p>
<p>If the allocated buffer is not large enough then the method doesn’t copy any data and just returns the required buffer’ size.</p>
<p><strong>Java</strong></p>
<p>In Java this method accepts a single parameter (a byte array). The size of the byte array must be equal or greater than the number of bytes stored by the data handler.</p>
<p><strong>Python</strong></p>
<p>In Python this method accepts a single parameter (an array). The size of the array (in bytes) must be equal or greater than the number of bytes stored by the data handler.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the number of bytes copied into the pre-allocated buffer, or the desired size of destination if destinationSize is smaller than the return value </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">destination</span></code>: a pointer to the allocated buffer </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">destinationSize</span></code>: the size of the allocated buffer </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK6imebra25ReadingDataHandlerNumeric4dataEP6size_t">
<span id="_CPPv3NK6imebra25ReadingDataHandlerNumeric4dataEP6size_t"></span><span id="_CPPv2NK6imebra25ReadingDataHandlerNumeric4dataEP6size_t"></span><span id="imebra::ReadingDataHandlerNumeric::data__sPC"></span><span class="target" id="classimebra_1_1_reading_data_handler_numeric_1a08360cb97abb723d6b39cf866b55d992"></span><em class="property">const</em> char *<code class="sig-name descname">data</code><span class="sig-paren">(</span>size_t *<em>pDataSize</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK6imebra25ReadingDataHandlerNumeric4dataEP6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns a pointer to the buffer’s raw memory content. </p>
<p>The referenced buffer is owned by the <a class="reference internal" href="#classimebra_1_1_reading_data_handler_numeric"><span class="std std-ref">ReadingDataHandlerNumeric</span></a> object and must not be freed by the client.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>a pointer to the buffer’s raw memory. The referenced buffer is owned by the <a class="reference internal" href="#classimebra_1_1_reading_data_handler_numeric"><span class="std std-ref">ReadingDataHandlerNumeric</span></a> object and must not be freed by the client. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pDataSize</span></code>: a variable that will contain the raw memory’s size in bytes </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK6imebra25ReadingDataHandlerNumeric11getUnitSizeEv">
<span id="_CPPv3NK6imebra25ReadingDataHandlerNumeric11getUnitSizeEv"></span><span id="_CPPv2NK6imebra25ReadingDataHandlerNumeric11getUnitSizeEv"></span><span id="imebra::ReadingDataHandlerNumeric::getUnitSizeC"></span><span class="target" id="classimebra_1_1_reading_data_handler_numeric_1ad6c9cc528fcb75d660ad24315f7ee627"></span>size_t <code class="sig-name descname">getUnitSize</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK6imebra25ReadingDataHandlerNumeric11getUnitSizeEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns the number of bytes occupied by the numbers handled by the data handler. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the number of bytes occupied by the numbers handled by the data handler </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK6imebra25ReadingDataHandlerNumeric8isSignedEv">
<span id="_CPPv3NK6imebra25ReadingDataHandlerNumeric8isSignedEv"></span><span id="_CPPv2NK6imebra25ReadingDataHandlerNumeric8isSignedEv"></span><span id="imebra::ReadingDataHandlerNumeric::isSignedC"></span><span class="target" id="classimebra_1_1_reading_data_handler_numeric_1a8a8a3248bc154c3c16624e2f94b4ade4"></span>bool <code class="sig-name descname">isSigned</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK6imebra25ReadingDataHandlerNumeric8isSignedEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns true if the numbers stored in the buffer are signed, false otherwise. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>true if the numbers stored in the buffer are signed, false otherwise </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK6imebra25ReadingDataHandlerNumeric7isFloatEv">
<span id="_CPPv3NK6imebra25ReadingDataHandlerNumeric7isFloatEv"></span><span id="_CPPv2NK6imebra25ReadingDataHandlerNumeric7isFloatEv"></span><span id="imebra::ReadingDataHandlerNumeric::isFloatC"></span><span class="target" id="classimebra_1_1_reading_data_handler_numeric_1ac88a53a350db036a57e66c26c2e610b7"></span>bool <code class="sig-name descname">isFloat</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK6imebra25ReadingDataHandlerNumeric7isFloatEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns true if the numbers stored in the buffer are floating point numbers, false otherwise. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>true if the numbers stored in the buffer are floating point numbers, false otherwise </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N6imebra25ReadingDataHandlerNumeric6copyToERK25WritingDataHandlerNumeric">
<span id="_CPPv3N6imebra25ReadingDataHandlerNumeric6copyToERK25WritingDataHandlerNumeric"></span><span id="_CPPv2N6imebra25ReadingDataHandlerNumeric6copyToERK25WritingDataHandlerNumeric"></span><span id="imebra::ReadingDataHandlerNumeric::copyTo__WritingDataHandlerNumericCR"></span><span class="target" id="classimebra_1_1_reading_data_handler_numeric_1a4d61eb868ecce30246f449ed091a7105"></span>void <code class="sig-name descname">copyTo</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N6imebra25WritingDataHandlerNumericE" title="imebra::WritingDataHandlerNumeric">WritingDataHandlerNumeric</a> &amp;<em>destination</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N6imebra25ReadingDataHandlerNumeric6copyToERK25WritingDataHandlerNumeric" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Copies the content of the data handler into another data handler, converting the data to the destination handler data type. </p>
<p><dl class="simple">
<dt><strong>Warning</strong></dt><dd><p>the size of the destination data handler stays unchanged: if the destination is too small to contain all the data to be copied then only a part of the data will be copied.</p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">destination</span></code>: the destination data handler </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</div>
<div class="section" id="id19">
<h4>Objective-C/Swift<a class="headerlink" href="#id19" title="Permalink to this headline">¶</a></h4>
<dl class="class">
<dt id="_CPPv431ImebraReadingDataHandlerNumeric">
<span id="_CPPv331ImebraReadingDataHandlerNumeric"></span><span id="_CPPv231ImebraReadingDataHandlerNumeric"></span><span id="ImebraReadingDataHandlerNumeric"></span><span class="target" id="interface_imebra_reading_data_handler_numeric"></span><em class="property">class </em><code class="sig-name descname">ImebraReadingDataHandlerNumeric</code> : <em class="property">public</em> <a class="reference internal" href="#_CPPv424ImebraReadingDataHandler" title="ImebraReadingDataHandler">ImebraReadingDataHandler</a><a class="headerlink" href="#_CPPv431ImebraReadingDataHandlerNumeric" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Specialized <a class="reference internal" href="#interface_imebra_reading_data_handler"><span class="std std-ref">ImebraReadingDataHandler</span></a> for numeric data types. </p>
<p>Includes few methods that allow accessing the raw memory containing the buffer’s data. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt>
<span class="target" id="interface_imebra_reading_data_handler_numeric_1a49c420a3e4bbd26d4257d25e7046a995"></span><code class="sig-name descname">ImebraMemory* ImebraReadingDataHandlerNumeric::getMemory:((swift_error(nonnull_error)) __attribute__)</code></dt>
<dd><p>Return a ReadMemory object referencing the raw buffer’s data. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>a ReadMemory object referencing the raw buffer’s data </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pError</span></code>: set to a NSError derived class in case of error </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_reading_data_handler_numeric_1aac0be2bf4f2f250762185a91416be2cf"></span><code class="sig-name descname">void ImebraReadingDataHandlerNumeric::copyTo:error:(ImebraWritingDataHandlerNumeric  * destination, (swift_error(nonnull_error)) __attribute__)</code></dt>
<dd><p>Copies the content of the data handler into another data handler, converting the data to the destination handler data type. </p>
<p><dl class="simple">
<dt><strong>Warning</strong></dt><dd><p>the size of the destination data handler stays unchanged: if the destination too small to contain all the data to be copied then only a part of the data will be copied.</p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pError</span></code>: set to a NSError derived class in case of error </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">destination</span></code>: the destination data handler </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Property</p>
<dl class="member">
<dt>
<span class="target" id="interface_imebra_reading_data_handler_numeric_1afa336cf845b739b955dbc5234ca2e1e7"></span><em class="property">property </em><code class="sig-name descname">ImebraReadingDataHandlerNumeric::unitSize</code></dt>
<dd><p>Returns the number of bytes occupied by the numbers handled by the data handler. </p>
</dd></dl>

<dl class="member">
<dt>
<span class="target" id="interface_imebra_reading_data_handler_numeric_1a0af122cbc10592986142db10b6986a2e"></span><em class="property">property </em><code class="sig-name descname">ImebraReadingDataHandlerNumeric::isSigned</code></dt>
<dd><p>Returns true if the numbers stored in the buffer are signed, false otherwise. </p>
</dd></dl>

<dl class="member">
<dt>
<span class="target" id="interface_imebra_reading_data_handler_numeric_1a1a14903be240bda960ae9b4e4990b7ec"></span><em class="property">property </em><code class="sig-name descname">ImebraReadingDataHandlerNumeric::isFloat</code></dt>
<dd><p>Returns true if the numbers stored in the buffer are floating point numbers, false otherwise. </p>
</dd></dl>

</div>
</dd></dl>

</div>
</div>
<div class="section" id="writingdatahandler">
<span id="id20"></span><h3>WritingDataHandler<a class="headerlink" href="#writingdatahandler" title="Permalink to this headline">¶</a></h3>
<div class="section" id="id21">
<h4>C++<a class="headerlink" href="#id21" title="Permalink to this headline">¶</a></h4>
<dl class="class">
<dt id="_CPPv4N6imebra18WritingDataHandlerE">
<span id="_CPPv3N6imebra18WritingDataHandlerE"></span><span id="_CPPv2N6imebra18WritingDataHandlerE"></span><span id="imebra::WritingDataHandler"></span><span class="target" id="classimebra_1_1_writing_data_handler"></span><em class="property">class </em><code class="sig-name descname">WritingDataHandler</code><a class="headerlink" href="#_CPPv4N6imebra18WritingDataHandlerE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The <a class="reference internal" href="#classimebra_1_1_writing_data_handler"><span class="std std-ref">WritingDataHandler</span></a> class allows to write the content of a Dicom tag’s buffer. </p>
<p><a class="reference internal" href="#classimebra_1_1_writing_data_handler"><span class="std std-ref">WritingDataHandler</span></a> is able to write into the buffer’s content strings, numbers, date/time or ages.</p>
<p>In order to obtain a <a class="reference internal" href="#classimebra_1_1_writing_data_handler"><span class="std std-ref">WritingDataHandler</span></a> object for a specific tag stored in a <a class="reference internal" href="#classimebra_1_1_data_set"><span class="std std-ref">DataSet</span></a>, call DataSet::getWritingDataHandler() or Tag::getWritingDataHandler().</p>
<p>The <a class="reference internal" href="#classimebra_1_1_writing_data_handler"><span class="std std-ref">WritingDataHandler</span></a> object always works on a new and clean memory area. The buffer’s memory is replaced by the <a class="reference internal" href="#classimebra_1_1_writing_data_handler"><span class="std std-ref">WritingDataHandler</span></a> memory when the data handler is destroyed. </p>
<p>Subclassed by <a class="reference internal" href="#classimebra_1_1_writing_data_handler_numeric"><span class="std std-ref">imebra::WritingDataHandlerNumeric</span></a></p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv4N6imebra18WritingDataHandler18WritingDataHandlerERK18WritingDataHandler">
<span id="_CPPv3N6imebra18WritingDataHandler18WritingDataHandlerERK18WritingDataHandler"></span><span id="_CPPv2N6imebra18WritingDataHandler18WritingDataHandlerERK18WritingDataHandler"></span><span id="imebra::WritingDataHandler::WritingDataHandler__WritingDataHandlerCR"></span><span class="target" id="classimebra_1_1_writing_data_handler_1ae151f8cdcd97880dcf0f9a685a75e55b"></span><code class="sig-name descname">WritingDataHandler</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N6imebra18WritingDataHandler18WritingDataHandlerERK18WritingDataHandler" title="imebra::WritingDataHandler::WritingDataHandler">WritingDataHandler</a> &amp;<em>source</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N6imebra18WritingDataHandler18WritingDataHandlerERK18WritingDataHandler" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Copy constructor. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">source</span></code>: source <a class="reference internal" href="#classimebra_1_1_writing_data_handler"><span class="std std-ref">WritingDataHandler</span></a> object </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N6imebra18WritingDataHandlerD0Ev">
<span id="_CPPv3N6imebra18WritingDataHandlerD0Ev"></span><span id="_CPPv2N6imebra18WritingDataHandlerD0Ev"></span><span id="imebra::WritingDataHandler::~WritingDataHandler"></span><span class="target" id="classimebra_1_1_writing_data_handler_1a5ace3e9ba974b35edaae140a7f72a8dd"></span><em class="property">virtual</em> <code class="sig-name descname">~WritingDataHandler</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N6imebra18WritingDataHandlerD0Ev" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Destructor: replaces the tag buffer’s memory with the memory created by this <a class="reference internal" href="#classimebra_1_1_writing_data_handler"><span class="std std-ref">WritingDataHandler</span></a>. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N6imebra18WritingDataHandler7setSizeE6size_t">
<span id="_CPPv3N6imebra18WritingDataHandler7setSizeE6size_t"></span><span id="_CPPv2N6imebra18WritingDataHandler7setSizeE6size_t"></span><span id="imebra::WritingDataHandler::setSize__s"></span><span class="target" id="classimebra_1_1_writing_data_handler_1a413692734d2094cbb76902e042282c4f"></span>void <code class="sig-name descname">setSize</code><span class="sig-paren">(</span>size_t <em>elementsNumber</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N6imebra18WritingDataHandler7setSizeE6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Resize the memory to contain the specified number of elements. </p>
<p>By default, the <a class="reference internal" href="#classimebra_1_1_writing_data_handler"><span class="std std-ref">WritingDataHandler</span></a> buffer allocates an empty memory block that must be resized in order to be filled with data.</p>
<p>The type of the contained elements depends on the tag’s VR. The VR can be retrieved with <a class="reference internal" href="#classimebra_1_1_writing_data_handler_1afeb2bcc3d7a1af6a5ea5eb67f91de72b"><span class="std std-ref">getDataType()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">elementsNumber</span></code>: the number of elements to store in the buffer. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK6imebra18WritingDataHandler7getSizeEv">
<span id="_CPPv3NK6imebra18WritingDataHandler7getSizeEv"></span><span id="_CPPv2NK6imebra18WritingDataHandler7getSizeEv"></span><span id="imebra::WritingDataHandler::getSizeC"></span><span class="target" id="classimebra_1_1_writing_data_handler_1a4deb5d45a123e9571f88ec48bf1ac1d4"></span>size_t <code class="sig-name descname">getSize</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK6imebra18WritingDataHandler7getSizeEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Retrieve the number of elements that can be stored in the buffer controlled by <a class="reference internal" href="#classimebra_1_1_writing_data_handler"><span class="std std-ref">WritingDataHandler</span></a>. </p>
<p>The memory size can be changed with <a class="reference internal" href="#classimebra_1_1_writing_data_handler_1a413692734d2094cbb76902e042282c4f"><span class="std std-ref">setSize()</span></a>.</p>
<p>The type of the contained elements depends on the tag’s VR. The VR can be retrieved with <a class="reference internal" href="#classimebra_1_1_writing_data_handler_1afeb2bcc3d7a1af6a5ea5eb67f91de72b"><span class="std std-ref">getDataType()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the number of elements that can be stored in the buffer </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK6imebra18WritingDataHandler11getDataTypeEv">
<span id="_CPPv3NK6imebra18WritingDataHandler11getDataTypeEv"></span><span id="_CPPv2NK6imebra18WritingDataHandler11getDataTypeEv"></span><span id="imebra::WritingDataHandler::getDataTypeC"></span><span class="target" id="classimebra_1_1_writing_data_handler_1afeb2bcc3d7a1af6a5ea5eb67f91de72b"></span><a class="reference internal" href="definition_classes.html#_CPPv4N6imebra7tagVR_tE" title="imebra::tagVR_t">tagVR_t</a> <code class="sig-name descname">getDataType</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK6imebra18WritingDataHandler11getDataTypeEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns the data type (VR) of the data handled by the data handler. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the data type of the handled data </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N6imebra18WritingDataHandler8setInt32E6size_tNSt7int32_tE">
<span id="_CPPv3N6imebra18WritingDataHandler8setInt32E6size_tNSt7int32_tE"></span><span id="_CPPv2N6imebra18WritingDataHandler8setInt32E6size_tNSt7int32_tE"></span><span id="imebra::WritingDataHandler::setInt32__s.std::int32_t"></span><span class="target" id="classimebra_1_1_writing_data_handler_1ad157336dd69425dde6f482d65baccf72"></span>void <code class="sig-name descname">setInt32</code><span class="sig-paren">(</span>size_t <em>index</em>, std::int32_t <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N6imebra18WritingDataHandler8setInt32E6size_tNSt7int32_tE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Write a signed long integer (32 bit). </p>
<p>If the value cannot be converted from a signed long integer then throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_data_handler_conversion_error"><span class="std std-ref">DataHandlerConversionError</span></a>.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">index</span></code>: the element number within the buffer. Must be smaller than <a class="reference internal" href="#classimebra_1_1_writing_data_handler_1a4deb5d45a123e9571f88ec48bf1ac1d4"><span class="std std-ref">getSize()</span></a> </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">value</span></code>: the value to write </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N6imebra18WritingDataHandler13setSignedLongE6size_tNSt7int32_tE">
<span id="_CPPv3N6imebra18WritingDataHandler13setSignedLongE6size_tNSt7int32_tE"></span><span id="_CPPv2N6imebra18WritingDataHandler13setSignedLongE6size_tNSt7int32_tE"></span><span id="imebra::WritingDataHandler::setSignedLong__s.std::int32_t"></span><span class="target" id="classimebra_1_1_writing_data_handler_1aebbdfef8ad1edfb312c7cc5a35e18a2a"></span>void <code class="sig-name descname">setSignedLong</code><span class="sig-paren">(</span>size_t <em>index</em>, std::int32_t <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N6imebra18WritingDataHandler13setSignedLongE6size_tNSt7int32_tE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Deprecated. Use <a class="reference internal" href="#classimebra_1_1_writing_data_handler_1ad157336dd69425dde6f482d65baccf72"><span class="std std-ref">setInt32()</span></a> instead. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N6imebra18WritingDataHandler9setUint32E6size_tNSt8uint32_tE">
<span id="_CPPv3N6imebra18WritingDataHandler9setUint32E6size_tNSt8uint32_tE"></span><span id="_CPPv2N6imebra18WritingDataHandler9setUint32E6size_tNSt8uint32_tE"></span><span id="imebra::WritingDataHandler::setUint32__s.std::uint32_t"></span><span class="target" id="classimebra_1_1_writing_data_handler_1acbbefe63a50ef06eb360ae34915a0713"></span>void <code class="sig-name descname">setUint32</code><span class="sig-paren">(</span>size_t <em>index</em>, std::uint32_t <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N6imebra18WritingDataHandler9setUint32E6size_tNSt8uint32_tE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Write an unsigned long integer (32 bit). </p>
<p>When setting a value for an AT tag (Attribute <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a>) then the tag’s group must always be in the higher 16 bits of the value.</p>
<p>If the value cannot be converted from an unsigned long integer then throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_data_handler_conversion_error"><span class="std std-ref">DataHandlerConversionError</span></a>.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">index</span></code>: the element number within the buffer. Must be smaller than <a class="reference internal" href="#classimebra_1_1_writing_data_handler_1a4deb5d45a123e9571f88ec48bf1ac1d4"><span class="std std-ref">getSize()</span></a> </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">value</span></code>: the value to write </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N6imebra18WritingDataHandler15setUnsignedLongE6size_tNSt8uint32_tE">
<span id="_CPPv3N6imebra18WritingDataHandler15setUnsignedLongE6size_tNSt8uint32_tE"></span><span id="_CPPv2N6imebra18WritingDataHandler15setUnsignedLongE6size_tNSt8uint32_tE"></span><span id="imebra::WritingDataHandler::setUnsignedLong__s.std::uint32_t"></span><span class="target" id="classimebra_1_1_writing_data_handler_1a6e33479a17119d1aa34e230fa86cd43b"></span>void <code class="sig-name descname">setUnsignedLong</code><span class="sig-paren">(</span>size_t <em>index</em>, std::uint32_t <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N6imebra18WritingDataHandler15setUnsignedLongE6size_tNSt8uint32_tE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Deprecated. Use <a class="reference internal" href="#classimebra_1_1_writing_data_handler_1acbbefe63a50ef06eb360ae34915a0713"><span class="std std-ref">setUint32()</span></a> instead. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N6imebra18WritingDataHandler8setInt16E6size_tNSt7int16_tE">
<span id="_CPPv3N6imebra18WritingDataHandler8setInt16E6size_tNSt7int16_tE"></span><span id="_CPPv2N6imebra18WritingDataHandler8setInt16E6size_tNSt7int16_tE"></span><span id="imebra::WritingDataHandler::setInt16__s.std::int16_t"></span><span class="target" id="classimebra_1_1_writing_data_handler_1ab87e450831c1c1df17e2c17031ae76c6"></span>void <code class="sig-name descname">setInt16</code><span class="sig-paren">(</span>size_t <em>index</em>, std::int16_t <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N6imebra18WritingDataHandler8setInt16E6size_tNSt7int16_tE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Write a signed long integer (16 bit). </p>
<p>If the value cannot be converted from a signed long integer then throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_data_handler_conversion_error"><span class="std std-ref">DataHandlerConversionError</span></a>.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">index</span></code>: the element number within the buffer. Must be smaller than <a class="reference internal" href="#classimebra_1_1_writing_data_handler_1a4deb5d45a123e9571f88ec48bf1ac1d4"><span class="std std-ref">getSize()</span></a> </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">value</span></code>: the value to write </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N6imebra18WritingDataHandler9setUint16E6size_tNSt8uint16_tE">
<span id="_CPPv3N6imebra18WritingDataHandler9setUint16E6size_tNSt8uint16_tE"></span><span id="_CPPv2N6imebra18WritingDataHandler9setUint16E6size_tNSt8uint16_tE"></span><span id="imebra::WritingDataHandler::setUint16__s.std::uint16_t"></span><span class="target" id="classimebra_1_1_writing_data_handler_1a0ca0c1357bb9ec4d7b2dafc6db7ff254"></span>void <code class="sig-name descname">setUint16</code><span class="sig-paren">(</span>size_t <em>index</em>, std::uint16_t <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N6imebra18WritingDataHandler9setUint16E6size_tNSt8uint16_tE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Write an unsigned long integer (16 bit). </p>
<p>If the value cannot be converted from an unsigned long integer then throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_data_handler_conversion_error"><span class="std std-ref">DataHandlerConversionError</span></a>.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">index</span></code>: the element number within the buffer. Must be smaller than <a class="reference internal" href="#classimebra_1_1_writing_data_handler_1a4deb5d45a123e9571f88ec48bf1ac1d4"><span class="std std-ref">getSize()</span></a> </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">value</span></code>: the value to write </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N6imebra18WritingDataHandler7setInt8E6size_tNSt6int8_tE">
<span id="_CPPv3N6imebra18WritingDataHandler7setInt8E6size_tNSt6int8_tE"></span><span id="_CPPv2N6imebra18WritingDataHandler7setInt8E6size_tNSt6int8_tE"></span><span id="imebra::WritingDataHandler::setInt8__s.std::int8_t"></span><span class="target" id="classimebra_1_1_writing_data_handler_1a03a768a40e22b3df4dd18df0b2cc3a20"></span>void <code class="sig-name descname">setInt8</code><span class="sig-paren">(</span>size_t <em>index</em>, std::int8_t <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N6imebra18WritingDataHandler7setInt8E6size_tNSt6int8_tE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Write a signed long integer (8 bit). </p>
<p>If the value cannot be converted from a signed long integer then throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_data_handler_conversion_error"><span class="std std-ref">DataHandlerConversionError</span></a>.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">index</span></code>: the element number within the buffer. Must be smaller than <a class="reference internal" href="#classimebra_1_1_writing_data_handler_1a4deb5d45a123e9571f88ec48bf1ac1d4"><span class="std std-ref">getSize()</span></a> </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">value</span></code>: the value to write </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N6imebra18WritingDataHandler8setUint8E6size_tNSt7uint8_tE">
<span id="_CPPv3N6imebra18WritingDataHandler8setUint8E6size_tNSt7uint8_tE"></span><span id="_CPPv2N6imebra18WritingDataHandler8setUint8E6size_tNSt7uint8_tE"></span><span id="imebra::WritingDataHandler::setUint8__s.std::uint8_t"></span><span class="target" id="classimebra_1_1_writing_data_handler_1a146ec91a0d6bf13e689b6abf60f6baa5"></span>void <code class="sig-name descname">setUint8</code><span class="sig-paren">(</span>size_t <em>index</em>, std::uint8_t <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N6imebra18WritingDataHandler8setUint8E6size_tNSt7uint8_tE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Write an unsigned long integer (8 bit). </p>
<p>If the value cannot be converted from an unsigned long integer then throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_data_handler_conversion_error"><span class="std std-ref">DataHandlerConversionError</span></a>.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">index</span></code>: the element number within the buffer. Must be smaller than <a class="reference internal" href="#classimebra_1_1_writing_data_handler_1a4deb5d45a123e9571f88ec48bf1ac1d4"><span class="std std-ref">getSize()</span></a> </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">value</span></code>: the value to write </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N6imebra18WritingDataHandler9setDoubleE6size_td">
<span id="_CPPv3N6imebra18WritingDataHandler9setDoubleE6size_td"></span><span id="_CPPv2N6imebra18WritingDataHandler9setDoubleE6size_td"></span><span id="imebra::WritingDataHandler::setDouble__s.double"></span><span class="target" id="classimebra_1_1_writing_data_handler_1a9694a54a6cb41fbe599b68afad06fda9"></span>void <code class="sig-name descname">setDouble</code><span class="sig-paren">(</span>size_t <em>index</em>, double <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N6imebra18WritingDataHandler9setDoubleE6size_td" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Write a double floating point value (64 bit). </p>
<p>If the value cannot be converted from a double floating point then throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_data_handler_conversion_error"><span class="std std-ref">DataHandlerConversionError</span></a>.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">index</span></code>: the element number within the buffer. Must be smaller than <a class="reference internal" href="#classimebra_1_1_writing_data_handler_1a4deb5d45a123e9571f88ec48bf1ac1d4"><span class="std std-ref">getSize()</span></a> </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">value</span></code>: the value to write </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N6imebra18WritingDataHandler8setFloatE6size_tf">
<span id="_CPPv3N6imebra18WritingDataHandler8setFloatE6size_tf"></span><span id="_CPPv2N6imebra18WritingDataHandler8setFloatE6size_tf"></span><span id="imebra::WritingDataHandler::setFloat__s.float"></span><span class="target" id="classimebra_1_1_writing_data_handler_1a66c1a6a9d39a1bafaa1892a7f844c26a"></span>void <code class="sig-name descname">setFloat</code><span class="sig-paren">(</span>size_t <em>index</em>, float <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N6imebra18WritingDataHandler8setFloatE6size_tf" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Write a floating point value (32 bit). </p>
<p>If the value cannot be converted from a floating point then throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_data_handler_conversion_error"><span class="std std-ref">DataHandlerConversionError</span></a>.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">index</span></code>: the element number within the buffer. Must be smaller than <a class="reference internal" href="#classimebra_1_1_writing_data_handler_1a4deb5d45a123e9571f88ec48bf1ac1d4"><span class="std std-ref">getSize()</span></a> </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">value</span></code>: the value to write </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N6imebra18WritingDataHandler9setStringE6size_tRKNSt6stringE">
<span id="_CPPv3N6imebra18WritingDataHandler9setStringE6size_tRKNSt6stringE"></span><span id="_CPPv2N6imebra18WritingDataHandler9setStringE6size_tRKNSt6stringE"></span><span id="imebra::WritingDataHandler::setString__s.ssCR"></span><span class="target" id="classimebra_1_1_writing_data_handler_1aa33cc25f450fabfccf661651b23fa9a0"></span>void <code class="sig-name descname">setString</code><span class="sig-paren">(</span>size_t <em>index</em>, <em class="property">const</em> std::string &amp;<em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N6imebra18WritingDataHandler9setStringE6size_tRKNSt6stringE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Write a UTF8 string. </p>
<p>If the value cannot be converted from a string then throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_data_handler_conversion_error"><span class="std std-ref">DataHandlerConversionError</span></a>.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">index</span></code>: the element number within the buffer. Must be smaller than <a class="reference internal" href="#classimebra_1_1_writing_data_handler_1a4deb5d45a123e9571f88ec48bf1ac1d4"><span class="std std-ref">getSize()</span></a> </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">value</span></code>: the value to write </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N6imebra18WritingDataHandler16setUnicodeStringE6size_tRKNSt7wstringE">
<span id="_CPPv3N6imebra18WritingDataHandler16setUnicodeStringE6size_tRKNSt7wstringE"></span><span id="_CPPv2N6imebra18WritingDataHandler16setUnicodeStringE6size_tRKNSt7wstringE"></span><span id="imebra::WritingDataHandler::setUnicodeString__s.std::wstringCR"></span><span class="target" id="classimebra_1_1_writing_data_handler_1af31ab17196c1cd5aadfb0ef04dc155ac"></span>void <code class="sig-name descname">setUnicodeString</code><span class="sig-paren">(</span>size_t <em>index</em>, <em class="property">const</em> std::wstring &amp;<em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N6imebra18WritingDataHandler16setUnicodeStringE6size_tRKNSt7wstringE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Write an Unicode string. </p>
<p>If the value cannot be converted from a Unicode string then throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_data_handler_conversion_error"><span class="std std-ref">DataHandlerConversionError</span></a>.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">index</span></code>: the element number within the buffer. Must be smaller than <a class="reference internal" href="#classimebra_1_1_writing_data_handler_1a4deb5d45a123e9571f88ec48bf1ac1d4"><span class="std std-ref">getSize()</span></a> </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">value</span></code>: the value to write </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N6imebra18WritingDataHandler7setDateE6size_tRK4Date">
<span id="_CPPv3N6imebra18WritingDataHandler7setDateE6size_tRK4Date"></span><span id="_CPPv2N6imebra18WritingDataHandler7setDateE6size_tRK4Date"></span><span id="imebra::WritingDataHandler::setDate__s.DateCR"></span><span class="target" id="classimebra_1_1_writing_data_handler_1abb744a7256dbbb8e4468c561f20dc579"></span>void <code class="sig-name descname">setDate</code><span class="sig-paren">(</span>size_t <em>index</em>, <em class="property">const</em> <a class="reference internal" href="#_CPPv4N6imebra4DateE" title="imebra::Date">Date</a> &amp;<em>date</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N6imebra18WritingDataHandler7setDateE6size_tRK4Date" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Write a date and/or a time. </p>
<p>If the value cannot be converted from a <a class="reference internal" href="#classimebra_1_1_date"><span class="std std-ref">Date</span></a> then throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_data_handler_conversion_error"><span class="std std-ref">DataHandlerConversionError</span></a>.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">index</span></code>: the element number within the buffer. Must be smaller than <a class="reference internal" href="#classimebra_1_1_writing_data_handler_1a4deb5d45a123e9571f88ec48bf1ac1d4"><span class="std std-ref">getSize()</span></a> </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">date</span></code>: the value to write </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N6imebra18WritingDataHandler6setAgeE6size_tRK3Age">
<span id="_CPPv3N6imebra18WritingDataHandler6setAgeE6size_tRK3Age"></span><span id="_CPPv2N6imebra18WritingDataHandler6setAgeE6size_tRK3Age"></span><span id="imebra::WritingDataHandler::setAge__s.AgeCR"></span><span class="target" id="classimebra_1_1_writing_data_handler_1aa0c1f4ff7ff62f052f1c6f1537abcbc1"></span>void <code class="sig-name descname">setAge</code><span class="sig-paren">(</span>size_t <em>index</em>, <em class="property">const</em> <a class="reference internal" href="#_CPPv4N6imebra3AgeE" title="imebra::Age">Age</a> &amp;<em>age</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N6imebra18WritingDataHandler6setAgeE6size_tRK3Age" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Write an <a class="reference internal" href="#classimebra_1_1_age"><span class="std std-ref">Age</span></a> value. </p>
<p>If the value cannot be converted from an <a class="reference internal" href="#classimebra_1_1_age"><span class="std std-ref">Age</span></a> then throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_data_handler_conversion_error"><span class="std std-ref">DataHandlerConversionError</span></a>.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">index</span></code>: the element number within the buffer. Must be smaller than <a class="reference internal" href="#classimebra_1_1_writing_data_handler_1a4deb5d45a123e9571f88ec48bf1ac1d4"><span class="std std-ref">getSize()</span></a> </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">age</span></code>: the value to write </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N6imebra18WritingDataHandler14setPatientNameE6size_tRK11PatientName">
<span id="_CPPv3N6imebra18WritingDataHandler14setPatientNameE6size_tRK11PatientName"></span><span id="_CPPv2N6imebra18WritingDataHandler14setPatientNameE6size_tRK11PatientName"></span><span id="imebra::WritingDataHandler::setPatientName__s.PatientNameCR"></span><span class="target" id="classimebra_1_1_writing_data_handler_1abf51a9dab2ae5075e4ba4f55be0be471"></span>void <code class="sig-name descname">setPatientName</code><span class="sig-paren">(</span>size_t <em>index</em>, <em class="property">const</em> <a class="reference internal" href="#_CPPv4N6imebra11PatientNameE" title="imebra::PatientName">PatientName</a> &amp;<em>patientName</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N6imebra18WritingDataHandler14setPatientNameE6size_tRK11PatientName" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Write a <a class="reference internal" href="#classimebra_1_1_patient_name"><span class="std std-ref">PatientName</span></a> value. </p>
<p>If the value cannot be converted from a <a class="reference internal" href="#classimebra_1_1_patient_name"><span class="std std-ref">PatientName</span></a> value then throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_data_handler_conversion_error"><span class="std std-ref">DataHandlerConversionError</span></a>.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">index</span></code>: the element number within the buffer. Must be smaller than <a class="reference internal" href="#classimebra_1_1_writing_data_handler_1a4deb5d45a123e9571f88ec48bf1ac1d4"><span class="std std-ref">getSize()</span></a> </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">age</span></code>: the value to write </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N6imebra18WritingDataHandler21setUnicodePatientNameE6size_tRK18UnicodePatientName">
<span id="_CPPv3N6imebra18WritingDataHandler21setUnicodePatientNameE6size_tRK18UnicodePatientName"></span><span id="_CPPv2N6imebra18WritingDataHandler21setUnicodePatientNameE6size_tRK18UnicodePatientName"></span><span id="imebra::WritingDataHandler::setUnicodePatientName__s.UnicodePatientNameCR"></span><span class="target" id="classimebra_1_1_writing_data_handler_1a07d04be08b4d6c313980a09a681739e9"></span>void <code class="sig-name descname">setUnicodePatientName</code><span class="sig-paren">(</span>size_t <em>index</em>, <em class="property">const</em> <a class="reference internal" href="#_CPPv4N6imebra18UnicodePatientNameE" title="imebra::UnicodePatientName">UnicodePatientName</a> &amp;<em>patientName</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N6imebra18WritingDataHandler21setUnicodePatientNameE6size_tRK18UnicodePatientName" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Write a <a class="reference internal" href="#classimebra_1_1_unicode_patient_name"><span class="std std-ref">UnicodePatientName</span></a> value. </p>
<p>If the value cannot be converted from a <a class="reference internal" href="#classimebra_1_1_patient_name"><span class="std std-ref">PatientName</span></a> value then throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_data_handler_conversion_error"><span class="std std-ref">DataHandlerConversionError</span></a>.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">index</span></code>: the element number within the buffer. Must be smaller than <a class="reference internal" href="#classimebra_1_1_writing_data_handler_1a4deb5d45a123e9571f88ec48bf1ac1d4"><span class="std std-ref">getSize()</span></a> </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">age</span></code>: the value to write </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</div>
<div class="section" id="id22">
<h4>Objective-C/Swift<a class="headerlink" href="#id22" title="Permalink to this headline">¶</a></h4>
<dl class="class">
<dt id="_CPPv424ImebraWritingDataHandler">
<span id="_CPPv324ImebraWritingDataHandler"></span><span id="_CPPv224ImebraWritingDataHandler"></span><span id="ImebraWritingDataHandler"></span><span class="target" id="interface_imebra_writing_data_handler"></span><em class="property">class </em><code class="sig-name descname">ImebraWritingDataHandler</code> : <em class="property">public</em> NSObject<a class="headerlink" href="#_CPPv424ImebraWritingDataHandler" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><a class="reference internal" href="#interface_imebra_writing_data_handler"><span class="std std-ref">ImebraWritingDataHandler</span></a> allows to write the content of a Dicom tag’s buffer. </p>
<p><a class="reference internal" href="#interface_imebra_writing_data_handler"><span class="std std-ref">ImebraWritingDataHandler</span></a> is able to write strings, numbers, date/time or ages.</p>
<p>In order to obtain a <a class="reference internal" href="#interface_imebra_writing_data_handler"><span class="std std-ref">ImebraWritingDataHandler</span></a> object for a specific tag call ImebraDataSet::getWritingDataHandler() or ImebraTag::getWritingDataHandler().</p>
<p>The <a class="reference internal" href="#interface_imebra_writing_data_handler"><span class="std std-ref">ImebraWritingDataHandler</span></a> object always works on a new and clean memory area. Once the data has been written into the data handler then call <a class="reference internal" href="#interface_imebra_writing_data_handler_1a734758aa34feabf927a24def4a784103"><span class="std std-ref">commit (ImebraWritingDataHandler)</span></a> in order to commit the data. The data is committed also when the data handler is deallocated.</p>
<p>Once the data has been committed then the data handler does not respond to further data modifications. </p>
<p>Subclassed by <a class="reference internal" href="#interface_imebra_writing_data_handler_numeric"><span class="std std-ref">ImebraWritingDataHandlerNumeric</span></a></p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt>
<span class="target" id="interface_imebra_writing_data_handler_1a4465f5636a6be9aee5bcdd1a59044343"></span><code class="sig-name descname">void ImebraWritingDataHandler::setInt32:newValue:error:(unsigned int index, signed int value, (swift_error(nonnull_error)) __attribute__)</code></dt>
<dd><p>Write a signed long integer (32 bit). </p>
<p>If the value cannot be converted from a signed long integer then set pError to ImebraDataHandlerConversionError.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">index</span></code>: the element number within the buffer. Must be smaller than <a class="reference internal" href="#interface_imebra_writing_data_handler_1a833230c586a55841265a455eba5fd53e"><span class="std std-ref">size()</span></a> </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">value</span></code>: the value to write </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pError</span></code>: set to a NSError derived class in case of error </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_writing_data_handler_1af9a10cc011d73f3ee3cb7dcb08af4104"></span><code class="sig-name descname">void ImebraWritingDataHandler::setSignedLong:newValue:error:(unsigned int index, signed int value, (swift_error(nonnull_error)) __attribute__)</code></dt>
<dd><p>Deprecated. Use setInt32() instead. </p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_writing_data_handler_1ad3da055eec706378a882cd7b906cc605"></span><code class="sig-name descname">void ImebraWritingDataHandler::setInt16:newValue:error:(unsigned int index, signed short value, (swift_error(nonnull_error)) __attribute__)</code></dt>
<dd><p>Write a signed short integer (16 bit). </p>
<p>If the value cannot be converted from a signed long integer then set pError to ImebraDataHandlerConversionError.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">index</span></code>: the element number within the buffer. Must be smaller than <a class="reference internal" href="#interface_imebra_writing_data_handler_1a833230c586a55841265a455eba5fd53e"><span class="std std-ref">size()</span></a> </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">value</span></code>: the value to write </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pError</span></code>: set to a NSError derived class in case of error </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_writing_data_handler_1ae237142df286e3a3d957ff0253bb4978"></span><code class="sig-name descname">void ImebraWritingDataHandler::setInt8:newValue:error:(unsigned int index, signed char value, (swift_error(nonnull_error)) __attribute__)</code></dt>
<dd><p>Write a signed char integer (8 bit). </p>
<p>If the value cannot be converted from a signed long integer then set pError to ImebraDataHandlerConversionError.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">index</span></code>: the element number within the buffer. Must be smaller than <a class="reference internal" href="#interface_imebra_writing_data_handler_1a833230c586a55841265a455eba5fd53e"><span class="std std-ref">size()</span></a> </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">value</span></code>: the value to write </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pError</span></code>: set to a NSError derived class in case of error </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_writing_data_handler_1a3d03198a96bdb3e17dc32298a2738f0f"></span><code class="sig-name descname">void ImebraWritingDataHandler::setUint32:newValue:error:(unsigned int index, unsigned int value, (swift_error(nonnull_error)) __attribute__)</code></dt>
<dd><p>Write an unsigned long integer (32 bit). </p>
<p>When setting a value for an AT tag (Attribute Tag) then the tag’s group must always be in the higher 16 bits of the value.</p>
<p>If the value cannot be converted from an unsigned long integer then set pError to ImebraDataHandlerConversionError.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">index</span></code>: the element number within the buffer. Must be smaller than <a class="reference internal" href="#interface_imebra_writing_data_handler_1a833230c586a55841265a455eba5fd53e"><span class="std std-ref">size()</span></a> </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">value</span></code>: the value to write </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pError</span></code>: set to a NSError derived class in case of error </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_writing_data_handler_1a1359d435579c43951d00f76e5a2aca5a"></span><code class="sig-name descname">void ImebraWritingDataHandler::setUnsignedLong:newValue:error:(unsigned int index, unsigned int value, (swift_error(nonnull_error)) __attribute__)</code></dt>
<dd><p>Deprecated. Use setUint32() instead. </p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_writing_data_handler_1af044f6ee59925f3c64b975dabe31f27a"></span><code class="sig-name descname">void ImebraWritingDataHandler::setUint16:newValue:error:(unsigned int index, unsigned short value, (swift_error(nonnull_error)) __attribute__)</code></dt>
<dd><p>Write an unsigned short integer (16 bit). </p>
<p>If the value cannot be converted from an unsigned long integer then set pError to ImebraDataHandlerConversionError.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">index</span></code>: the element number within the buffer. Must be smaller than <a class="reference internal" href="#interface_imebra_writing_data_handler_1a833230c586a55841265a455eba5fd53e"><span class="std std-ref">size()</span></a> </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">value</span></code>: the value to write </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pError</span></code>: set to a NSError derived class in case of error </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_writing_data_handler_1a978a68d9849483c51b70445a27c4e47a"></span><code class="sig-name descname">void ImebraWritingDataHandler::setUint8:newValue:error:(unsigned int index, unsigned char value, (swift_error(nonnull_error)) __attribute__)</code></dt>
<dd><p>Write an unsigned char integer (8 bit). </p>
<p>If the value cannot be converted from an unsigned long integer then set pError to ImebraDataHandlerConversionError.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">index</span></code>: the element number within the buffer. Must be smaller than <a class="reference internal" href="#interface_imebra_writing_data_handler_1a833230c586a55841265a455eba5fd53e"><span class="std std-ref">size()</span></a> </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">value</span></code>: the value to write </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pError</span></code>: set to a NSError derived class in case of error </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_writing_data_handler_1ac148ac3a49de1418ec538b07fd92d816"></span><code class="sig-name descname">void ImebraWritingDataHandler::setDouble:newValue:error:(unsigned int index, double value, (swift_error(nonnull_error)) __attribute__)</code></dt>
<dd><p>Write a double floating point value (64 bit). </p>
<p>If the value cannot be converted from a double floating point then set pError to ImebraDataHandlerConversionError.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">index</span></code>: the element number within the buffer. Must be smaller than <a class="reference internal" href="#interface_imebra_writing_data_handler_1a833230c586a55841265a455eba5fd53e"><span class="std std-ref">size()</span></a> </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">value</span></code>: the value to write </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pError</span></code>: set to a NSError derived class in case of error </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_writing_data_handler_1ac5382428b4791423243244ef0f2eb8e0"></span><code class="sig-name descname">void ImebraWritingDataHandler::setFloat:newValue:error:(unsigned int index, float value, (swift_error(nonnull_error)) __attribute__)</code></dt>
<dd><p>Write a floating point value (32 bit). </p>
<p>If the value cannot be converted from a double floating point then set pError to ImebraDataHandlerConversionError.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">index</span></code>: the element number within the buffer. Must be smaller than <a class="reference internal" href="#interface_imebra_writing_data_handler_1a833230c586a55841265a455eba5fd53e"><span class="std std-ref">size()</span></a> </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">value</span></code>: the value to write </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pError</span></code>: set to a NSError derived class in case of error </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_writing_data_handler_1ac04f5d2b07751534a583528dfa6198c8"></span><code class="sig-name descname">void ImebraWritingDataHandler::setString:newValue:error:(unsigned int index, NSString * value, (swift_error(nonnull_error)) __attribute__)</code></dt>
<dd><p>Write a string. </p>
<p>If the value cannot be converted from a string then set pError to ImebraDataHandlerConversionError.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">index</span></code>: the element number within the buffer. Must be smaller than <a class="reference internal" href="#interface_imebra_writing_data_handler_1a833230c586a55841265a455eba5fd53e"><span class="std std-ref">size()</span></a> </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">value</span></code>: the value to write </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pError</span></code>: set to a NSError derived class in case of error </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_writing_data_handler_1aaadbb13aa9568c0fe0da83c2e316c36a"></span><code class="sig-name descname">void ImebraWritingDataHandler::setDate:newValue:error:(unsigned int index, ImebraDate * value, (swift_error(nonnull_error)) __attribute__)</code></dt>
<dd><p>Write a date and/or a time. </p>
<p>If the value cannot be converted from a Date then set pError to ImebraDataHandlerConversionError.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">index</span></code>: the element number within the buffer. Must be smaller than <a class="reference internal" href="#interface_imebra_writing_data_handler_1a833230c586a55841265a455eba5fd53e"><span class="std std-ref">size()</span></a> </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">value</span></code>: the value to write </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pError</span></code>: set to a NSError derived class in case of error </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_writing_data_handler_1a391f4229227460077c4fdf576ef1a62f"></span><code class="sig-name descname">void ImebraWritingDataHandler::setAge:newValue:error:(unsigned int index, ImebraAge  * value, (swift_error(nonnull_error)) __attribute__)</code></dt>
<dd><p>Write an Age value. </p>
<p>If the value cannot be converted from an Age then set pError to ImebraDataHandlerConversionError.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">index</span></code>: the element number within the buffer. Must be smaller than <a class="reference internal" href="#interface_imebra_writing_data_handler_1a833230c586a55841265a455eba5fd53e"><span class="std std-ref">size()</span></a> </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">value</span></code>: the value to write </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pError</span></code>: set to a NSError derived class in case of error </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_writing_data_handler_1ad2c33f19f57e360676e88f9fc6364c78"></span><code class="sig-name descname">void ImebraWritingDataHandler::setPatientName:newValue:error:(unsigned int index, ImebraPatientName * value, (swift_error(nonnull_error)) __attribute__)</code></dt>
<dd><p>Write a patient name. </p>
<p>If the value cannot be converted to a patient name then set pError to ImebraDataHandlerConversionError.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">index</span></code>: the element number within the buffer. Must be smaller than <a class="reference internal" href="#interface_imebra_writing_data_handler_1a833230c586a55841265a455eba5fd53e"><span class="std std-ref">size()</span></a> </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">value</span></code>: the value to write </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pError</span></code>: set to a NSError derived class in case of error </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N24ImebraWritingDataHandler6commitEv">
<span id="_CPPv3N24ImebraWritingDataHandler6commitEv"></span><span id="_CPPv2N24ImebraWritingDataHandler6commitEv"></span><span id="ImebraWritingDataHandler::commit"></span><span class="target" id="interface_imebra_writing_data_handler_1a734758aa34feabf927a24def4a784103"></span>void <code class="sig-name descname">commit</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N24ImebraWritingDataHandler6commitEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Commit the changes to the handler’s memory. </p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Property</p>
<dl class="member">
<dt>
<span class="target" id="interface_imebra_writing_data_handler_1a833230c586a55841265a455eba5fd53e"></span><em class="property">property </em><code class="sig-name descname">ImebraWritingDataHandler::size</code></dt>
<dd><p>Resize the memory to contain the specified number of elements or return the current number of elements when read. </p>
<p>By default, <a class="reference internal" href="#interface_imebra_writing_data_handler"><span class="std std-ref">ImebraWritingDataHandler</span></a> allocates an empty memory block that must be resized in order to be filled with data. </p>
</dd></dl>

</div>
</dd></dl>

</div>
</div>
<div class="section" id="writingdatahandlernumeric">
<span id="id23"></span><h3>WritingDataHandlerNumeric<a class="headerlink" href="#writingdatahandlernumeric" title="Permalink to this headline">¶</a></h3>
<div class="section" id="id24">
<h4>C++<a class="headerlink" href="#id24" title="Permalink to this headline">¶</a></h4>
<dl class="class">
<dt id="_CPPv4N6imebra25WritingDataHandlerNumericE">
<span id="_CPPv3N6imebra25WritingDataHandlerNumericE"></span><span id="_CPPv2N6imebra25WritingDataHandlerNumericE"></span><span id="imebra::WritingDataHandlerNumeric"></span><span class="target" id="classimebra_1_1_writing_data_handler_numeric"></span><em class="property">class </em><code class="sig-name descname">WritingDataHandlerNumeric</code> : <em class="property">public</em> imebra::<a class="reference internal" href="#_CPPv4N6imebra18WritingDataHandlerE" title="imebra::WritingDataHandler">WritingDataHandler</a><a class="headerlink" href="#_CPPv4N6imebra25WritingDataHandlerNumericE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Specialized <a class="reference internal" href="#classimebra_1_1_writing_data_handler"><span class="std std-ref">WritingDataHandler</span></a> for numeric data types. </p>
<p>Includes few methods that allow accessing the raw memory containing the buffer’s data. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv4N6imebra25WritingDataHandlerNumeric25WritingDataHandlerNumericERK25WritingDataHandlerNumeric">
<span id="_CPPv3N6imebra25WritingDataHandlerNumeric25WritingDataHandlerNumericERK25WritingDataHandlerNumeric"></span><span id="_CPPv2N6imebra25WritingDataHandlerNumeric25WritingDataHandlerNumericERK25WritingDataHandlerNumeric"></span><span id="imebra::WritingDataHandlerNumeric::WritingDataHandlerNumeric__WritingDataHandlerNumericCR"></span><span class="target" id="classimebra_1_1_writing_data_handler_numeric_1a7fff1f00f5f4036da6834bdee65aab5a"></span><code class="sig-name descname">WritingDataHandlerNumeric</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N6imebra25WritingDataHandlerNumeric25WritingDataHandlerNumericERK25WritingDataHandlerNumeric" title="imebra::WritingDataHandlerNumeric::WritingDataHandlerNumeric">WritingDataHandlerNumeric</a> &amp;<em>source</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N6imebra25WritingDataHandlerNumeric25WritingDataHandlerNumericERK25WritingDataHandlerNumeric" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Copy constructor. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">source</span></code>: source <a class="reference internal" href="#classimebra_1_1_writing_data_handler_numeric"><span class="std std-ref">WritingDataHandlerNumeric</span></a> object </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK6imebra25WritingDataHandlerNumeric9getMemoryEv">
<span id="_CPPv3NK6imebra25WritingDataHandlerNumeric9getMemoryEv"></span><span id="_CPPv2NK6imebra25WritingDataHandlerNumeric9getMemoryEv"></span><span id="imebra::WritingDataHandlerNumeric::getMemoryC"></span><span class="target" id="classimebra_1_1_writing_data_handler_numeric_1a7248a3b8aa60592d6bff88a224d0f72c"></span><a class="reference internal" href="memory_management_classes.html#_CPPv4N6imebra13MutableMemoryE" title="imebra::MutableMemory">MutableMemory</a> <code class="sig-name descname">getMemory</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK6imebra25WritingDataHandlerNumeric9getMemoryEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return a <a class="reference internal" href="memory_management_classes.html#classimebra_1_1_mutable_memory"><span class="std std-ref">MutableMemory</span></a> object referencing the raw buffer’s data. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>a <a class="reference internal" href="memory_management_classes.html#classimebra_1_1_mutable_memory"><span class="std std-ref">MutableMemory</span></a> object referencing the raw buffer’s data </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N6imebra25WritingDataHandlerNumeric6assignEPKc6size_t">
<span id="_CPPv3N6imebra25WritingDataHandlerNumeric6assignEPKc6size_t"></span><span id="_CPPv2N6imebra25WritingDataHandlerNumeric6assignEPKc6size_t"></span><span id="imebra::WritingDataHandlerNumeric::assign__cCP.s"></span><span class="target" id="classimebra_1_1_writing_data_handler_numeric_1a41a31fa7c7f9103c32e70129dc48c7fb"></span>void <code class="sig-name descname">assign</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>source</em>, size_t <em>sourceSize</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N6imebra25WritingDataHandlerNumeric6assignEPKc6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Copy the content of the specified buffer into the content managed by data handler. </p>
<p><strong>Java</strong></p>
<p>In Java this method accepts a single parameter (a byte array).</p>
<p><strong>Python</strong></p>
<p>In Python this method accepts a single parameter (an array).</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">source</span></code>: a pointer to the source memory buffer </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sourceSize</span></code>: the number of bytes to copy and the new memory size </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK6imebra25WritingDataHandlerNumeric4dataEP6size_t">
<span id="_CPPv3NK6imebra25WritingDataHandlerNumeric4dataEP6size_t"></span><span id="_CPPv2NK6imebra25WritingDataHandlerNumeric4dataEP6size_t"></span><span id="imebra::WritingDataHandlerNumeric::data__sPC"></span><span class="target" id="classimebra_1_1_writing_data_handler_numeric_1ac50c9d2638d1a3aebc7af04d215f7756"></span>char *<code class="sig-name descname">data</code><span class="sig-paren">(</span>size_t *<em>pDataSize</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK6imebra25WritingDataHandlerNumeric4dataEP6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns a pointer to the buffer’s raw memory content. </p>
<p>The referenced buffer is owned by the <a class="reference internal" href="#classimebra_1_1_writing_data_handler_numeric"><span class="std std-ref">WritingDataHandlerNumeric</span></a> object and must not be freed by the client.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>a pointer to the buffer’s raw memory. The referenced buffer is owned by the <a class="reference internal" href="#classimebra_1_1_writing_data_handler_numeric"><span class="std std-ref">WritingDataHandlerNumeric</span></a> object and must not be freed by the client </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pDataSize</span></code>: a variable that will contain the raw memory’s size in bytes </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK6imebra25WritingDataHandlerNumeric4dataEPc6size_t">
<span id="_CPPv3NK6imebra25WritingDataHandlerNumeric4dataEPc6size_t"></span><span id="_CPPv2NK6imebra25WritingDataHandlerNumeric4dataEPc6size_t"></span><span id="imebra::WritingDataHandlerNumeric::data__cP.sC"></span><span class="target" id="classimebra_1_1_writing_data_handler_numeric_1a71da89e6b67864a512c70eafa2616a61"></span>size_t <code class="sig-name descname">data</code><span class="sig-paren">(</span>char *<em>destination</em>, size_t <em>destinationSize</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK6imebra25WritingDataHandlerNumeric4dataEPc6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Copies the raw memory content into the specified buffer. </p>
<p>If the allocated buffer is not large enough then the method doesn’t copy any data and just returns the required buffer’ size.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the number of bytes to be copied into the pre-allocated buffer </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">destination</span></code>: a pointer to the allocated buffer </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">destinationSize</span></code>: the size of the allocated buffer, in bytes </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK6imebra25WritingDataHandlerNumeric11getUnitSizeEv">
<span id="_CPPv3NK6imebra25WritingDataHandlerNumeric11getUnitSizeEv"></span><span id="_CPPv2NK6imebra25WritingDataHandlerNumeric11getUnitSizeEv"></span><span id="imebra::WritingDataHandlerNumeric::getUnitSizeC"></span><span class="target" id="classimebra_1_1_writing_data_handler_numeric_1ad1fa0a2b87bb8fa1aea36b9a2011ad6f"></span>size_t <code class="sig-name descname">getUnitSize</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK6imebra25WritingDataHandlerNumeric11getUnitSizeEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns the number of bytes occupied by the numbers handled by the data handler. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the number of bytes occupied by the numbers handled by the data handler </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK6imebra25WritingDataHandlerNumeric8isSignedEv">
<span id="_CPPv3NK6imebra25WritingDataHandlerNumeric8isSignedEv"></span><span id="_CPPv2NK6imebra25WritingDataHandlerNumeric8isSignedEv"></span><span id="imebra::WritingDataHandlerNumeric::isSignedC"></span><span class="target" id="classimebra_1_1_writing_data_handler_numeric_1a2d9c90cbcb41cdbd4f96554937ae3d1c"></span>bool <code class="sig-name descname">isSigned</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK6imebra25WritingDataHandlerNumeric8isSignedEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns true if the numbers handled by the data handler are signed, false otherwise. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>true if the numbers handled by the data handler are signed, false otherwise </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK6imebra25WritingDataHandlerNumeric7isFloatEv">
<span id="_CPPv3NK6imebra25WritingDataHandlerNumeric7isFloatEv"></span><span id="_CPPv2NK6imebra25WritingDataHandlerNumeric7isFloatEv"></span><span id="imebra::WritingDataHandlerNumeric::isFloatC"></span><span class="target" id="classimebra_1_1_writing_data_handler_numeric_1a6fd6138bb01f83e092837117f6919292"></span>bool <code class="sig-name descname">isFloat</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK6imebra25WritingDataHandlerNumeric7isFloatEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns true if the numbers stored in the buffer are floating point numbers, false otherwise. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>true if the numbers stored in the buffer are floating point numbers, false otherwise </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N6imebra25WritingDataHandlerNumeric8copyFromERK25ReadingDataHandlerNumeric">
<span id="_CPPv3N6imebra25WritingDataHandlerNumeric8copyFromERK25ReadingDataHandlerNumeric"></span><span id="_CPPv2N6imebra25WritingDataHandlerNumeric8copyFromERK25ReadingDataHandlerNumeric"></span><span id="imebra::WritingDataHandlerNumeric::copyFrom__ReadingDataHandlerNumericCR"></span><span class="target" id="classimebra_1_1_writing_data_handler_numeric_1a05b81477969c5da01eb8dfaac52bc894"></span>void <code class="sig-name descname">copyFrom</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N6imebra25ReadingDataHandlerNumericE" title="imebra::ReadingDataHandlerNumeric">ReadingDataHandlerNumeric</a> &amp;<em>source</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N6imebra25WritingDataHandlerNumeric8copyFromERK25ReadingDataHandlerNumeric" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Copies data from another data handler, converting the data type if necessary. </p>
<p>The data handler is resized to the same size of the source data handler.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">source</span></code>: the data handler from which the data must be copied </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</div>
<div class="section" id="id25">
<h4>Objective-C/Swift<a class="headerlink" href="#id25" title="Permalink to this headline">¶</a></h4>
<dl class="class">
<dt id="_CPPv431ImebraWritingDataHandlerNumeric">
<span id="_CPPv331ImebraWritingDataHandlerNumeric"></span><span id="_CPPv231ImebraWritingDataHandlerNumeric"></span><span id="ImebraWritingDataHandlerNumeric"></span><span class="target" id="interface_imebra_writing_data_handler_numeric"></span><em class="property">class </em><code class="sig-name descname">ImebraWritingDataHandlerNumeric</code> : <em class="property">public</em> <a class="reference internal" href="#_CPPv424ImebraWritingDataHandler" title="ImebraWritingDataHandler">ImebraWritingDataHandler</a><a class="headerlink" href="#_CPPv431ImebraWritingDataHandlerNumeric" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Specialized <a class="reference internal" href="#interface_imebra_writing_data_handler"><span class="std std-ref">ImebraWritingDataHandler</span></a> for numeric data types. </p>
<p>Includes few methods that allow accessing the raw memory containing the buffer’s data. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt>
<span class="target" id="interface_imebra_writing_data_handler_numeric_1a16884e2422221423dd251e56f9837978"></span><code class="sig-name descname">ImebraMutableMemory* ImebraWritingDataHandlerNumeric::getMemory:(NSError ** pError)</code></dt>
<dd><p>Return a <a class="reference internal" href="memory_management_classes.html#interface_imebra_mutable_memory"><span class="std std-ref">ImebraMutableMemory</span></a> object referencing the raw buffer’s data. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>a <a class="reference internal" href="memory_management_classes.html#interface_imebra_mutable_memory"><span class="std std-ref">ImebraMutableMemory</span></a> object referencing the raw buffer’s data </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pError</span></code>: set to a NSError derived class in case of error </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_writing_data_handler_numeric_1adfa67160900f3c05bd37c45b2e97d68a"></span><code class="sig-name descname">void ImebraWritingDataHandlerNumeric::assign:error:(NSData * pSource, (swift_error(nonnull_error)) __attribute__)</code></dt>
<dd><p>Copy the content of the specified buffer into the content managed by data handler. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pSource</span></code>: a pointer to the source memory buffer </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pError</span></code>: set to a NSError derived class in case of error </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_writing_data_handler_numeric_1a608bed6025a5d44519fa103421843422"></span><code class="sig-name descname">void ImebraWritingDataHandlerNumeric::copyFrom:error:(ImebraReadingDataHandlerNumeric  * pSource, (swift_error(nonnull_error)) __attribute__)</code></dt>
<dd><p>Copies data from another data handler, converting the data type if necessary. </p>
<p>The data handler is resized to the same size of the source data handler.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pSource</span></code>: the data handler from which the data must be copied </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pError</span></code>: set to a NSError derived class in case of error </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Property</p>
<dl class="member">
<dt>
<span class="target" id="interface_imebra_writing_data_handler_numeric_1aad95d95838dccd4c015597a689731f4f"></span><em class="property">property </em><code class="sig-name descname">ImebraWritingDataHandlerNumeric::unitSize</code></dt>
<dd><p>Returns the number of bytes occupied by each number handled by the data handler. </p>
</dd></dl>

<dl class="member">
<dt>
<span class="target" id="interface_imebra_writing_data_handler_numeric_1ae3be940c7be0709b30de4f740c26e80f"></span><em class="property">property </em><code class="sig-name descname">ImebraWritingDataHandlerNumeric::isSigned</code></dt>
<dd><p>Returns true if the numbers handled by the data handler are signed, false otherwise. </p>
</dd></dl>

<dl class="member">
<dt>
<span class="target" id="interface_imebra_writing_data_handler_numeric_1a6f962049cf53dfb49233bf30beef4791"></span><em class="property">property </em><code class="sig-name descname">ImebraWritingDataHandlerNumeric::isFloat</code></dt>
<dd><p>Returns true if the numbers stored in the buffer are floating point numbers, false otherwise. </p>
</dd></dl>

</div>
</dd></dl>

</div>
</div>
<div class="section" id="date">
<h3>Date<a class="headerlink" href="#date" title="Permalink to this headline">¶</a></h3>
<div class="section" id="id26">
<h4>C++<a class="headerlink" href="#id26" title="Permalink to this headline">¶</a></h4>
<dl class="class">
<dt id="_CPPv4N6imebra4DateE">
<span id="_CPPv3N6imebra4DateE"></span><span id="_CPPv2N6imebra4DateE"></span><span id="imebra::Date"></span><span class="target" id="classimebra_1_1_date"></span><em class="property">class </em><code class="sig-name descname">Date</code><a class="headerlink" href="#_CPPv4N6imebra4DateE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Stores a <a class="reference internal" href="#classimebra_1_1_date"><span class="std std-ref">Date</span></a>, Time or Date/Time value. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv4N6imebra4Date4DateERK4Date">
<span id="_CPPv3N6imebra4Date4DateERK4Date"></span><span id="_CPPv2N6imebra4Date4DateERK4Date"></span><span id="imebra::Date::Date__DateCR"></span><span class="target" id="classimebra_1_1_date_1aed15e1c65163781745fcc3c8ea69b00f"></span><code class="sig-name descname">Date</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N6imebra4Date4DateERK4Date" title="imebra::Date::Date">Date</a> &amp;<em>source</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N6imebra4Date4DateERK4Date" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Copy constructor. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">source</span></code>: source <a class="reference internal" href="#classimebra_1_1_date"><span class="std std-ref">Date</span></a> object </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N6imebra4Date4DateEKNSt8uint32_tEKNSt8uint32_tEKNSt8uint32_tEKNSt8uint32_tEKNSt8uint32_tEKNSt8uint32_tEKNSt8uint32_tEKNSt7int32_tEKNSt7int32_tE">
<span id="_CPPv3N6imebra4Date4DateEKNSt8uint32_tEKNSt8uint32_tEKNSt8uint32_tEKNSt8uint32_tEKNSt8uint32_tEKNSt8uint32_tEKNSt8uint32_tEKNSt7int32_tEKNSt7int32_tE"></span><span id="_CPPv2N6imebra4Date4DateEKNSt8uint32_tEKNSt8uint32_tEKNSt8uint32_tEKNSt8uint32_tEKNSt8uint32_tEKNSt8uint32_tEKNSt8uint32_tEKNSt7int32_tEKNSt7int32_tE"></span><span id="imebra::Date::Date__std::uint32_tC.std::uint32_tC.std::uint32_tC.std::uint32_tC.std::uint32_tC.std::uint32_tC.std::uint32_tC.std::int32_tC.std::int32_tC"></span><span class="target" id="classimebra_1_1_date_1a13dfbea2de602705634db48542b8cf28"></span><code class="sig-name descname">Date</code><span class="sig-paren">(</span><em class="property">const</em> std::uint32_t <em>initialYear</em>, <em class="property">const</em> std::uint32_t <em>initialMonth</em>, <em class="property">const</em> std::uint32_t <em>initialDay</em>, <em class="property">const</em> std::uint32_t <em>initialHour</em>, <em class="property">const</em> std::uint32_t <em>initialMinutes</em>, <em class="property">const</em> std::uint32_t <em>initialSeconds</em>, <em class="property">const</em> std::uint32_t <em>initialNanoseconds</em>, <em class="property">const</em> std::int32_t <em>initialOffsetHours</em>, <em class="property">const</em> std::int32_t <em>initialOffsetMinutes</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N6imebra4Date4DateEKNSt8uint32_tEKNSt8uint32_tEKNSt8uint32_tEKNSt8uint32_tEKNSt8uint32_tEKNSt8uint32_tEKNSt8uint32_tEKNSt7int32_tEKNSt7int32_tE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Constructor. </p>
<p>Initialize the <a class="reference internal" href="#classimebra_1_1_date"><span class="std std-ref">Date</span></a> structure with the specified values.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">initialYear</span></code>: year (0 = unused) </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">initialMonth</span></code>: month (1…12, 0 = unused) </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">initialDay</span></code>: day of the month (1…31, 0 = unused) </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">initialHour</span></code>: hour (0…23) </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">initialMinutes</span></code>: minutes (0…59) </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">initialSeconds</span></code>: seconds (0…59) </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">initialNanoseconds</span></code>: nanoseconds </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">initialOffsetHours</span></code>: hours offset from UTC </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">initialOffsetMinutes</span></code>: minutes offset from UTC </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</div>
<div class="section" id="id27">
<h4>Objective-C/Swift<a class="headerlink" href="#id27" title="Permalink to this headline">¶</a></h4>
<dl class="class">
<dt id="_CPPv410ImebraDate">
<span id="_CPPv310ImebraDate"></span><span id="_CPPv210ImebraDate"></span><span id="ImebraDate"></span><span class="target" id="interface_imebra_date"></span><em class="property">class </em><code class="sig-name descname">ImebraDate</code> : <em class="property">public</em> NSObject<a class="headerlink" href="#_CPPv410ImebraDate" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt>
<span class="target" id="interface_imebra_date_1a464fc11224a14b45378ed1c1c11e12f6"></span><code class="sig-name descname">id ImebraDate::initWithYear:month:day:hour:minutes:seconds:nanoseconds:offsetHours:offsetMinutes:(unsigned int initialYear, unsigned int initialMonth, unsigned int initialDay, unsigned int initialHour, unsigned int initialMinutes, unsigned int initialSeconds, unsigned int initialNanoseconds, int initialOffsetHours, int initialOffsetMinutes)</code></dt>
<dd><p>Constructor. </p>
<p>Initialize the Date structure with the specified values.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">initialYear</span></code>: year (0 = unused) </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">initialMonth</span></code>: month (1…12, 0 = unused) </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">initialDay</span></code>: day of the month (1…31, 0 = unused) </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">initialHour</span></code>: hour (0…23) </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">initialMinutes</span></code>: minutes (0…59) </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">initialSeconds</span></code>: seconds (0…59) </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">initialNanoseconds</span></code>: nanoseconds </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">initialOffsetHours</span></code>: hours offset from UTC </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">initialOffsetMinutes</span></code>: minutes offset from UTC </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Property</p>
<dl class="member">
<dt>
<span class="target" id="interface_imebra_date_1a6d824a06c18a667d039e66b6543d7b31"></span><em class="property">property </em><code class="sig-name descname">ImebraDate::year</code></dt>
<dd><p>Year (0 = unused) </p>
</dd></dl>

<dl class="member">
<dt>
<span class="target" id="interface_imebra_date_1a26abb12090dfa94a4dc9efa7a6808ad9"></span><em class="property">property </em><code class="sig-name descname">ImebraDate::month</code></dt>
<dd><p>Month (1…12, 0 = unused) </p>
</dd></dl>

<dl class="member">
<dt>
<span class="target" id="interface_imebra_date_1a82ed7fa0f14af13c7dbbc18f55ecc84e"></span><em class="property">property </em><code class="sig-name descname">ImebraDate::day</code></dt>
<dd><p>Day (1…12, 0 = unused) </p>
</dd></dl>

<dl class="member">
<dt>
<span class="target" id="interface_imebra_date_1a43180628d62598f798fa5e3ee63121ee"></span><em class="property">property </em><code class="sig-name descname">ImebraDate::hour</code></dt>
<dd><p>Hours. </p>
</dd></dl>

<dl class="member">
<dt>
<span class="target" id="interface_imebra_date_1a1b8003d49436bc42ae85c78083fd4772"></span><em class="property">property </em><code class="sig-name descname">ImebraDate::minutes</code></dt>
<dd><p>Minutes. </p>
</dd></dl>

<dl class="member">
<dt>
<span class="target" id="interface_imebra_date_1a87cf29c86a4d1234c4e8647ab0ea2844"></span><em class="property">property </em><code class="sig-name descname">ImebraDate::seconds</code></dt>
<dd><p>Seconds. </p>
</dd></dl>

<dl class="member">
<dt>
<span class="target" id="interface_imebra_date_1ae05b5e52d8d1b2ae1232e1841992944a"></span><em class="property">property </em><code class="sig-name descname">ImebraDate::nanoseconds</code></dt>
<dd><p>Nanoseconds. </p>
</dd></dl>

<dl class="member">
<dt>
<span class="target" id="interface_imebra_date_1a5ef5dfb6d200277014947e3ce3f5a970"></span><em class="property">property </em><code class="sig-name descname">ImebraDate::offsetHours</code></dt>
<dd><p>Offset hours from UTC. </p>
</dd></dl>

<dl class="member">
<dt>
<span class="target" id="interface_imebra_date_1a4292110db782a9941741a0c1cf485f1a"></span><em class="property">property </em><code class="sig-name descname">ImebraDate::offsetMinutes</code></dt>
<dd><p>Offset minutes from UTC. </p>
</dd></dl>

</div>
</dd></dl>

</div>
</div>
<div class="section" id="age">
<h3>Age<a class="headerlink" href="#age" title="Permalink to this headline">¶</a></h3>
<div class="section" id="id28">
<h4>C++<a class="headerlink" href="#id28" title="Permalink to this headline">¶</a></h4>
<dl class="class">
<dt id="_CPPv4N6imebra3AgeE">
<span id="_CPPv3N6imebra3AgeE"></span><span id="_CPPv2N6imebra3AgeE"></span><span id="imebra::Age"></span><span class="target" id="classimebra_1_1_age"></span><em class="property">class </em><code class="sig-name descname">Age</code><a class="headerlink" href="#_CPPv4N6imebra3AgeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Specifies an age, in days, weeks, months or years. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv4N6imebra3Age3AgeERK3Age">
<span id="_CPPv3N6imebra3Age3AgeERK3Age"></span><span id="_CPPv2N6imebra3Age3AgeERK3Age"></span><span id="imebra::Age::Age__AgeCR"></span><span class="target" id="classimebra_1_1_age_1a8ff219ea731489afb852a6d6e13c7a8f"></span><code class="sig-name descname">Age</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N6imebra3Age3AgeERK3Age" title="imebra::Age::Age">Age</a> &amp;<em>source</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N6imebra3Age3AgeERK3Age" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Copy constructor. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">source</span></code>: source <a class="reference internal" href="#classimebra_1_1_date"><span class="std std-ref">Date</span></a> object </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N6imebra3Age3AgeENSt8uint32_tE9ageUnit_t">
<span id="_CPPv3N6imebra3Age3AgeENSt8uint32_tE9ageUnit_t"></span><span id="_CPPv2N6imebra3Age3AgeENSt8uint32_tE9ageUnit_t"></span><span id="imebra::Age::Age__std::uint32_t.ageUnit_t"></span><span class="target" id="classimebra_1_1_age_1a77dd8fe5944fe246659460f4663e51b6"></span><code class="sig-name descname">Age</code><span class="sig-paren">(</span>std::uint32_t <em>initialAge</em>, <a class="reference internal" href="definition_classes.html#_CPPv4N6imebra9ageUnit_tE" title="imebra::ageUnit_t">ageUnit_t</a> <em>initialUnits</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N6imebra3Age3AgeENSt8uint32_tE9ageUnit_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Constructor. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">initialAge</span></code>: the initial age to assign to the object, in days, weeks, months or years, depending on the parameter initialUnits </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">initialUnits</span></code>: the units of the value in initialAge </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK6imebra3Age8getYearsEv">
<span id="_CPPv3NK6imebra3Age8getYearsEv"></span><span id="_CPPv2NK6imebra3Age8getYearsEv"></span><span id="imebra::Age::getYearsC"></span><span class="target" id="classimebra_1_1_age_1ad059104460009fdcd91b1526263fe4e6"></span>double <code class="sig-name descname">getYears</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK6imebra3Age8getYearsEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return the age in years. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the stored age converted to years. </p>
</dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</div>
<div class="section" id="id29">
<h4>Objective-C/Swift<a class="headerlink" href="#id29" title="Permalink to this headline">¶</a></h4>
<dl class="class">
<dt id="_CPPv49ImebraAge">
<span id="_CPPv39ImebraAge"></span><span id="_CPPv29ImebraAge"></span><span id="ImebraAge"></span><span class="target" id="interface_imebra_age"></span><em class="property">class </em><code class="sig-name descname">ImebraAge</code> : <em class="property">public</em> NSObject<a class="headerlink" href="#_CPPv49ImebraAge" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Specifies an age, in days, weeks, months or years. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt>
<span class="target" id="interface_imebra_age_1a14145f9955bd9c71846c0e18ce4562d4"></span><code class="sig-name descname">id ImebraAge::initWithAge:units:(unsigned int initialAge, ImebraAgeUnit initialUnits)</code></dt>
<dd><p>Constructor. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">initialAge</span></code>: the initial age to assign to the object, in days, weeks, months or years, depending on the parameter initialUnits </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">initialUnits</span></code>: the units of the value in initialAge </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Property</p>
<dl class="member">
<dt>
<span class="target" id="interface_imebra_age_1a6d56499101b82dc4151472e3db6ac44b"></span><em class="property">property </em><code class="sig-name descname">ImebraAge::years</code></dt>
<dd><p>Return the age in years. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the stored age converted to years. </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="member">
<dt>
<span class="target" id="interface_imebra_age_1a2906dce7f6a6d97ed7c8bc9aa5e26b9d"></span><em class="property">property </em><code class="sig-name descname">ImebraAge::age</code></dt>
<dd><p>Return the age in the units returned by the property units. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the stored age, speficied using the stored units. </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="member">
<dt>
<span class="target" id="interface_imebra_age_1a2f767c61665b28be7913e37d23bf4a6a"></span><em class="property">property </em><code class="sig-name descname">ImebraAge::units</code></dt>
<dd><p>Return the age’s units. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the age’s units </p>
</dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</div>
</div>
<div class="section" id="patientname">
<h3>PatientName<a class="headerlink" href="#patientname" title="Permalink to this headline">¶</a></h3>
<div class="section" id="id30">
<h4>C++<a class="headerlink" href="#id30" title="Permalink to this headline">¶</a></h4>
<dl class="class">
<dt id="_CPPv4N6imebra11PatientNameE">
<span id="_CPPv3N6imebra11PatientNameE"></span><span id="_CPPv2N6imebra11PatientNameE"></span><span id="imebra::PatientName"></span><span class="target" id="classimebra_1_1_patient_name"></span><em class="property">class </em><code class="sig-name descname">PatientName</code><a class="headerlink" href="#_CPPv4N6imebra11PatientNameE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Stores a patient name (in alphabetic, ideographic and phonetic forms). </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv4N6imebra11PatientName11PatientNameERK11PatientName">
<span id="_CPPv3N6imebra11PatientName11PatientNameERK11PatientName"></span><span id="_CPPv2N6imebra11PatientName11PatientNameERK11PatientName"></span><span id="imebra::PatientName::PatientName__PatientNameCR"></span><span class="target" id="classimebra_1_1_patient_name_1a7c3f875d53f1b0b3321a08160e460bc8"></span><code class="sig-name descname">PatientName</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N6imebra11PatientName11PatientNameERK11PatientName" title="imebra::PatientName::PatientName">PatientName</a> &amp;<em>source</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N6imebra11PatientName11PatientNameERK11PatientName" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Copy constructor. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">source</span></code>: source <a class="reference internal" href="#classimebra_1_1_patient_name"><span class="std std-ref">PatientName</span></a> object </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N6imebra11PatientName11PatientNameERKNSt6stringERKNSt6stringERKNSt6stringE">
<span id="_CPPv3N6imebra11PatientName11PatientNameERKNSt6stringERKNSt6stringERKNSt6stringE"></span><span id="_CPPv2N6imebra11PatientName11PatientNameERKNSt6stringERKNSt6stringERKNSt6stringE"></span><span id="imebra::PatientName::PatientName__ssCR.ssCR.ssCR"></span><span class="target" id="classimebra_1_1_patient_name_1acce89522a5a020fc07bdfd07678c131f"></span><code class="sig-name descname">PatientName</code><span class="sig-paren">(</span><em class="property">const</em> std::string &amp;<em>alphabeticRepresentation</em>, <em class="property">const</em> std::string &amp;<em>ideographicRepresentation</em>, <em class="property">const</em> std::string &amp;<em>phoneticRepresentation</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N6imebra11PatientName11PatientNameERKNSt6stringERKNSt6stringERKNSt6stringE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Constructor. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">alphabeticRepresentation</span></code>: the alphabetic representation of the patient name (UTF8 encoded) </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ideographicRepresentation</span></code>: the ideographic representation of the patient name (UTF8 encoded) </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">phoneticRepresentation</span></code>: the phonetic representation of the patient name (UTF8 encoded) </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK6imebra11PatientName27getAlphabeticRepresentationEv">
<span id="_CPPv3NK6imebra11PatientName27getAlphabeticRepresentationEv"></span><span id="_CPPv2NK6imebra11PatientName27getAlphabeticRepresentationEv"></span><span id="imebra::PatientName::getAlphabeticRepresentationC"></span><span class="target" id="classimebra_1_1_patient_name_1af3f554ee5cfe887d28058603887111a0"></span>std::string <code class="sig-name descname">getAlphabeticRepresentation</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK6imebra11PatientName27getAlphabeticRepresentationEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns the alphabetic form of the patient name (UTF8 encoded). </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>alphabetic representation of the patient name </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK6imebra11PatientName28getIdeographicRepresentationEv">
<span id="_CPPv3NK6imebra11PatientName28getIdeographicRepresentationEv"></span><span id="_CPPv2NK6imebra11PatientName28getIdeographicRepresentationEv"></span><span id="imebra::PatientName::getIdeographicRepresentationC"></span><span class="target" id="classimebra_1_1_patient_name_1a520d414a4d734e0e750cc82a9049b962"></span>std::string <code class="sig-name descname">getIdeographicRepresentation</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK6imebra11PatientName28getIdeographicRepresentationEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns the ideographic form of the patient name (UTF8 encoded). </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>ideographic representation of the patient name </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK6imebra11PatientName25getPhoneticRepresentationEv">
<span id="_CPPv3NK6imebra11PatientName25getPhoneticRepresentationEv"></span><span id="_CPPv2NK6imebra11PatientName25getPhoneticRepresentationEv"></span><span id="imebra::PatientName::getPhoneticRepresentationC"></span><span class="target" id="classimebra_1_1_patient_name_1a51099821c992c8fabbe933a482c35f48"></span>std::string <code class="sig-name descname">getPhoneticRepresentation</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK6imebra11PatientName25getPhoneticRepresentationEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns the phonetic form of the patient name (UTF8 encoded). </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>phonetic representation of the patient name </p>
</dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</div>
<div class="section" id="id31">
<h4>Objective-C/Swift<a class="headerlink" href="#id31" title="Permalink to this headline">¶</a></h4>
<dl class="class">
<dt id="_CPPv417ImebraPatientName">
<span id="_CPPv317ImebraPatientName"></span><span id="_CPPv217ImebraPatientName"></span><span id="ImebraPatientName"></span><span class="target" id="interface_imebra_patient_name"></span><em class="property">class </em><code class="sig-name descname">ImebraPatientName</code> : <em class="property">public</em> NSObject<a class="headerlink" href="#_CPPv417ImebraPatientName" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt>
<span class="target" id="interface_imebra_patient_name_1a8016fb8b5c7fb49aba93b5f862a657d3"></span><code class="sig-name descname">id ImebraPatientName::initWithAlphabeticRepresentation:ideographicRepresentation:phoneticRepresentation:(NSString * alphabeticRepresentation, NSString * ideographicRepresentation, NSString * phoneticRepresentation)</code></dt>
<dd><p>Constructor. </p>
<p>Initialize the PatientName structure with the specified values.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">alphabeticRepresentation</span></code>: The alphabetic representation of the patient name </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ideographicRepresentation</span></code>: The ideographic representation of the patient name. Can be left empty </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">phoneticRepresentation</span></code>: The phonetic representation of the patient name. Can be left empty </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Property</p>
<dl class="member">
<dt>
<span class="target" id="interface_imebra_patient_name_1a9aaa16e47e0d8b718c29e67d4a639b1d"></span><em class="property">property </em><code class="sig-name descname">ImebraPatientName::alphabeticRepresentation</code></dt>
<dd><p>The alphabetic representation of the Patient Name. </p>
</dd></dl>

<dl class="member">
<dt>
<span class="target" id="interface_imebra_patient_name_1ac6c72e46d5c69439e994aab8ad6c97b0"></span><em class="property">property </em><code class="sig-name descname">ImebraPatientName::ideographicRepresentation</code></dt>
<dd><p>The ideographic representation of the Patient Name. </p>
</dd></dl>

<dl class="member">
<dt>
<span class="target" id="interface_imebra_patient_name_1a46957ae6719840c8cdcc795f8ce2523f"></span><em class="property">property </em><code class="sig-name descname">ImebraPatientName::phoneticRepresentation</code></dt>
<dd><p>The phonetic representation of the Patient Name. </p>
</dd></dl>

</div>
</dd></dl>

</div>
</div>
<div class="section" id="unicodepatientname">
<h3>UnicodePatientName<a class="headerlink" href="#unicodepatientname" title="Permalink to this headline">¶</a></h3>
<div class="section" id="id32">
<h4>C++<a class="headerlink" href="#id32" title="Permalink to this headline">¶</a></h4>
<dl class="class">
<dt id="_CPPv4N6imebra18UnicodePatientNameE">
<span id="_CPPv3N6imebra18UnicodePatientNameE"></span><span id="_CPPv2N6imebra18UnicodePatientNameE"></span><span id="imebra::UnicodePatientName"></span><span class="target" id="classimebra_1_1_unicode_patient_name"></span><em class="property">class </em><code class="sig-name descname">UnicodePatientName</code><a class="headerlink" href="#_CPPv4N6imebra18UnicodePatientNameE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Stores a patient name with Unicode chars (in alphabetic, ideographic and phonetic forms). </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv4N6imebra18UnicodePatientName18UnicodePatientNameERK18UnicodePatientName">
<span id="_CPPv3N6imebra18UnicodePatientName18UnicodePatientNameERK18UnicodePatientName"></span><span id="_CPPv2N6imebra18UnicodePatientName18UnicodePatientNameERK18UnicodePatientName"></span><span id="imebra::UnicodePatientName::UnicodePatientName__UnicodePatientNameCR"></span><span class="target" id="classimebra_1_1_unicode_patient_name_1aa73098b3e72ac12213191dd29756994a"></span><code class="sig-name descname">UnicodePatientName</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N6imebra18UnicodePatientName18UnicodePatientNameERK18UnicodePatientName" title="imebra::UnicodePatientName::UnicodePatientName">UnicodePatientName</a> &amp;<em>source</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N6imebra18UnicodePatientName18UnicodePatientNameERK18UnicodePatientName" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Copy constructor. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">source</span></code>: source <a class="reference internal" href="#classimebra_1_1_patient_name"><span class="std std-ref">PatientName</span></a> object </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N6imebra18UnicodePatientName18UnicodePatientNameERKNSt7wstringERKNSt7wstringERKNSt7wstringE">
<span id="_CPPv3N6imebra18UnicodePatientName18UnicodePatientNameERKNSt7wstringERKNSt7wstringERKNSt7wstringE"></span><span id="_CPPv2N6imebra18UnicodePatientName18UnicodePatientNameERKNSt7wstringERKNSt7wstringERKNSt7wstringE"></span><span id="imebra::UnicodePatientName::UnicodePatientName__std::wstringCR.std::wstringCR.std::wstringCR"></span><span class="target" id="classimebra_1_1_unicode_patient_name_1aa69ec7aa1bb4b29b6cf31c96ebe8f4f9"></span><code class="sig-name descname">UnicodePatientName</code><span class="sig-paren">(</span><em class="property">const</em> std::wstring &amp;<em>alphabeticRepresentation</em>, <em class="property">const</em> std::wstring &amp;<em>ideographicRepresentation</em>, <em class="property">const</em> std::wstring &amp;<em>phoneticRepresentation</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N6imebra18UnicodePatientName18UnicodePatientNameERKNSt7wstringERKNSt7wstringERKNSt7wstringE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Constructor. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">alphabeticRepresentation</span></code>: the alphabetic representation of the patient name </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ideographicRepresentation</span></code>: the ideographic representation of the patient name </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">phoneticRepresentation</span></code>: the phonetic representation of the patient name </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK6imebra18UnicodePatientName27getAlphabeticRepresentationEv">
<span id="_CPPv3NK6imebra18UnicodePatientName27getAlphabeticRepresentationEv"></span><span id="_CPPv2NK6imebra18UnicodePatientName27getAlphabeticRepresentationEv"></span><span id="imebra::UnicodePatientName::getAlphabeticRepresentationC"></span><span class="target" id="classimebra_1_1_unicode_patient_name_1aa4015b455d4e84d9ec0a26a7b23fdf57"></span>std::wstring <code class="sig-name descname">getAlphabeticRepresentation</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK6imebra18UnicodePatientName27getAlphabeticRepresentationEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns the alphabetic form of the patient name. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>alphabetic representation of the patient name </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK6imebra18UnicodePatientName28getIdeographicRepresentationEv">
<span id="_CPPv3NK6imebra18UnicodePatientName28getIdeographicRepresentationEv"></span><span id="_CPPv2NK6imebra18UnicodePatientName28getIdeographicRepresentationEv"></span><span id="imebra::UnicodePatientName::getIdeographicRepresentationC"></span><span class="target" id="classimebra_1_1_unicode_patient_name_1a85eb33280d74820ade0008a44a58cef2"></span>std::wstring <code class="sig-name descname">getIdeographicRepresentation</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK6imebra18UnicodePatientName28getIdeographicRepresentationEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns the ideographic form of the patient name. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>ideographic representation of the patient name </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK6imebra18UnicodePatientName25getPhoneticRepresentationEv">
<span id="_CPPv3NK6imebra18UnicodePatientName25getPhoneticRepresentationEv"></span><span id="_CPPv2NK6imebra18UnicodePatientName25getPhoneticRepresentationEv"></span><span id="imebra::UnicodePatientName::getPhoneticRepresentationC"></span><span class="target" id="classimebra_1_1_unicode_patient_name_1a2d4bdda816cc4d16390521f0557bf878"></span>std::wstring <code class="sig-name descname">getPhoneticRepresentation</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK6imebra18UnicodePatientName25getPhoneticRepresentationEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns the phonetic form of the patient name. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>phonetic representation of the patient name </p>
</dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</div>
<div class="section" id="id33">
<h4>Objective-C/Swift<a class="headerlink" href="#id33" title="Permalink to this headline">¶</a></h4>
<p>Not available (<a class="reference internal" href="#_CPPv417ImebraPatientName" title="ImebraPatientName"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ImebraPatientName</span></code></a> uses Unicode on Objective-C/Swift)</p>
</div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="dicom_uid_generation_classes.html" class="btn btn-neutral float-right" title="UID generation classes" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="objects_lifecycle.html" class="btn btn-neutral float-left" title="Objects lifecycle and Object ownership" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; <a href="copyright.html">Copyright</a> 2019, Paolo Brandoli

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>